<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Mac下百度脑图快捷键]]></title>
    <url>%2Fp%2F91926421.html</url>
    <content type="text"><![CDATA[在MAC下无法使用F2快捷键编辑节点解决方案：双击某个节点，可以修改节点内容时，点击回车，此时不要再用鼠标操作，就可以使用键盘快捷键了 节点操作 ​ Enter 插入兄弟节点 ​ Tab, Insert 插入子节点 ​ Shift+Tab 插入父节点 ​ Delete 册除节点 ​ Up, Down, Left, Right 节点导航 ​ Alt+Up, Down 向上/向下调整顺序 ​ / 展开/收起节点 ​ /F2 编辑节点 ​ Shift+Enter 文本换行 ​ Ctrl+A 全选节点 ​ Ctrl+C 复制节点 ​ Ctrl+X 剪切节点 ​ Ctrl+V 粘贴节点 ​ Ctrl+B 加粗 ​ Ctrl+I 斜体 ​ Ctrl+F 查找节点 视野控制 ​ Alt+拖动，右键拖动 拖动视野 ​ 滚轮，触摸板 移动视野 ​ 空白处双击，Ctrl +Enter 居中根节点 ​ Ctrl + +，- 放大/缩小视野 布局 ​ Ctrl + Shift + L 整理布局 后悔药 ​ Ctrl+Z 撤销 ​ Ctrl+Y 重做]]></content>
      <tags>
        <tag>MAC</tag>
        <tag>快捷键</tag>
        <tag>百度脑图</tag>
        <tag>思维导图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac下Chrome快捷键大全]]></title>
    <url>%2Fp%2F91926116.html</url>
    <content type="text"><![CDATA[最近一直在使用 MAC 机器，感觉很不错，只是有很多操作不适应，找不到地方，特别是 Chrome 的快捷键操作，下午就详细的查询了下 Chrome 在 Mac 中的快捷键，做下备忘，并希望帮到更多的人。 1. 标签页和窗口快捷键 ⌘-N 打开新窗口。 ⌘-T 打开新标签页。 ⌘-Shift-N 在隐身模式下打开新窗口。 按 ⌘-O，然后选择文件。 在 Chrome 浏览器中打开计算机中的文件。 按住 ⌘ 的同时点击链接。或用鼠标中键（或鼠标滚轮）点击链接。 从后台在新标签页中打开链接。 按住 ⌘-Shift 的同时点击链接。或按住 Shift 键的同时用鼠标中键（或鼠标滚轮）点击链接。 在新标签页中打开链接并切换到刚打开的标签页。 按住 Shift 键的同时点击链接。 在新窗口中打开链接。 ⌘-Shift-T 重新打开上次关闭的标签页。Chrome 浏览器可记住最近关闭的 10 个标签页。 将标签页拖出标签栏。 在新窗口中打开标签页。 将标签页从标签栏拖到现有窗口中。 在现有窗口中打开标签页。 同时按 ⌘-Option 和向右箭头键。 切换到下一个标签页。 同时按 ⌘-Option 和向左箭头键。 切换到上一个标签页。 ⌘-W 关闭当前标签页或弹出窗口。 ⌘-Shift-W 关闭当前窗口。 点击并按住浏览器工具栏中的后退或前进箭头。 在新标签页中显示浏览历史记录。 按 Delete 或 ⌘-[ 转到当前标签页的上一页浏览历史记录。 按 Shift-Delete 或 ⌘-] 转到当前标签页的下一页浏览历史记录。 按住 Shift 键的同时点击窗口左上角的 + 按钮。 最大化窗口。 ⌘-M 最小化窗口。 ⌘-H 隐藏 Chrome 浏览器。 ⌘-Option-H 隐藏其他所有窗口。 ⌘-Q 关闭 Chrome 浏览器。 2. Chrome 浏览器功能快捷键 ⌘-Shift-B 打开和关闭书签栏。 ⌘-Option-B 打开书签管理器。 ⌘-, 打开“偏好设置”对话框。 ⌘-Y 打开“历史记录”页。 ⌘-Shift-J 打开“下载内容”页。 ⌘-Shift-Delete 打开“清除浏览数据”对话框。 3. 地址栏快捷键 键入搜索字词，然后按 Enter 键。 使用默认搜索引擎进行搜索。 键入搜索引擎关键字，按空格键，然后键入搜索字词，再按 Enter 键。 使用与关键字相关联的搜索引擎进行搜索。 首先键入搜索引擎网址，然后在系统提示时按 Tab 键，键入搜索字词，再按 Enter 键。 使用与网址相关联的搜索引擎进行搜索。 键入网址，然后按 ⌘-Enter。 在新后台标签页中打开网址。 ⌘-L 突出显示网址。 ⌘-Option-F 在地址栏中输入“?”。在问号后键入搜索字词可用默认搜索引擎执行搜索。 同时按 Option 和向左箭头键。 将光标移到地址栏中的前一个关键字词 同时按 Option 和向右箭头键。 在地址栏中将光标移到下一个关键字词 同时按 Shift-Option 和向左箭头键。 在地址栏中突出显示上一关键字词 同时按 Shift-Option 和向右箭头键。 在地址栏中突出显示下一关键字词 ⌘-Delete 在地址栏中删除光标前的字词 在地址栏菜单中按 Page Up 或 Page Down。 在菜单中选择上一条目或下一条目。 4. 网页快捷键 ⌘-P 打印当前网页。 ⌘-Shift-P 打开“网页设置”对话框。 ⌘-S 保存当前网页。 ⌘-Shift-I 通过电子邮件发送当前网页。 ⌘-R 重新载入当前网页。 ⌘-, 停止载入当前网页。 ⌘-F 打开查找栏。 ⌘-G 在查找栏中查找下一条与输入内容相匹配的内容。 ⌘-Shift-G 或 Shift-Enter 在查找栏中查找上一条与输入内容相匹配的内容。 ⌘-E 使用所选内容查找。 ⌘-J 跳到所选内容。 ⌘-Option-I 打开“开发人员工具”。 ⌘-Option-J 打开“JavaScript 控制台”。 ⌘-Option-U 打开当前网页的源代码。 按住 Option 键，然后点击链接。 下载链接目标。 将链接拖到书签栏中。 将链接保存为书签。 ⌘-D 将当前网页保存为书签。 ⌘-Shift-D 将所有打开的标签页以书签的形式保存在新文件夹中。 ⌘-Shift-F 在全屏模式下打开网页。再按一次 ⌘-Shift-F 可退出全屏模式。 ⌘-+ 放大网页上的所有内容。 ⌘ 和 - 缩小网页上的所有内容。 ⌘-0 将网页上的所有内容恢复到正常大小。 ⌘-Shift-H 在当前标签页中打开主页。 空格键 向下滚动网页。 ⌘-Option-F 搜索网页。 5. 文本快捷键 ⌘-C 将突出显示的内容复制到剪贴板中。 ⌘-Option-C 将您正在查看的网页的网址复制到剪贴板中。 ⌘-V 从剪贴板中粘贴内容。 ⌘-Shift-Option-V 粘贴内容并应用周围文本的格式。 ⌘-X 或 Shift-Delete 删除突出显示的内容并将其复制到剪贴板中。 ⌘-Z 撤消最后一步操作。 ⌘-Shift-Z 重复最后一步操作。 ⌘-X 删除突出显示的内容并将其保存到剪贴板中（剪切）。 ⌘-A 选择当前网页上的所有文本。 ⌘-: 打开“拼写和语法”对话框。 ⌘-; 检查当前网页上的拼写和语法。 原文首发博客园： Mac 下 Chrome 快捷键大全 http://www.cnblogs.com/xunziji/archive/2012/08/23/2652530.html]]></content>
      <tags>
        <tag>MAC</tag>
        <tag>Chrome</tag>
        <tag>快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[atom 支持微信小程序开发环境]]></title>
    <url>%2Fp%2F88477779.html</url>
    <content type="text"><![CDATA[在使用 atom 进行 微信小程序开发 时，atom 无法识别 .wxml 模板文件 和 .wxss 样式文件 语法做代码高亮，也不能使用 emmet 插件进行补全。 支持语法高亮在 config.cson(用户设置) 里 core 配置下添加 customFileTypes 配置即可支持 .wxml 和 .wxss 的语法高亮12345678core: customFileTypes: &quot;source.css&quot;: [ &quot;wxss&quot; ] &quot;text.html.mustache&quot;: [ &quot;wxml&quot; ] emmet tab 快捷键支持 .wxml 补全emmet 要先识别当前文件的语法格式才能做自动拓展，故必须先完成上面步骤让 atom 能识别 wxml 语法才行在 keymap.cson(用户键盘映射) 中添加如下配置即可12&#39;atom-text-editor[data-grammar&#x3D;&quot;text html mustache&quot;]:not([mini])&#39;: &#39;tab&#39;: &#39;emmet:expand-abbreviation-with-tab&#39; 参考链接： http://flight-manual.atom.io/using-atom/sections/basic-customization/#customizing-language-recognition]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>编辑器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对象的属性特性]]></title>
    <url>%2Fp%2F88231259.html</url>
    <content type="text"><![CDATA[数据属性存储器属性存储器属性不包含数据值，只包含包含 getter 和 setter 函数(非必需)。 getter负责查询值，它不带任何参数，setter则负责设置键值，值是以参数的形式传递，在他的函数体中，一切的return都是无效的。和普通属性不同的是，存储器属性在只声明了get或set时，对于读和写是两者不可兼得的，当它只拥有了getter方法，那么它仅仅只读，同样的，当它只有setter方法，那么您读到的永远都是undefined。如何声明对象存储器属性呢？ 最快捷的途径就是利用对象字面量的语法来写了，请看下述一段代码： 123456789var oo &#x3D; &#123; name : &#39;贤心&#39;, get sex()&#123; return &#39;man&#39;; &#125;&#125;;&#x2F;&#x2F;显然这是不允许的，因为贤心并不希望外界去改变他是男性的事实，所以对于sex只设置了只读功能oo.sex &#x3D; &#39;woman&#39;;console.log(oo.sex); &#x2F;&#x2F;结果依然是man 定义一个已经声明的函数作为的getter和setter方法，使用Object.defineProperty 下面这个例子展示使用getter和setter方法扩展 Date原型，为预定义好的Date类添加一个year的属性。定义属性year的getter和setter方法用到了Date类中已存在的getFullYear和setFullYear方法。 定义属性year的getter和setter：1234567891011var d &#x3D; Date.prototype;Object.defineProperty(d, &quot;year&quot;, &#123; get: function() &#123; return this.getFullYear() &#125;, set: function(y) &#123; this.setFullYear(y) &#125;&#125;);&#x2F;&#x2F;通过一个Date对象使用getter和setter:var now &#x3D; new Date();console.log(now.year); &#x2F;&#x2F; 2017now.year &#x3D; 2030;console.log(now);]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML元素的属性]]></title>
    <url>%2Fp%2F82012217.html</url>
    <content type="text"><![CDATA[属性分类必需属性img图片标签中的src alt 可选属性img图片的标签 width height 标准(全局)属性全局属性是所有HTML元素共有的属性; 它们可以用于所有元素，即使属性可能对某些元素不起作用。 我们可以在所有的HTML元素上指定全局属性，甚至是在标准里没有指定的元素。这意味着任何非标准元素仍必须能够应用这些属性，即使使用这些元素意味着文档不再是html5兼容的。例如，虽然&lt;foo&gt;不是一个有效的HTML元素，但是html5兼容的浏览器隐藏了标记为&lt;foo hidden&gt;...&lt;foo&gt;的内容。 除了基本的HTML全局属性之外，还存在以下全局属性 - xml:lang 和 xml:base ——两者都是从XHTML规范继承，但为了兼容性而被保留的。 - 多重`aria-*`属性，用于改善可访问性。 - 事件处理程序 属性：onabort, onautocomplete, onautocompleteerror, onblur, oncancel, oncanplay, oncanplaythrough, onchange, onclick, onclose, oncontextmenu, oncuechange, ondblclick, ondrag, ondragend, ondragenter, ondragexit, ondragleave, ondragover, ondragstart, ondrop, ondurationchange, onemptied, onended, onerror, onfocus, oninput, oninvalid, onkeydown, onkeypress, onkeyup, onload, onloadeddata, onloadedmetadata, onloadstart, onmousedown, onmouseenter, onmouseleave, onmousemove, onmouseout, onmouseover, onmouseup, onmousewheel, onpause, onplay, onplaying, onprogress, onratechange, onreset, onresize, onscroll, onseeked, onseeking, onselect, onshow, onsort, onstalled, onsubmit, onsuspend, ontimeupdate, ontoggle, onvolumechange, onwaiting. 全局属性列表accesskey 提供了为当前元素生成键盘快捷键的提示。这个属性由空格分隔的字符列表组成。浏览器应该使用在计算机键盘布局上存在的第一个。 autocapitalize 控制用户的文本输入是否和如何自动大写，它可以有以下的值： off or none，没有应用自动大写（所有字母都默认为小写字母）。 on or sentences，每个句子的第一个字母默认为大写字母;所有其他字母都默认为小写字母。 words，每个单词的第一个字母默认为大写字母;所有其他字母都默认为小写字母。 characters，所有的字母都应该默认为大写。 class 一个以空格分隔的元素的类名（classes ）列表，它允许 CSS 和 Javascript 通过类选择器 (class selectors) 或DOM方法( document.getElementsByClassName)来选择和访问特定的元素。 contenteditable 一个枚举属性（enumerated attribute），表示元素是否可被用户编辑。 如果可以，浏览器会调整元素的部件（widget）以允许编辑。 true 或者空字符串，表明元素是可被编辑的； false，表明元素不能被编辑。 contextmenu &lt;menu&gt; 的id ，作为该元素的上下文菜单（已经不被支持，将从所有浏览器中删除）。 data-* 一类自定义数据属性，它赋予我们在所有 HTML 元素上嵌入自定义数据属性的能力，并可以通过脚本(一般指JavaScript) 与 HTML 之间进行专有数据的交换。所有这些自定义数据属性都可以通过所属元素的 HTMLElement 接口来访问。 HTMLElement.dataset 属性可以访问它们。 dir 一个指示元素中文本方向的枚举属性。它的取值如下： ltr, 指从左到右，用于那种从左向右书写的语言（比如英语）； rtl, 指从右到左，用于那种从右向左书写的语言（比如阿拉伯语）； auto, 指由用户代理决定方向。它在解析元素中字符时会运用一个基本算法，直到发现一个具有强方向性的字符，然后将这一方向应用于整个元素。 draggable 一种枚举属性，指示是否可以 使用 Drag and Drop API 拖动元素。它可以有以下的值： true, 这表明元素可能被拖动 false, 这表明元素可能不会被拖动 dropzone 枚举属性，指示可以使用 Drag and Drop API 在元素上删除哪些类型的内容。 它可以具有以下值： copy，表示drop将创建被拖动元素的副本 move，表示拖动的元素将移动到此新位置。 link，将创建一个指向拖动数据的链接。 exportparts Used to transitively export shadow parts from a nested shadow tree into a containing light tree. hidden 布尔属性表示该元素尚未或不再相关。例如，它可用于隐藏在登录过程完成之前无法使用的页面元素。浏览器不会呈现此类元素。不得使用此属性隐藏可合法显示的内容 id 定义唯一标识符（ID），该标识符在整个文档中必须是唯一的。 其目的是在链接（使用片段标识符），脚本或样式（使用CSS）时标识元素。 inputmode 向浏览器提供有关在编辑此元素或其内容时要使用的虚拟键盘配置类型的提示。主要用于 &lt;input&gt;元素，但在contenteditable模式下可用于任何元素。 is 允许您指定标准HTML元素应该像已注册的自定义内置元素一样（有关更多详细信息，请参阅使用自定义元素）。 注意: item *属性是 WHATWG HTML Microdata feature的一部分。 itemid 项的唯一全局标识符。 itemprop 用于向项添加属性。 每个HTML元素都可以指定一个itemprop属性，其中一个itemprop由一个名称和值对组成。 itemref 只有不是具有itemscope属性的元素的后代，它的属性才可以与使用itemref项目相关联。它提供了元素ID列表（而不是itemids）以及文档中其他位置的其他属性。 itemscope itemscope（通常）与itemtype一起使用，以指定包含在关于特定项目代码块中的HTML。 itemscope创建Item并定义与之关联的itemtype的范围。 itemtype是描述项及其属性上下文的词汇表（例如schema.org）的有效URL。 itemtype 指定将用于在数据结构中定义itemprops（项属性）的词汇表的URL。 itemscope用于设置数据结构中按itemtype设置的词汇表的生效范围。 lang 帮助定义元素的语言:不可编辑元素所在的语言，或者应该由用户编写的可编辑元素的语言。该属性包含一个“语言标记”(由用连字符分隔的“语言子标记”组成)，格式在 Tags for Identifying Languages (BCP47) 中定义。xml:lang 优先于它。 part 元素的部件名称的空格分隔列表。Part名称允许CSS通过::part() 伪元素选择和设置阴影关联树中的特定元素。 slot 将shadow DOM阴影关联树中的一个沟槽分配给一个元素：具有slot属性的元素被分配给由&lt;slot&gt;元素创建的沟槽，其name属性的值与slot属性的值匹配。 spellcheck 枚举属性定义是否可以检查元素是否存在拼写错误。它可能具有以下值： true，表示如果可能，应检查元素是否存在拼写错误; false, 表示不应检查元素的拼写错误。 style 含要应用于元素的CSS样式声明。 请注意，建议在单独的文件中定义样式。 该属性和&lt;style&gt;元素主要用于快速样式化，例如用于测试目的。 tabindex 整数属性，指示元素是否可以获取输入焦点（可聚焦），是否应该参与顺序键盘导航，如果是，则表示哪个位置。它可能需要几个值： 负值表示该元素应该是可聚焦的，但不应通过顺序键盘导航到达; 0 表示元素应通过顺序键盘导航可聚焦和可到达，但其相对顺序由平台约定定义; 正值意味着元素应该可以通过顺序键盘导航进行聚焦和访问;元素聚焦的顺序是tabindex的增加值。如果多个元素共享相同的tabindex，则它们的相对顺序遵循它们在文档中的相对位置。 title 包含表示与其所属元素相关信息的文本。 这些信息通常可以作为提示呈现给用户,但不是必须的。 translate 枚举属性，用于指定在页面本地化时是否转换元素的属性值及其Text 节点子节点的值，或者是否保持它们不变。它可以具有以下值： 空字符串和&quot;yes&quot;，表示元素将被翻译。 &quot;no&quot;, 表示该元素不会被翻译。 事件属性onclick onmouseover onmouseout 参考:[HTML（超文本标记语言）全局属性](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes) [HTML 属性参考](https://developer.mozilla.org/zh-CN/docs/web/html/attributes)]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>前端</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端常用的工具软件及js库]]></title>
    <url>%2Fp%2F81818956.html</url>
    <content type="text"><![CDATA[css重置样式文件https://github.com/necolas/normalize.css可伸缩布局方案https://github.com/amfe/lib-flexible]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端开发常用工具]]></title>
    <url>%2Fp%2F80112853.html</url>
    <content type="text"><![CDATA[开发工具webstormvscodesublimeatom 测试工具IETester模拟器]]></content>
  </entry>
  <entry>
    <title><![CDATA[浏览器兼容]]></title>
    <url>%2Fp%2F80112243.html</url>
    <content type="text"><![CDATA[HackHTML hack12&lt;!-- [if lte IE6]&gt; &lt;[endif]--&gt; CSS 值hackCSS 选择器hack12345678&#x2F;* IE 6 and below *&#x2F;* html selector &#123;&#125;&#x2F;* IE 7 and below *&#x2F;selector, &#123;&#125; 兼容IE5和IE6不识别子代选择器，但是识别后代选择器 IE6不兼容交集选择器里的类选择器连写 浮动问题一个（前面）盒子浮动，另外一个盒子不浮动，在IE7下呈现出左右依次贴边显示效果，IE5和IE6呈现出3px的间距 双倍margin的问题设置与浮动方向相同方向的margin在IE6下第一个元素会出现双倍间距的问题]]></content>
  </entry>
  <entry>
    <title><![CDATA[hexo坑之让百度分享支持Https]]></title>
    <url>%2Fp%2F75994925.html</url>
    <content type="text"><![CDATA[背景最近整理博客，想给加个分享功能 过程博客用hexo生成的，本身集成了集中第三方分享插件，最后选了百度分享，但是发现本地测试没问题，托管到GitHub就不能用了 解决那么就网上搜查资料吧 发现网上解决方法基本上是同一个，这个作者的方案：https://github.com/hrwhisper/baiduShare 我就直接拿来主义了，fork到了我自己到项目https://github.com/snjylin/baiduShare下稍微做了修改，将static/api/js/share.js中的staticUrl:&quot;http://bdimg.share.baidu.com/&quot;修改为 staticUrl:&quot;https://baidushare.secretbase.vip/&quot; 再修改文件 /layout/_partials/share/baidushare.swig将对应的百度分享代码中，把 http://bdimg.share.baidu.com/ 改为 //www.secretbase.vip/baiduShare/ 这里因为我设置了GitHub page，并CNAME到了二级域名baidushare.secretbase.vip下，可以直接访问，你也可以fork作者的仓库通过改为自己的GitHub page来访问 修改主题配置文件。在主题目录下的_config.yml目录下，添加如下配置:12baidushare: type: button 然后，就可以正常使用了]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>建站</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GoogleAdSense申请提示“网站已下线或无法访问”]]></title>
    <url>%2Fp%2F75938452.html</url>
    <content type="text"><![CDATA[背景第一次申请Google AdSense，遭到了拒绝，提示“网站已下线或无法访问” 解决思路查看自己的网站，能正常访问，么有问题。但没有测试其他国家能否正常访问。查阅网上资料，初步判定是域名解析问题，需要添加两条境外解析 记录类型 A主机记录 @解析路线 境外记录值 服务器名或主机IP 记录类型 A主机记录 www解析路线 境外记录值 服务器名或主机IP 结果等待。。。 成功。]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo优化URL结构]]></title>
    <url>%2Fp%2F75934424.html</url>
    <content type="text"><![CDATA[背景hexo 默认的 url 是permalink: :year/:month/:day/:title/ 特别长，层级也太多，不利于SEO 之前修改了一次,修改成了permalink: :title.html 还是很长，而且有汉字的时候会转码，之前专门建了个项目放demo，过长的URL引用起来很费劲。 于是想要改成时间戳的形式，一般文章的发表不会隔那么近，倒也不太影响 遇到的问题用的第三方文章阅读次数计数是对应文章url的，文章URL变了之后阅读次数都变0了 解决查找资料…… 已经发表的文章url还是用标题，新增的文章url采用时间戳 修改hexo设置文件_config.yml，增加一个urlname属性123permalink: :urlname.htmlpermalink_defaults: urlname: index修改 scaffold/post.md文件，在Front-matter区域增加一个urlname属性12345---title: &#123;&#123; title &#125;&#125;urlname: &#123;&#123; timestamp &#125;&#125;date: &#123;&#123; date &#125;&#125;--- 手动修改hexo文件 /node_modules/hexo/lib/hexo/post.js 12345678910111213const preservedKeys &#x3D; [&#39;title&#39;, &#39;slug&#39;, &#39;path&#39;, &#39;layout&#39;, &#39;date&#39;, &#39;content&#39;, &#39;timestamp&#39;]; &#x2F;&#x2F; 添加timestamp... &#x2F;&#x2F; 省略中间代码Post.prototype.create &#x3D; function(data, replace, callback) &#123; ... &#x2F;&#x2F; 省略中间代码 data.timestamp &#x3D; moment().unix(); &#x2F;&#x2F; 添加timestamp ... &#x2F;&#x2F; 省略中间代码&#125;; 测试可用，终于可以告别冗长的URL啦～～]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>建站</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[下载视频的chrome扩展程序]]></title>
    <url>%2F%E4%B8%8B%E8%BD%BD%E8%A7%86%E9%A2%91%E7%9A%84chrome%E6%89%A9%E5%B1%95%E7%A8%8B%E5%BA%8F.html</url>
    <content type="text"><![CDATA[DownieDownie 是 Mac OS X 上的一个超级易于使用的视频下载工具。支持国内的优酷和土豆以及国外的Youtube，如果你对视频下载有强烈的需求，那么Downie 是一个简单易用的视频下载工具。 YouTube视频下载器需要前往YouTube视频下载器官网下载。将此扩展程序添加到Chrome后，当打开YouTube视频时，您会在YouTube界面上的订阅按钮旁边看到下载按钮。总之，YouTube视频下载器扩展程序可让您轻松保存YouTube中的视频供您自己使用。]]></content>
  </entry>
  <entry>
    <title><![CDATA[影单]]></title>
    <url>%2F%E5%BD%B1%E5%8D%95.html</url>
    <content type="text"><![CDATA[奥黛丽·赫本 电影 01 罗马假日(Roman Holiday) - 1953年 02 蒂凡尼的早餐(Breakfast at Tiffany’s) - 1961年 03 窈窕淑女(My Fair Lady) - 1964年 04 战争与和平(War and Peace) - 1956年 05 偷龙转凤(How to Steal a Million) - 1966年 06 盲女惊魂记(Wait Until Dark) - 1967年 07 修女传(The Nun’s Story) - 1959年 08 龙凤配(Sabrina) - 1953年 09 甜姐(Funny Face) - 1957年 10 黄昏之恋(Love in the Afternoon) - 1956年 11 谜中谜(Charade) - 1963年 12 直到永远(Always) - 1989年]]></content>
      <categories>
        <category>清单</category>
      </categories>
      <tags>
        <tag>todolist</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[书单]]></title>
    <url>%2F%E4%B9%A6%E5%8D%95.html</url>
    <content type="text"><![CDATA[《平凡的世界》 作者: 路遥 《活着》 作者: 余华 《百年孤独》 作者 : [哥伦比亚] 加西亚•马尔克斯 《1984》 作者 : [英] 乔治•奥威尔 《瓦尔登湖》 作者: (美)亨利戴维梭罗 《三体》 作者: 刘慈欣 《三重门》 作者: 韩寒 《万历十五年》 作者: 黄仁宇 《围城》 作者: 钱钟书 《悲惨世界》 作者: 雨果 《月亮和六便士》 作者 : [英] 威廉•萨默塞特•毛姆 《解忧杂货店》 作者 : [日] 东野圭吾 《霍乱时期的爱情》 作者 : [哥伦比亚] 加西亚•马尔克斯 《杀死一只知更鸟》 作者 : [美] 哈珀•李 《不能承受的生命之轻》 作者: [捷克] 米兰•昆德拉 《白鹿原》 作者: 陈忠实 《挪威的森林》 作者 : [日] 村上春树 《穆斯林的葬礼》 作者: 霍达 《局外人》 作者: 阿尔贝·加缪 《麦田里的守望者》 《了不起的盖茨比》 《基督山伯爵》 《苏菲的世界》 《没有人给他写信的上校》 作者 : [哥伦比亚] 加西亚•马尔克斯 《枪炮、病菌与钢铁》 《渴望生活·梵高传》 《小王子》 《追风筝的人》 《人类简史》 《漫长的告别》 《暗算》 《额尔古纳河右岸》 《乡关何处》 《酒吧长谈》 《给青年小说家的信》 《看不见的大猩猩》 《动物精神》 《万寿寺》 《飘》 《房思琪的初恋乐园》 《未来简史》 《树上的男爵》 作者 : [意] 伊塔洛·卡尔维诺 《生存与命运》 作者 : [苏] 瓦·格罗斯曼 《巨人的陨落》 作者 : [英] 肯·福莱特 《查令十字街84号》 《无人生还》 《尘埃落定》 《人类群星闪耀时》 《贝多芬传》 罗曼-罗兰 《米开朗琪罗传》 罗曼-罗兰 《托尔斯泰传》 罗曼-罗兰 《詹姆斯-乔伊斯传》 理查德-艾尔曼 《天才之为责任——维特根斯坦》 《知无涯者——拉马努金》 《孤独的猎手：卡森·麦卡勒斯传》 《忏悔录》 《钢铁是怎样炼成的》 《日瓦戈医生》 《滚雪球-沃伦巴菲特传》 《回忆录》格雷厄姆 《萨姆沃尔顿传》 《乔布斯传》 《牛顿传》 《希特勒传》 《本·拉登传：一个恐怖大亨的隐秘人生》 《毛泽东传》 特里尔 《红太阳是怎样升起的》 高华 《邓小平时代》 傅高义著 《五柳先生传》 《史记》 《洛克菲勒自传》 《人性的光辉-林肯传》（戴尔.卡耐基著） 《富兰克林自传》 《但丁传》薄伽丘 《我的奋斗》 《爱因斯坦传》 《世界因你而不同》 《激荡三十年》 《我的一个世纪》董竹君 《明朝那些事儿》 《我不要你死于一事无成》 法齐娅·库菲]]></content>
      <categories>
        <category>清单</category>
      </categories>
      <tags>
        <tag>todolist</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css属性书写顺序（重点）]]></title>
    <url>%2Fcss%E5%B1%9E%E6%80%A7%E4%B9%A6%E5%86%99%E9%A1%BA%E5%BA%8F%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89.html</url>
    <content type="text"><![CDATA[建议遵循以下顺序： 布局定位属性：display / position / float / clear / visibility / overflow （建议display第一个写，关系到模式） 自身属性：width / height / margin / padding / border / background 文本属性：color / font / text-decoration / text-align / vertical-align / white-space / break-word 其他属性（css3）：content / cursor / border-radius / box-shadow / text-shadow / background: linear-gradient …]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>前端</tag>
        <tag>css</tag>
        <tag>规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PS常用操作及cutterman插件使用]]></title>
    <url>%2FPS%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%8F%8Acutterman%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8.html</url>
    <content type="text"><![CDATA[常见图片格式ps切片工具使用利用图层切图利用辅助线切图cutterman插件安装使用官网：http://www.cutterman.cn/zh/cutterman]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>前端</tag>
        <tag>PhotoShop</tag>
        <tag>设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css清除浮动]]></title>
    <url>%2Fcss%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8.html</url>
    <content type="text"><![CDATA[什么时候清除浮动？1.父级没高度2.子盒子浮动了3.影响下面布局了，我们就应该清除浮动了 清除浮动方法额外标签法（隔墙法）123456789101112131415161718192021&lt;style&gt; .son &#123; float: left; weight: 100px; height: 100px; background-color: #0f0; &#125; .clearfix &#123; clear: both; &#125; .another &#123; width: 700px; height: 150px; background-color: #000; &#125;&lt;&#x2F;style&gt;&lt;div class&#x3D;&quot;father&quot;&gt; &lt;div class&#x3D;&quot;son&quot;&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;clearfix&quot;&gt;&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;div class&#x3D;&quot;another&quot;&gt;&lt;&#x2F;div&gt; 父级overflow: hidden;1234567891011121314151617181920&lt;style&gt; .father &#123; overflow: hidden; &#125; .son &#123; float: left; weight: 100px; height: 100px; background-color: #0f0; &#125; .another &#123; width: 700px; height: 150px; background-color: #000; &#125;&lt;&#x2F;style&gt;&lt;div class&#x3D;&quot;father&quot;&gt; &lt;div class&#x3D;&quot;son&quot;&gt;&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;div class&#x3D;&quot;another&quot;&gt;&lt;&#x2F;div&gt; 父级after伪元素123456789101112131415161718192021222324252627&lt;style&gt; .son &#123; float: left; weight: 100px; height: 100px; background-color: #0f0; &#125; .another &#123; width: 700px; height: 150px; background-color: #000; &#125; .clearfix:after &#123; content: &quot;&quot;; display: block; height: 0; visibility: hidden; clear: both; &#125; .clearfix &#123; *zoom: 1; &#x2F;* 兼容IE6、7 | ie6,7专门清除浮动的样式 *&#x2F; &#125;&lt;&#x2F;style&gt;&lt;div class&#x3D;&quot;father clearfix&quot;&gt; &lt;div class&#x3D;&quot;son&quot;&gt;&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;div class&#x3D;&quot;another&quot;&gt;&lt;&#x2F;div&gt; 父级双伪元素12345678910111213141516171819202122232425262728&lt;style&gt; .son &#123; float: left; weight: 100px; height: 100px; background-color: #0f0; &#125; .another &#123; width: 700px; height: 150px; background-color: #000; &#125; .clearfix:before, .clearfix:after &#123; content: &quot;&quot;; display: table; &#125; .clearfix:after &#123; clear: both; &#125; .clearfix &#123; *zoom: 1; &#x2F;* 兼容IE6、7 | ie6,7专门清除浮动的样式 *&#x2F; &#125;&lt;&#x2F;style&gt;&lt;div class&#x3D;&quot;father clearfix&quot;&gt; &lt;div class&#x3D;&quot;son&quot;&gt;&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;div class&#x3D;&quot;another&quot;&gt;&lt;&#x2F;div&gt; 清除浮动的方式 优点 缺点 额外标签法（隔墙法） 通俗易懂，书写方便 添加许多无意义的标签，结构化较差 父级overflow: hidden; 书写简单 溢出隐藏 父级after伪元素 结构语义化正确 由于IE6-7不支持:after，兼容性问题 父级双伪元素 结构语义化正确 由于IE6-7不支持:after，兼容性问题]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>前端</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css三大特性]]></title>
    <url>%2Fcss%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7.html</url>
    <content type="text"><![CDATA[css层叠性多种css样式的叠加 css样式冲突采取的原则 样式冲突，遵循的原则是就近原则。哪个样式离着结构近，就执行那个样式。 样式不冲突，不会层叠。哪些常见的样式会有继承写出css优先级的算法计算常见选择器的叠加值 css继承性css优先级（重点）1）权重计算公式| 标签选择器 | 计算权重公式 || - | - || 继承或者* | 0,0,0,0 || 每个元素（标签选择器） | 0,0,0,1 || 每个类，伪类 | 0,0,1,0 || 每个ID | 0,1,0,0 || 每个行内样式 style=”” | 1,0,0,0 || 每个 !important 重要的 | ∞无穷大 | 2）权重叠加数位之间是没有进制的 比如：0,0,0,5 + 0,0,0,5 = 0,0,0,10 而不是 0,0,1,0，所以不会存在10个div能赶上一个类选择器的情况。 3）继承的权重是0修改样式，一定要看该标签有没有被选中。 如果选中了，那么以上面的公式来计算权重 如果没有选中，那么权重是0，因为继承的权重为0 注意： 有2个特殊标签 链接和 h 标题 它们浏览器有自己默认的样式，继承的权重为0，所以，还是要单独给链接和标题一个样式。]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>前端</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css命名规范]]></title>
    <url>%2Fcss%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83.html</url>
    <content type="text"><![CDATA[CSS命名规范 页面结构 命名 头 header 内容 content/container 尾 footer 导航 nav 侧栏 sidebar 栏目 column 外围整体布局宽度 wrapper 左右中 left right center 登录条 loginbar 标志 logo 广告/标语 banner 页面主体 main 热点 hot 新闻 news 下载 download 子导航 subnav 菜单 menu 子菜单 submenu 搜索 search 友情链接 friendlink 页脚 footer 版权 copyright 滚动 scroll 内容 content 尾 footer 签页 tab 文章列表 list 提示信息 msg 小技巧 tips 栏目标题 title 加入 joinus 指南 guild 服务 service 注册 register 状态 status 投票 vote 合作伙伴 partner 容器 container 内容 content/container 页面主体 main 主导航 mainbav 子导航 subnav 顶导航 topnav 边导航 sidebar 左导航 leftsidebar 右导航 rightsidebar 菜单 menu 子菜单 submenu 标题 title 摘要 summary 登录 login 登录条 loginbar 注册 register 搜索 search 功能区 shop(如购物车，收银台) 标题 title 加入 joinus 状态 status 按钮 btn 滚动 scroll 标签页 tab 文章列表 list 提示信息 msg 当前的 current 小技巧 tips 图标 icon 注释 note 指南 guild 服务 service 热点 hot 新闻 news 下载 download 投票 vote 合作伙伴 partner 友情链接 friendlink 版权 copyright 面包屑 breadcrumb 商标 label css文件功能 命名 主要的 master.css 模块 module.css 基本共用 base.css 布局，版面 layout.css 主题 themes.css 专栏 columns.css 文字 font.css 表单 forms.css 补丁 mend.css 打印 print.css 注意事项：1.一律小写；2.尽量用英文；3.不加中杠和下划线；4.尽量不缩写单词]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>前端</tag>
        <tag>css</tag>
        <tag>规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css书写规范]]></title>
    <url>%2Fcss%E4%B9%A6%E5%86%99%E8%A7%84%E8%8C%83.html</url>
    <content type="text"><![CDATA[css书写规范空格规范「强制」选择器与 { 之间必须包含空格。示例：12.selector &#123;&#125;「强制」属性名与之后的 : 之间不允许包含空格，: 与属性值之间必须包含空格。示例：1font-size: 12px; 选择器规范「强制」并集选择器，每个选择器声明必须独占一行。示例：1234567891011&#x2F;* good *&#x2F;.post,.page,.comment &#123; line-height: 1.5;&#125;&#x2F;* bad *&#x2F;.post, .page, .comment &#123; line-height: 1.5;&#125;「建议」一般情况下，选择器的嵌套层级应不大于3级，位置靠后的限定条件应尽可能精确。示例：1234567&#x2F;* good *&#x2F;#username input &#123;&#125;.comment .avatar &#123;&#125;&#x2F;* bad *&#x2F;.page .header .login input &#123;&#125;.comment div * &#123;&#125; 属性规范「强制」属性定义必须另起一行。示例：12345678&#x2F;* good *&#x2F;.selector &#123; margin: 0; padding: 0;&#125;&#x2F;* bad *&#x2F;.selector &#123; margin: 0; padding: 0; &#125;「强制」属性定义后必须以分号结束。示例：123456789&#x2F;* good *&#x2F;.selector &#123; margin: 0;&#125;&#x2F;* bad *&#x2F;.selector &#123; margin: 0&#125;]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>前端</tag>
        <tag>css</tag>
        <tag>规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css盒子阴影]]></title>
    <url>%2Fcss%E7%9B%92%E5%AD%90%E9%98%B4%E5%BD%B1.html</url>
    <content type="text"><![CDATA[12&#x2F;* box-shadow: 水平阴影 垂直阴影 模糊距离(虚实) 阴影尺寸(影子大小) 阴影颜色 内&#x2F;外阴影(默认外阴影); *&#x2F;box-shadow: 2px 2px 2px 2px #000;]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>前端</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css盒子模型（css重点）]]></title>
    <url>%2Fcss%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%EF%BC%88css%E9%87%8D%E7%82%B9%EF%BC%89.html</url>
    <content type="text"><![CDATA[css学习三大重点：css盒子模型、浮动、定位 看透网页布局本质： 首先利用CSS设置好盒子的大小，然后摆放盒子的位置。 最后把网页元素比如文字图片等等，放入盒子里面。 以上两步，就是网页布局的本质 盒子模型（Box Model）所谓盒子模型，就是把HTML页面中的布局元素看作是一个矩形的盒子，也就是一个盛装内容的容器 细线表格 通过表格的cellspacing=&quot;0&quot;，将单元格与单元格之间的border-collapse： collapse; 表示相邻边框合并在一起 计算盒子实际大小padding会撑大原来的盒子解决： 通过给设置了宽高的盒子，减去相应的内边距的值，维持盒子原有的大小特殊情况：如果这个盒子没有宽度，则padding不会撑开盒子 文字居中和盒子居中区别 文字水平居中是 text-align: center; 而且还可以让行内元素和行内块居中对齐 块级盒子水平居中 左右margin改为auto块级盒子水平居中1.必须有宽度2.左右外边距设置为auto盒子里面的文字 行内元素、行内块居中对齐水平居中 text-align: center; 插入图片和背景图片区别1.插入图片 我们用的最多 比如产品展示类 移动位置只能靠盒模型 padding margin2.背景图片我们一般用于 小图标背景 或者 超大背景图片 背景图片只能通过 background-position 清除元素默认的内外边距为了灵活方便的控制网页中的元素，制作网页时，我们需要将元素的默认内外边距清除1234* &#123; margin: 0; padding: 0;&#125;注意： 行内元素为了照顾兼容性，尽量只设置左右内外边距，不要设置上下内外边距 1）相邻块元素垂直外边距合并解决方案：尽量只给一个盒子添加margin值 2）嵌套块元素垂直外边距的合并（塌陷） 对于两个嵌套关系的块元素，如果父元素没有上内边距及边框 父元素的上外边距会与子元素的上外边距发生合并 合并后的外边距为两者中较大者解决方案：1.可以为父元素定义上边框2.可以为父元素定义上内边距3.可以为父元素添加overflow: hidden;还有其他方法，比如浮动、固定、绝对定位的盒子不会有问题。。 盒子模型布局稳定性根据稳定性来分，建议：按照 优先使用 宽度(width) 其次 使用内边距(padding) 再次 外边距(margin)width &gt; padding &gt; margin原因： margin会有外边距合并 还有ie6下面margin加倍的bug（讨厌）所以最后用 padding会影响盒子大小，需要进行加减计算（麻烦）其次使用 width没有问题 我们经常使用宽度剩余法 高度剩余法来做]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>前端</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css背景]]></title>
    <url>%2Fcss%E8%83%8C%E6%99%AF.html</url>
    <content type="text"><![CDATA[123background-repeat: no-repeat;&#x2F;* 这种写法一般是 超大背景图片的做法 背景定位 *&#x2F;background-position: center top; 背景附着解释背景是滚动的还是固定的语法：1background-attachment: scroll || fixed 参数 作用 scroll 背景图像是随对象内容滚动 fixed 背景图像固定 背景简写background: 属性的值的书写顺序官方并没有强制标准。为了可读性，建议如下写：background: 背景颜色 背景图片地址 背景平铺 背景滚动 背景位置;background: background-color background-image background-repeat background-attachment background-position;语法：1background: transparent url(image.jpg) repeat-y scroll center top; 背景总结| 属性 | 作用 | 值 || - | - | - || background-color | 背景颜色 | 预定义的颜色值/十六进制/RGB代码 || background-image | 背景图片 | url(图片路径) || background-repeat | 是否平铺 | repeat/no-repeat/repeat-x/repeat-y || background-position | 背景位置 | length/position 分别是x和y坐标，切记如果有精确数值单位，则必须按照先x后y的写法 || background-attachment | 背景固定还是滚动 | scroll/fixed || 背景简写 | 更简单 | 背景颜色 背景图片 背景平铺 背景滚动 背景位置; 它们没有顺序 || 背景透明 | 让盒子半透明 | background: rgba(0,0,0,0.3); 后面必须是4个值 |]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>前端</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[标签显示模式]]></title>
    <url>%2F%E6%A0%87%E7%AD%BE%E6%98%BE%E7%A4%BA%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[标签显示模式（display）重点 什么是标签显示模式标签以什么方式进行显示，比如div自己占一行，比如span一行可以放很多个作用： 网页的标签非常多，在不同地方会用到不同类型的标签，以便更好的完成网页标签的类型（分类）HTML标签一般分为块标签和行内标签两种，它们也称块元素和行内元素 块级元素特点：1）自己独占一行2）高度、宽度、外边距以及内边距都可以控制3）宽度默认是容器的100%4）是一个容器及盒子，里面可以放行内或者块级元素注意： 只有文字才能组成段落 因此 p 里面不能放块级元素，特别是 p 不能放 div 同理还有标签h1,h2,h3,h4,h5,h6,dt，它们都是文字类块级标签，里面不能放其他块级元素 行内元素常见的行内元素： 等，其中标签最典型的行内元素，有的地方也称内联元素特点：1）相邻行内元素在一行上，一行可以显示多个2）高、宽直接设置是无效的3）默认宽度就是它本身内容的宽度4）行内元素只能容纳文本或者其他行内元素注意： 链接里面不能再放链接 特殊情况a里面可以放块级元素，但是给a转换一下块级模式最安全 行内块元素在行内元素中有几个特殊的标签 ，可以对它们设置宽高和对齐属性，有些资料可能会称它们为行内块元素特点：1）和相邻行内元素（行内块）在一行上，但是之间会有空白缝隙，一行可以显示多个2）默认宽度就是它本身内容的宽度3）高度，行高、外边距以及内边距都可以控制 三种模式总结区别| 元素模式 | 元素排列 | 设置样式 | 默认宽度 | 包含 || - | - | - | - | - || 块级元素 | 一行只能放一个块级元素 | 可以设置宽度高度 | 容器的100% | 容器级可以包含任何标签 || 行内元素 | 一行可以放多个行内元素 | 不可以直接设置宽度高度 | 它本身内容的宽度 | 容纳文本或者其他行内元素 || 行内块元素 | 一行放多个行内块元素 | 可以设置宽度高度 | 它本身内容的宽度 | |]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>前端</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css选择器]]></title>
    <url>%2Fcss%E9%80%89%E6%8B%A9%E5%99%A8.html</url>
    <content type="text"><![CDATA[链接伪类选择器 注意： 写的时候顺序尽量不要颠倒，按照lvha的顺序。否则可能引起错误 记忆法 love hate 爱上了讨厌 lv 包包 非常 hao 因为叫链接伪类，所以都是利用交集选择器 a:link a:hover 因为a链接浏览器具有默认样式，所以我们实际工作中都需要给链接单独指定样式 实际工作开发中，我们很少写全四个状态，一般写法如下：12345678a &#123; &#x2F;* a是标签选择器 所有的链接 *&#x2F; font-weight: 700; font-size: 16px; color: gray;&#125;a:hover &#123; &#x2F;* :hover 是链接伪类选择器 鼠标经过 *&#x2F; color: red; &#x2F;* 鼠标经过的时候，由原来的灰色变成了红色 *&#x2F;&#125; 复合选择器总结 选择器 作用 特征 使用情况 隔开符号及用法 后代选择器 用来选择元素后代 是选择所有的子孙后代 较多 符号是空格 .nav a 子代选择器 选择最近一级元素 只选亲儿子 较少 符号是&gt; .nav&gt;p 交集选择器 选择两个标签交集的部分 既是 又是 较少 没有符号 p.one 并集选择器 选择某些相同样式的选择器 可以用于集体声明 较多 符号是逗号 .nav,header 链接伪类选择器 给链接更改状态 较多 重点记住 a{} 和 a:hover 实际开发的写法]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>前端</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css字体]]></title>
    <url>%2Fcss%E5%AD%97%E4%BD%93.html</url>
    <content type="text"><![CDATA[font-sizefont-familycss字体特殊写法（Unicode）为什么使用Unicode字体在css中设置字体名称，直接写中文是可以的。但是在文件编码（GB2312，UTF-8等）不匹配时会产生乱码的错误。xp系统不支持类似微软雅黑的中文 解决方案方案一：可以使用英文来代替。比如：font-family:“Microsoft Yahei”。方案二：在css直接使用Unicode编码来写字体名称可以避免这些错误。使用Unicode写中文字体名称，浏览器是可以正确的解析的。font-family: “\5FAE\8F6F\96C5\9ED1”; 表示设置字体为微软雅黑 字体名称 英文名称 Unicode编码 宋体 SimSun \5B8B\4F53 新宋体 NSimSun \65b0\5b8b\4f53 黑体 SimHei \9ed1\4f53 微软雅黑 Microsoft YaHei \5fae\8f6f\96c5\9ed1 楷体_GB2312 KaiTi_GB2312 \6977\4f53_GB2312 隶书 LiSu \96b6\4e66 幼圆 YouYuan \5e7c\5706 华文黑细 STXiHei \534e\6587\9ed1\7ec6 细明体 MingLiU \7ec6\660e\4f53 新细明体 PMingLiU \65b0\7ec6\660e\4f53 为照顾不同电脑的字体安装问题，我们尽量只使用宋体和微软雅黑中文字体 font-weightnormal : 正常的字体。相当于number为400。声明此值将取消之前任何设置bold : 粗体。相当于number为700。也相当于b对象的作用bolder : IE5+ 特粗体lighter : IE5+ 细体number : IE5+ 100 | 200 | 300 | 400 | 500 | 600 | 700 | 800 | 900 提倡： 我们平时更喜欢用数字来表示加粗和不加粗。（实际开发中用数字来表示会更好） font-stylenormal : 正常的字体italic : 斜体。对于没有斜体变量的特殊字体，将应用obliqueoblique : 倾斜的字体 字体综合写法font: 综合设置字体样式（重点）基本语法：选择器&#123; font: font-style font-weight font-size/line-height font-family; &#125;使用font属性时，必须严格按上面语法格式中的顺序书写，不能更换顺序，各个属性以空格隔开。其中不需要设置的属性可以省略（取默认值），但必须保留font-size和font-family属性，否则font属性将不起作用。 font总结| 属性 | 表示 | 注意点 || - | - | - || font-size | 字号 | 我们通常用的单位是px像素，一定要跟上单位 || font-family | 字体 | 实际工作中按照团队约定来写字体 || font-weight | 字体粗细 | 记住加粗是700或bold 不加粗是normal或者400 机组数字不要跟单位 || font-style | 字体样式 | 记住倾斜是italic 不倾斜是normal 工作中最常用normal || font | 字体连写 | 1.连写是有顺序的 不能随意换位置 2.其中字号和字体必须同时出现 | 行高 line-height顶线 中线 基线 底线行高测量方法：基线和基线的距离为行高 行高利用最多的地方：单行文本垂直居中行高 = 上距离 + 内容高度 + 下距离上距离和下距离总是相等的，因此文字看上去是垂直居中的 行高和高度的三种关系 行高 等 高度 文字会垂直居中 行高 大于 高度 文字会偏下 行高 小于 高度 文字会偏上]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>前端</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git使用]]></title>
    <url>%2Fgit%E4%BD%BF%E7%94%A8.html</url>
    <content type="text"><![CDATA[背景换电脑重装git，遇到一些坑 过程1.查看是否已经有了ssh密钥：cd ~/.ssh如果没有密钥（No such file or directory）则不会有此文件夹，有则备份删除 2.生成SSH密钥$ ssh-keygen -t rsa -C &quot;your_email@yourmail.com&quot;后面的your_email@youremail.com改为你的邮箱。直接点回车，说明会在默认文件id_rsa上生成ssh key然后系统要求输入密码，直接按回车表示不设密码重复密码时也是直接回车，之后提示你shh key已经生成成功最后得到了两个文件：id_rsa和id_rsa.pub 3.在github上添加ssh密钥，这要添加的是“id_rsa.pub”里面的公钥github右上角个人中心-&gt;settings-&gt;SSH and GPG keys-&gt;New SSH keytitle随便填，一般填写方便区分的名字，比如使用这个公钥的那台机器名，key粘贴刚才复制的公钥 4.验证是否成功$ ssh -T git@github.comThe authenticity of host ‘github.com (207.97.227.239)’ can’t be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added ‘github.com,207.97.227.239′ (RSA) to the list of known hosts.ERROR: Hi tekkub! You’ve successfully authenticated, but GitHub does not provide shell accessConnection to github.com closed. 5.使用GitHub1）获取源码1$ git clone git@github.com:snjylin&#x2F;test.git我这里安装的时候提示“git命令需要使用开发者工具。您要现在安装该工具吗”查阅资料，可以通过Xcode安装，我这里安装了homebrew就正常了 安装 HomebrewHomebrew12&#x2F;usr&#x2F;bin&#x2F;ruby -e &quot;$(curl -fsSL https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Homebrew&#x2F;install&#x2F;master&#x2F;install)&quot;brew -v #验证brew是否安装成功这个地方我安装完提示-bash: brew: command not found，去网上找了解决办法，有一种提到比较多的方法123sudo vim .bash_profile #以root身份来打开并创建.bash_profileexport PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;bin:$PATH #在.bash_profile文件中写入这句，为PATH添加&#x2F;usr&#x2F;local&#x2F;bin的路径source .bash_profile #更新配置后的环境变量关闭Terminal再打开Terminal，brew -v但是我这样操作并没有用，重新安装后就好了 2)在命令行上创建新的仓库，GitHub建议每个存储库都包含一个自述文件、许可证和.gitignore。123456echo &quot;# test&quot; &gt;&gt; README.mdgit initgit add README.mdgit commit -m &quot;first commit&quot;git remote add origin git@github.com:snjylin&#x2F;test.gitgit push -u origin master 3)从命令行推送现有仓库12git remote add origin git@github.com:snjylin&#x2F;test.gitgit push -u origin master 4)从其他仓库导入代码可以使用Subversion、Mercurial或TFS项目中的代码初始化仓库。 6.设置username和email，因为github每次commit都会记录他们一般情况下需要设置全局config12$ git config --global user.name&quot;your name&quot;$ git config --global user.email&quot;your_email@youremail.com&quot;也可以每个项目单独设置config（因为之前公司项目和自己的项目是分开的，不是用的相同的config），cd到项目文件夹设置：12$ git config user.name&quot;your name&quot;$ git config user.email&quot;your_email@youremail.com&quot;]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>前端</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue+Webpack打造TODO应用]]></title>
    <url>%2FVue%2BWebpack%E6%89%93%E9%80%A0TODO%E5%BA%94%E7%94%A8.html</url>
    <content type="text"><![CDATA[需求分析：记录需要做的事项做完的事项打钩、取消打钩筛选功能：还未完成，已经完成，全部显示还有几条未做的事项清除所有已完成事项事项删除功能]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[视频解析]]></title>
    <url>%2F%E8%A7%86%E9%A2%91%E8%A7%A3%E6%9E%90.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[一些常用符号的英文表示]]></title>
    <url>%2F%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%AC%A6%E5%8F%B7%E7%9A%84%E8%8B%B1%E6%96%87%E8%A1%A8%E7%A4%BA.html</url>
    <content type="text"><![CDATA[&lt; is less than 小于号 &gt; is greater than 大于号 = is equal to 等于号 + plus 加号；正号 - minus 减号；负号 ± plus or minus 正负号 × is multiplied by 乘号 ÷ is divided by 除号 ≠ is not equal to 不等号 ≡ is equivalent to 全等于号 ≤ is not less than 小于等于号 ≥ is not more than 大于等于号 ≢is less than or equal to 小于或等于号 ≣ is more than or equal to 大于或等于号 % per cent 百分之… ‰ per mill 千分之… ∞ infinity 无限大号 ○ circumference 圆周 π pi 圆周率 △ triangle 三角形 ∑ (sigma) summation of 总和 ° degree 度 ′ minute 分 ″ second 秒 ℃ Celsius system 摄氏度]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue知识点梳理]]></title>
    <url>%2Fvue%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86.html</url>
    <content type="text"><![CDATA[环境IDEwebstorm vscode npmvue-cli webpack cnpm nvm Chromevue调试插件 认识Vue第一个demo声明式渲染条件渲染列表事件 热部署gulpwebpack 认识样式Sasspostcss 前置知识代码规范eslint 学习资料官网 社区 基本概念模板语法计算属性指令class，style绑定条件渲染列表渲染事件处理表单输入绑定 组件基础生命周期模块化思想 组件组件通信方式props$parentemit eventVuex 动画Vue-routerVue-resource（官方推荐Axios）常用API####vue.use propsDOMeltemplaterender 渲染服务端渲染打包编译 vue文件结构； 插值语法，数据、js表达式； 指令（指令缩写）@click, v-if, :href 计算属性 computed 监听属性 watch 使用场景 watch 异步场景 computed 数据联动watch通常监听的是一个变量（可能是单一的变量或数组）或者一个常量，computed可以监听很多个变量，但是这个变量一定要是在vue这个实例里的 条件渲染v-if列表渲染v-forClass与Style绑定 vue如何工程化？vue代码规范，如何优雅的写vue代码？如何调试vue？]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[win10下搭建vue开发环境]]></title>
    <url>%2Fwin10%E4%B8%8B%E6%90%AD%E5%BB%BAvue%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83.html</url>
    <content type="text"><![CDATA[1.下载对应系统的Node.js版本2.下载完成后，双击msi文件，开始安装Node.js，—— accept，Next—— 更改安装位置(例如：D:\Develop\nodejs)，next—— Add to PATH，Next—— Install—— Finish3.打开cmd切换到安装目录下，测试是否安装成功12node -v &#x2F;&#x2F; 显示node版本号说明安装成功npm -v &#x2F;&#x2F; 显示npm版本号说明自带的npm安装成功4.环境配置这里的环境配置主要配置的是npm安装的全局模块所在的路径，以及缓存cache的路径，之所以要配置，是因为以后在执行类似：npm install express [-g] （后面的可选参数-g，g代表global全局安装的意思）的安装语句时，会将安装的模块安装到【C:\Users\用户名\AppData\Roaming\npm】路径中，占C盘空间。 —— 在安装文件夹【D:\Develop\nodejs】下创建两个文件夹【node_global】及【node_cache】 —— 创建完两个空文件夹之后，打开cmd命令窗口，输入 12npm config set prefix &quot;D:\Develop\nodejs\node_global&quot;npm config set cache &quot;D:\Develop\nodejs\node_cache&quot; —— 接下来设置环境变量，关闭cmd窗口，回到桌面 “我的电脑”-右键-“属性”-“高级系统设置”-“高级”-“环境变量” —— 进入环境变量对话框 在【系统变量】下新建【NODE_PATH】，输入【D:\Develop\nodejs\node_global\node_modules】， 将【用户变量】下的【Path】由【C:\Users\用户名\AppData\Roaming\npm】修改为【D:\Develop\nodejs\node_global】]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue</tag>
        <tag>开发环境</tag>
        <tag>win10</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML头部部分用法]]></title>
    <url>%2FHTML%E5%A4%B4%E9%83%A8%E9%83%A8%E5%88%86%E7%94%A8%E6%B3%95.html</url>
    <content type="text"><![CDATA[分析源码：看&lt;head&gt; &lt;meta&gt;标签1.兼容性配置1&lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;Edge,chrome&#x3D;1&quot;&gt; &#x2F;&#x2F; 使IE用最高版本Edge去渲染，如果有chrome浏览器使用chrome浏览器渲染页面 2.渲染1&lt;meta name&#x3D;&quot;renderer&quot; content&#x3D;&quot;webkit&quot;&gt; &#x2F;&#x2F; 双核浏览器优先使用webkit引擎渲染页面 3.dns预解析1&lt;link rel&#x3D;&quot;dns-prefetch&quot; href&#x3D;&quot;&quot;&gt; &#x2F;&#x2F; href里和当前域名是不同的域名，通常是存放静态资源的域名，加快静态资源加载（比如加快图片加载，dns预解析可以是一个可以优化的点，提升网站性能） 4.字符集1&lt;meta http-equiv&#x3D;&quot;content-type&quot; content&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot;&gt; 5.关键词&amp;描述：SEO12&lt;meta name&#x3D;&quot;keywords&quot; content&#x3D;&quot;&quot;&gt;&lt;meta name&#x3D;&quot;description&quot; content&#x3D;&quot;&quot;&gt; 相关参考:HTML-head头部浅析]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>前端</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo使用过程中遇到的坑]]></title>
    <url>%2Fhexo%E4%BD%BF%E7%94%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91.html</url>
    <content type="text"><![CDATA[安装hexo后，初始化博客，出现bash: hexo: command not found找到hexo的安装目录，我的是：G:\nodejs\node_global\node_modules\hexo-cli\bin，将此目录新增到系统环境变量path中(注：Administrator改成你自己的账户名) 参考1]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>建站</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ECMAScript6]]></title>
    <url>%2FECMAScript6.html</url>
    <content type="text"><![CDATA[es3 es5 es6常量 作用域 箭头函数 默认参数 对象代理 变量声明es5:vares6新增:letconst]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[h5唤醒app解决方案]]></title>
    <url>%2Fh5%E5%94%A4%E9%86%92app%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html</url>
    <content type="text"><![CDATA[背景 产品需求：h5页面唤醒app，如果app有h5页面对应的页面，则打开对应的页面，否则打开app首页 如果本地安装了app那么直接打开，否则ios要跳转到app-store，android则要跳到对应的市场 方案 魔窗：开始收费了，弃用 js实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&#x2F;** * 判断浏览器类型 * @return &#123;Object:&#123;key[sting]:value[boolean]&#125;&#125; key:浏览器名；value:true&#x2F;false *&#x2F;var browser &#x3D; (function()&#123; var u &#x3D; navigator.userAgent; return &#123; trident: u.indexOf(&#39;Trident&#39;) &gt; -1, &#x2F;&#x2F;IE内核 presto: u.indexOf(&#39;Presto&#39;) &gt; -1, &#x2F;&#x2F;opera内核 webKit: u.indexOf(&#39;AppleWebKit&#39;) &gt; -1, &#x2F;&#x2F;苹果、谷歌内核 gecko: u.indexOf(&#39;Gecko&#39;) &gt; -1 &amp;&amp; u.indexOf(&#39;KHTML&#39;) &#x3D;&#x3D; -1,&#x2F;&#x2F;火狐内核 mobile: !!u.match(&#x2F;AppleWebKit.*Mobile.*&#x2F;), &#x2F;&#x2F;是否为移动终端 ios: !!u.match(&#x2F;\(i[^;]+;( U;)? CPU.+Mac OS X&#x2F;), &#x2F;&#x2F;ios终端 android: u.indexOf(&#39;Android&#39;) &gt; -1 || u.indexOf(&#39;Linux&#39;) &gt; -1, &#x2F;&#x2F;android终端或者uc浏览器 iPhone: u.indexOf(&#39;iPhone&#39;) &gt; -1 , &#x2F;&#x2F;是否为iPhone或者QQHD浏览器 iPad: u.indexOf(&#39;iPad&#39;) &gt; -1, &#x2F;&#x2F;是否iPad webApp: u.indexOf(&#39;Safari&#39;) &#x3D;&#x3D; -1, &#x2F;&#x2F;是否web应该程序，没有头部与底部 weixin: u.indexOf(&#39;MicroMessenger&#39;) &gt; -1, &#x2F;&#x2F;是否微信 （2015-01-22新增） qq: u.match(&#x2F;\sQQ&#x2F;i) &#x3D;&#x3D; &quot; qq&quot; &#x2F;&#x2F;是否QQ &#125;;&#125;)();&#x2F;** * 本地已安装app时调起，未安装时下载 * @param &#123;Object&#125; button 点击操作的对象 * @param &#123;Object&#125; params 对象参数 * @return &#123;[type]&#125; [description] *&#x2F;function open_or_download_app(button, params)&#123; $(button).click(function(e)&#123; if (browser.ios) &#123; window.setTimeout(function()&#123; window.location &#x3D; ios_applink; &#125;, 50); window.setTimeout(function() &#123; window.location.reload(); &#125;, 500); window.location &#x3D; params.scheme; &#125; else if (browser.android) &#123; window.setTimeout(function()&#123; window.location &#x3D; android_applink; &#125;, 50); window.setTimeout(function() &#123; window.location.reload(); &#125;, 500); window.location &#x3D; params.scheme; &#125; &#125;);&#125;; 相关（摘录自参考内容）什么是Deeplink?Deeplink是App应用中的深度链接，如果把App看做一个网站，那么Deeplink就是网站中的一个页面，比如产品页面，活动促销页面等。Deeplink在App市场推广运营中有很好的意义: 使用Deeplink的广告商可以在用户点击广告后直接进入指定的Appp, 而没有使用Deeplink的App广告只能在点击后将用户跳转到App首页上。为了更好的解释Deeplink，请见下面的图片： Deeplink在App运营中的作用Deeplink在App运营中的重要作用在于提升转换率，好比是网站推广运营中的Landing Page (广告进入页面），App运营者可用独立制作出适合广告投放人群的Deeplink, 在用户点击广告后转移至App中的Deeplink页面，而不是无论什么用户都转移到App首页上。 例如：如果在一款汽车资讯类App推广中使用Deeplink, 我们可以针对中档汽车做一个Deeplink，在App页面中展现中档价位汽车，偏重价格与促销做活动宣传图片。 针对高档汽车做另外一个Deeplink，展现高档价位汽车，针对品众与座驾享受做宣传。 然后在投放时，我们可以选择DSP投放，将不同收入人群做不同的定向广告，针对中等收入人群的App广告中链接到中档价位汽车Deeplink中，针对高收入人群的App广告中链接到高档价位汽车的Deeplink中，提升广告效果与转化率。 参考：1.你知道App推广神技“Deferred Deeplink”吗?]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>h5</tag>
        <tag>app</tag>
        <tag>deeplink</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信页面打开链接,引导在其他浏览器打开的引导页实现]]></title>
    <url>%2F%E5%BE%AE%E4%BF%A1%E9%A1%B5%E9%9D%A2%E6%89%93%E5%BC%80%E9%93%BE%E6%8E%A5%2C%E5%BC%95%E5%AF%BC%E5%9C%A8%E5%85%B6%E4%BB%96%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%93%E5%BC%80%E7%9A%84%E5%BC%95%E5%AF%BC%E9%A1%B5%E5%AE%9E%E7%8E%B0.html</url>
    <content type="text"><![CDATA[背景微信访问网站时，网页内容不显示，显示引导内容，让用户用浏览器打开 实现判断为微信浏览器时，阻止页面加载，提示“点击右上角用浏览器打开”信息阻止页面加载需要在document文档头部载入相关js代码1234&lt;script&gt; window.stop(); &#x2F;&#x2F; 停止窗口的加载。 document.write(&#39;&lt;div&gt;点击右上角用浏览器打开&lt;&#x2F;div&gt;&#39;);&lt;&#x2F;script&gt;[Window stop() 方法] 由于脚本的加载顺序，stop()方法不能停止包含它的文档的加载，但是它将停止加载大型图像、新窗口和其他延迟加载的对象。[HTML DOM write() 方法] write() 方法可向文档写入 HTML 表达式或 JavaScript 代码。]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>h5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[抓包软件的使用记录]]></title>
    <url>%2F%E6%8A%93%E5%8C%85%E8%BD%AF%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95.html</url>
    <content type="text"><![CDATA[背景移动端页面抓包，Mac OS 软件CharlesMac OS系统可用 1.下载安装包安装，Charles官网，我是同事发的个破解版，可以网上随便找个。2.配置代理使移动设备可以连接到Charles。Proxy -&gt; Proxy Settings默认端口是8888，根据实际情况可修改。手机配置代理，保证手机和pc在同一网络下，代理服务器ip设为连接的pc的ip，端口8888打开要调试的页面，请求就会先发送到Charles，然后验证是否允许访问。点击Allow 手机抓包出现unknown和乱码的问题在电脑上安装CA证书 打开charles，点击help-&gt;SSL Proxying-&gt;Install Charles Root Certificatehttps://www.v2ex.com/t/255040https://www.cnblogs.com/xuxiaolu/p/6186410.html Fiddler下载安装包https://www.telerik.com/download/fiddler/fiddler-osx-beta Wireshark下载安装包]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>抓包</tag>
        <tag>Fiddler</tag>
        <tag>Charles</tag>
        <tag>Wireshark</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动开发中需要注意的问题]]></title>
    <url>%2F%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91%E4%B8%AD%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98.html</url>
    <content type="text"><![CDATA[背景 做用于在移动app中的h5页面时，需要从一个页面跳到另一个页面。同事告知移动端使用&lt;a&gt;标签会有一些坑，可能会导致页面多次跳转的问题，尽量避免使用&lt;a&gt;标签 测试了一下，ios单独使用click事件写的跳转或者&lt;a&gt;标签都可以正常跳转，使用&lt;a&gt;标签跳出去再回到当前页面再使用click事件写的跳转就会多打开一个页面，每多跳转出去一次就多打开一个页面== click事件里调用了ios的方法打开页面 1234567&lt;div class&#x3D;&quot;btn&quot;&gt;&lt;&#x2F;div&gt;&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;&quot;&gt;&lt;&#x2F;a&gt;&lt;script&gt; $(&#39;.btn&#39;).on(&#39;click&#39;, function()&#123; &#125;);&lt;&#x2F;script&gt; 定位问题&amp;&amp;查阅资料定义了一个变量var num=0;，每点击一次num++，ios在方法中打印后发现是多次触发了click事件，事件被累加绑定了。 累加绑定：在页面中为一个元素绑定事件，事件执行后页面未刷新且元素还在，然后你再次点击，元素又被绑定个一次点击事件，这样第二次点击就会执行两次，以此类推。 解决方法解绑后再进行绑定12345678&lt;div class&#x3D;&quot;btn&quot;&gt;&lt;&#x2F;div&gt;&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;&quot;&gt;&lt;&#x2F;a&gt;&lt;script&gt; $(&#39;.btn&#39;).off(&#39;click&#39;); $(&#39;.btn&#39;).on(&#39;click&#39;, function()&#123; &#125;);&lt;&#x2F;script&gt; 参考：1.click点击一次，执行多次的bug]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>前端</tag>
        <tag>移动开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用纯css写一个按钮——自适应，阴影]]></title>
    <url>%2F%E4%BD%BF%E7%94%A8%E7%BA%AFcss%E5%86%99%E4%B8%80%E4%B8%AA%E6%8C%89%E9%92%AE%E2%80%94%E2%80%94%E8%87%AA%E9%80%82%E5%BA%94%EF%BC%8C%E9%98%B4%E5%BD%B1.html</url>
    <content type="text"><![CDATA[背景制作h5页面的自适应宽度按钮，开始使用背景图制作，把按钮两端切出来，中间区域单独切出来宽一像素图沿x轴重复，但在不同客户端浏览器表现不一致（遇到的是android的某款机型显示有问题，大概用图片仍可以调好，没做尝试），之后考虑直接用css写按钮效果 实现过程中遇到的问题关于阴影部分使用box-shadow属性设置内阴影、外阴影、内发光、外发光语法1box-shadow: h-shadow(必需) v-shadow(必需) blur(可选) spread(可选) color(可选) inset(可选);可以用逗号分隔阴影列表设置多个阴影叠加效果，层级关系位置越靠前面的显示层级越高，例如：1box-shadow: 0px 0px 0px 10px #f00, 0px 0px 0px 20px #fc0, 0px 0px 0px 30px #ff0, 0px 0px 0px 40px #0f0, 0px 0px 0px 50px #0fe, 0px 0px 0px 60px #00f, 0px 0px 0px 70px #f0f;Photoshop投影与CSS中box-shadow的转换 关于阴影使用了混合模式，正片叠底和滤色等阴影颜色使用了正片叠底，暂时是使用了叠完之后的颜色做为阴影颜色==如果是元素,可以使用CSS3新特性: mix-blend-mode文档描述为： mix-blend-mode CSS 属性描述了元素的内容应该与元素的直系父元素的内容和元素的背景如何混合。 扩展：1.CSS3混合模式mix-blend-mode/background-blend-mode简介2.https://developer.mozilla.org/zh-CN/docs/Web/CSS/mix-blend-mode 关于自适应h5页面css设置属性值单位的问题，px，rem，em，百分比对于一个固定可自动缩放模块，如果可以使用百分比，优先使用百分比。内部如果font-size值不会受影响可以使用em，如果font-size值不确定，可以使用rem，对于不期望随着模版放大缩小改变的单位使用px。 关于伪类选择器中文乱码的问题确保html文件编码和css文件编码保持一致。最好使用utf-8编码。在css文档头加入 @charset &quot;utf-8&quot;;（不声明的话会默认为ansi编码）。伪类选择器中的中文可以使用中文对应的Unicode，需要注意Unicode在CSS中的书写方式。英文字符不要转换为Unicode，会被转成实体字符例如：”更多&gt;” 对应的Unicode：\u66f4\u591a\u0026\u0067\u0074\u003b 对应的UTF-8：&amp;#x66F4;&amp;#x591A;&gt; 伪类选择器中 使用 content: &#39;\66F4\591A&gt;&#39;;转换工具：http://tool.chinaz.com/tools/urlencode.aspx 参考及扩展：1.http://www.w3school.com.cn/cssref/pr_box-shadow.asp2.字符编码笔记：ASCII，Unicode 和 UTF-83.ASCII，Unicode和UTF-8]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>前端</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[less使用记录]]></title>
    <url>%2Fless%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95.html</url>
    <content type="text"><![CDATA[运行环境Less 可以运行在 Node 或浏览器端。 安装node 下载nodejs安装包安装https://nodejs.org/en/ macOS下使用brew安装node 安装brew http://brew.sh/ linux下使用yum安装nodejs (自行搜索安装方法) Node.js 环境中使用 Less ：12npm install -g less&gt; lessc styles.less styles.css 在浏览器环境中使用 Less ：12&lt;link rel&#x3D;&quot;stylesheet&#x2F;less&quot; type&#x3D;&quot;text&#x2F;css&quot; href&#x3D;&quot;styles.less&quot; &#x2F;&gt;&lt;script src&#x3D;&quot;&#x2F;&#x2F;cdnjs.cloudflare.com&#x2F;ajax&#x2F;libs&#x2F;less.js&#x2F;2.5.3&#x2F;less.min.js&quot;&gt;&lt;&#x2F;script&gt; Phpstorm配置Less配置：“Phpstorm”&gt; “Preferences”（command+,）弹出设置界面，在左侧导航找到“Tools”&gt;”File Watchers” 点击“+”号按钮找到less文件选项点击添加。 Output paths to refresh：默认：1$FileNameWithoutExtension$.css:$FileNameWithoutExtension$.css.map修改为：1$FileParentDir(less)$&#x2F;css&#x2F;$FileDirPathFromParent(less)$&#x2F;$FileNameWithoutExtension$.css//说明$FileParentDir(less)$ 是获取 less 目录的路径$FileDirPathFromParent(less)$ 是获取 less 文件到 less 目录的路径$FileNameWithoutExtension$ 是获取 less 文件不带后缀的名字 Atom配置Less“Window” -&gt; “Settings” -&gt; “Packages”安装插件 搜索atom-less -&gt; install 搜索less-autocompile -&gt; install Example12345678910111213141516171819202122232425262728less&#x2F;base.less &#x2F;&#x2F; &quot;out&quot;: false, &quot;compress&quot;: false &#x2F;** * 不编译 不压缩 *&#x2F;less&#x2F;styles.less &#x2F;&#x2F; out: ..&#x2F;css&#x2F;styles.css, sourcemap: true, compress: true &#x2F;** * 编译输出到..&#x2F;css&#x2F;styles.css * 生成sourcemap * 压缩文件 *&#x2F; @import &quot;my&#x2F;components&#x2F;select.less&quot;;less&#x2F;my&#x2F;components&#x2F;select.less &#x2F;&#x2F; main: ..&#x2F;..&#x2F;styles.less @import &quot;base.less&quot;; .select &#123; height: 100px; width: 100px; &#125; 参考：1.http://lesscss.cn/2.https://less.bootcss.com/3.https://www.cnblogs.com/enix/p/3505610.html4.https://www.cnblogs.com/zzhbx/p/6944922.html]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>前端</tag>
        <tag>css</tag>
        <tag>less</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[h5页面与app原生页面通信——postMessage方法]]></title>
    <url>%2Fh5%E9%A1%B5%E9%9D%A2%E4%B8%8Eapp%E5%8E%9F%E7%94%9F%E9%A1%B5%E9%9D%A2%E9%80%9A%E4%BF%A1%E2%80%94%E2%80%94postMessage%E6%96%B9%E6%B3%95.html</url>
    <content type="text"><![CDATA[背景 有些页面需要经常改动，为了避免app频繁发版本，需要在app里放h5页面 h5页面和app有交互 解决方案 JS部分1234567891011121314151617181920212223242526272829var params &#x3D; &#123; &#39;id&#39;: $id, &#39;type&#39;: $type, &#39;typeide&#39;: $typeide, &#39;categoryId&#39;: $categoryId, &#39;good_id&#39;: $good_id, &#39;url&#39;: $url&#125;;function setupWvJsBridge(params)&#123; &#x2F;&#x2F;参数 var u &#x3D; navigator.userAgent; var isAndroid &#x3D; u.indexOf(&#39;Android&#39;) &gt; -1 || u.indexOf(&#39;Adr&#39;) &gt; -1; &#x2F;&#x2F;android终端 var isiOS &#x3D; !!u.match(&#x2F;\(i[^;]+;( U;)? CPU.+Mac OS X&#x2F;); &#x2F;&#x2F;ios终端 &#x2F;&#x2F; ios postMessage try &#123; if(isAndroid !&#x3D; true &amp;&amp; isiOS &#x3D;&#x3D; true)&#123; var postMsg &#x3D; params; window.webkit.messageHandlers.AppModel.postMessage(postMsg); &#125; &#125; catch &#123;&#125; &#x2F;&#x2F; android postMessage try &#123; if(isiOS !&#x3D; true &amp;&amp; isAndroid &#x3D;&#x3D; true)&#123; var postMsg &#x3D; params; window.Android.postMessage(JSON.stringify(postMsg)); &#125; &#125; catch(error) &#123;&#125;&#125; 参考：https://blog.csdn.net/qq_36435508/article/details/78165007]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>h5</tag>
        <tag>app</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js判断h5页面滑动方向]]></title>
    <url>%2Fjs%E5%88%A4%E6%96%ADh5%E9%A1%B5%E9%9D%A2%E6%BB%91%E5%8A%A8%E6%96%B9%E5%90%91.html</url>
    <content type="text"><![CDATA[问题背景最近做了个h5页面，需要在页面中的一个固定区域向上滑动时加载数据 解决方案1234567891011121314151617181920212223242526var windowHeight &#x3D; $(window).height();$(&quot;body&quot;).css(&quot;height&quot;, windowHeight);var startX, startY, moveEndX, moveEndY, X, Y;$(&quot;body&quot;).on(&quot;touchstart&quot;, function(e) &#123; e.preventDefault(); startX &#x3D; e.targetTouches[0].pageX; startY &#x3D; e.targetTouches[0].pageY;&#125;);$(&quot;body&quot;).on(&quot;touchmove&quot;, function(e) &#123; e.preventDefault(); moveEndX &#x3D; e.targetTouches[0].pageX; moveEndY &#x3D; e.targetTouches[0].pageY; X &#x3D; moveEndX - startX; Y &#x3D; moveEndY - startY; if (Math.abs(X) &gt; Math.abs(Y) &amp;&amp; X &gt; 0) &#123; alert(&quot;left to right&quot;); &#125; else if (Math.abs(X) &gt; Math.abs(Y) &amp;&amp; X &lt; 0) &#123; alert(&quot;right to left&quot;); &#125; else if (Math.abs(Y) &gt; Math.abs(X) &amp;&amp; Y &gt; 0) &#123; alert(&quot;top to bottom&quot;); &#125; else if (Math.abs(Y) &gt; Math.abs(X) &amp;&amp; Y &lt; 0) &#123; alert(&quot;bottom to top&quot;); &#125; else &#123; alert(&quot;just touch&quot;); &#125;&#125;);]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>transform</tag>
        <tag>h5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS 3D转换]]></title>
    <url>%2FCSS%203D%E8%BD%AC%E6%8D%A2.html</url>
    <content type="text"><![CDATA[html部分123456789101112&lt;section class&#x3D;&quot;container&quot;&gt; &lt;div class&#x3D;&quot;box&quot;&gt; &lt;figure&gt;1&lt;&#x2F;figure&gt; &lt;figure&gt;2&lt;&#x2F;figure&gt; &lt;figure&gt;3&lt;&#x2F;figure&gt; &lt;figure&gt;4&lt;&#x2F;figure&gt; &lt;figure&gt;5&lt;&#x2F;figure&gt; &lt;figure&gt;6&lt;&#x2F;figure&gt; &lt;figure&gt;7&lt;&#x2F;figure&gt; &lt;figure&gt;8&lt;&#x2F;figure&gt; &lt;&#x2F;div&gt;&lt;&#x2F;section&gt; css部分123456789101112131415161718192021&lt;style&gt; .container&#123;position: relative;margin: auto;width: 100px;height: 100px;&#125; .box&#123;position: absolute;width: 100%;height: 100%;transform-style: preserve-3d;transform-origin: 100%;animation: circle 10s linear infinite;&#125; figure&#123;position: absolute;width: 100%;height: 100%;font-size: 20px; line-height: 100px;color: #fff;text-align: center;&#125; figure:nth-child(1)&#123;background-color: hsla(0, 100%, 50%, 0.5);transform: translateZ(-86.6px);&#125; figure:nth-child(2)&#123;background-color: hsla(45, 100%, 50%, 0.5);transform: rotateY(60deg) translateZ(-86.6px);&#125; figure:nth-child(3)&#123;background-color: hsla(90, 100%, 50%, 0.5);transform: rotateY(120deg) translateZ(-86.6px);&#125; figure:nth-child(4)&#123;background-color: hsla(135, 100%, 50%, 0.5);transform: rotateY(180deg) translateZ(-86.6px);&#125; figure:nth-child(5)&#123;background-color: hsla(180, 100%, 50%, 0.5);transform: rotateY(240deg) translateZ(-86.6px);&#125; figure:nth-child(6)&#123;background-color: hsla(225, 100%, 50%, 0.5);transform: rotateY(300deg) translateZ(-86.6px);&#125; figure:nth-child(7)&#123;height: 173.2px;line-height: 173.2px;background-color: hsla(270, 100%, 50%, 0.5);transform: rotateX(90deg) translateZ(86.6px);&#125; figure:nth-child(8)&#123;height: 173.2px;line-height: 173.2px;background-color: hsla(315, 100%, 50%, 0.5);transform: rotateX(-90deg) translateZ(13.4px);&#125; figure:nth-child(7):before&#123;content: &#39;&#39;;display: block;border-width: 86.6px 50px 86.6px 0;border-style: solid;border-color: transparent hsla(270, 100%, 50%, 0.5) transparent transparent;position: absolute;left: -50px;top: 0;&#125; figure:nth-child(7):after&#123;content: &#39;&#39;;display: block;border-width: 86.6px 0 86.6px 50px;border-style: solid;border-color: transparent transparent transparent hsla(270, 100%, 50%, 0.5);position: absolute;right: -50px;top: 0;&#125; figure:nth-child(8):before&#123;content: &#39;&#39;;display: block;border-width: 86.6px 50px 86.6px 0;border-style: solid;border-color: transparent hsla(315, 100%, 50%, 0.5) transparent transparent;position: absolute;left: -50px;top: 0;&#125; figure:nth-child(8):after&#123;content: &#39;&#39;;display: block;border-width: 86.6px 0 86.6px 50px;border-style: solid;border-color: transparent transparent transparent hsla(315, 100%, 50%, 0.5);position: absolute;right: -50px;top: 0;&#125; @keyframes circle&#123; 0%&#123;transform: translateY(200px) rotateX(-20deg) rotateY(0);&#125; 100%&#123;transform: translateY(200px) rotateX(-20deg) rotateY(360deg);&#125; &#125;&lt;&#x2F;style&gt; 例子：CSS-3D转换]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>transform</tag>
        <tag>3d</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canvas学习(1)]]></title>
    <url>%2Fcanvas%E5%AD%A6%E4%B9%A0(1).html</url>
    <content type="text"></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>canvas</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5详解学习笔记(1)]]></title>
    <url>%2FHTML5%E8%AF%A6%E8%A7%A3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(1).html</url>
    <content type="text"><![CDATA[HTML5新增语义化标签]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>前端</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Photoshop投影与CSS中box-shadow的转换]]></title>
    <url>%2FPhotoshop%E6%8A%95%E5%BD%B1%E4%B8%8ECSS%E4%B8%ADbox-shadow%E7%9A%84%E8%BD%AC%E6%8D%A2.html</url>
    <content type="text"><![CDATA[“混合模式”： Photoshop提供了各式各样的混合模式，但是CSS3阴影只支持正常模式（normal）。“颜色（color）”： 阴影颜色。对应于CSS3阴影中的 color 值。“不透明度（opacity）”： 阴影的不透明度。对应于CSS3阴影的颜色 rgba() 中的 a 值。“角度（Angle）”： 投影的角度。“距离（Distance）”： 阴影的距离。根据角度和距离可以换算出CSS3阴影中的x-offset和y-offet。 x-offset = Distance cos(180 -Angle) ， y-offset = Distance sin(180 - Angle)“扩展（Spread）”： 阴影的扩展大小。控制阴影实体颜色和虚化颜色的多少。 Spread Size = 阴影中实体颜色的大小 。剩下的就是虚化的颜色。 CSS3阴影 spread-radius = Spread Size“大小（Size）”： 阴影的大小。 在CSS3中 blur-radius + spread-radius = Size 即 blur-radius = Size - spread-radius 。 例：图层样式：投影： 结构： 混合模式：正常 不透明度：75% 角度：145（使用全局光） 距离：5像素 扩展：6% 大小：10像素 品质： 杂色：0% 图层挖空投影1234567color: rgba(118,113,113,.75);x-offset: 5 * cos(180°- 145°) &#x3D; 4.09px;y-offset: 5 * sin(180°- 145°) &#x3D; 2.87px;spread-radius: 10 * 6% &#x3D; 0.6pxblur-radius: 10 - 0.6 &#x3D; 9.4px;box-shadow: 4.09px 2.87px 9.4px 0.6px rgba(118,113,113,.75);text-shadow: 4.09px 2.87px 9.4px rgba(118,113,113,.75); 参考：1.https://www.jb51.net/css/404167.html2.https://developer.mozilla.org/zh-CN/docs/Web/CSS/box-shadow3.http://psd-to-css-shadows.com/]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>前端</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css中透明度和颜色的关系]]></title>
    <url>%2Fcss%E4%B8%AD%E9%80%8F%E6%98%8E%E5%BA%A6%E5%92%8C%E9%A2%9C%E8%89%B2%E7%9A%84%E5%85%B3%E7%B3%BB.html</url>
    <content type="text"><![CDATA[每一种颜色 = 透明度百分比 当前色种值 + (1-透明度百分比) 底部色种值RGB三个分量分别相加 ARGB 依次代表透明度（alpha）、红色(red)、绿色(green)、蓝色(blue)。#FF99CC00 为例，其中，FF 是透明度，99 是红色值， CC 是绿色值， 00 是蓝色值。 1.透明度分为256阶（0-255），计算机上用16进制表示为（00-ff）。透明就是0阶，不透明就是255阶,如果50%透明就是127阶（256的一半当然是128，但因为是从0开始，所以实际上是127）。2.透明度 和 不透明度是两个概念， 它们加起来是1，或者100%. 12345678910111213141516171819202122透明度参照表；00%&#x3D;FF（不透明）5%&#x3D;F210%&#x3D;E515%&#x3D;D820%&#x3D;CC25%&#x3D;BF30%&#x3D;B235%&#x3D;A540%&#x3D;9945%&#x3D;8c50%&#x3D;7F55%&#x3D;7260%&#x3D;6665%&#x3D;5970%&#x3D;4c75%&#x3D;3F80%&#x3D;3385%&#x3D;2190%&#x3D;1995%&#x3D;0c100%&#x3D;00（全透明） 参考：1.http://blog.csdn.net/pinglingying/article/details/524038192.https://blog.csdn.net/qq_35900047/article/details/79097658]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>前端</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[textarea实现高度自适应]]></title>
    <url>%2Ftextarea%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%BA%A6%E8%87%AA%E9%80%82%E5%BA%94.html</url>
    <content type="text"><![CDATA[问题背景自学前端过程中想要模仿windows桌面做个网页版，作为练习。桌面图标改名框刚开始使用input实现，然后发现改名框是可以多行而且根据名称长度自适应高度的，然后考虑使用textarea实现，但是textarea不能自适应高度 解决方案网上查找资料，总结几种解决方案 1.div模拟textarea文本域轻松实现高度自适应,通过添加contenteditable属性并将属性值设为true1&lt;div contenteditable&#x3D;&quot;true&quot;&gt;&lt;&#x2F;div&gt; 单击后选中文本的实现：selectNodeContents对具有contenteditable=&#39;true&#39;的容器有效1234567891011121314151617181920&lt;div contenteditable&#x3D;&#39;true&#39; id&#x3D;&quot;selectable&quot;&gt;http:&#x2F;&#x2F;example.com&#x2F;page.htm&lt;&#x2F;div&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt; var obj &#x3D; document.getElementById(&#39;selectable&#39;); obj.onclick &#x3D; function()&#123; selectText(this); &#125;; function selectText(obj) &#123; if (document.selection) &#123; var range &#x3D; document.body.createTextRange(); range.moveToElementText(obj); range.select(); &#125; else if (window.getSelection) &#123; var range &#x3D; document.createRange(); range.selectNodeContents(obj); window.getSelection().removeAllRanges(); window.getSelection().addRange(range); &#125; &#125;&lt;&#x2F;script&gt; 2.文本框textarea根据输入内容自适应高度,js实现 参考：1.https://www.zhangxinxu.com/wordpress/2010/12/div-textarea-height-auto/2.https://www.cnblogs.com/dffy/p/6386318.html3.https://segmentfault.com/q/1010000007857595?_ea=1474484]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>前端</tag>
        <tag>textarea</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS面向对象及组件开发学习笔记(3)]]></title>
    <url>%2FJS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%8F%8A%E7%BB%84%E4%BB%B6%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(3).html</url>
    <content type="text"><![CDATA[组件开发对象的多种表现形式提高对象的复用性如何配置参数和默认参数例子：拖拽例子：弹窗 例子：拖拽的组件开发例子：弹窗的组件开发 复杂组件开发之自定义事件组件 对面向对象的深入应用（UI组件，功能组件） 将配置参数、方法、事件，三者进行分离创建自定义事件 有利于多人协作开发代码 如何去挂载自定义事件与事件函数 自定义事件：让函数能够具备事件的某些特性（绑定事件互相不会覆盖）1234567891011window.addEventListener(&#39;show&#39;,function()&#123; alert(1);&#125;,false);window.addEventListener(&#39;show&#39;,function()&#123; alert(2);&#125;,false);window.addEventListener(&#39;show&#39;,function()&#123; alert(3);&#125;,false);show(); &#x2F;&#x2F;主动触发自定义事件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;div id&#x3D;&quot;div1&quot;&gt;&lt;&#x2F;div&gt;&lt;span id&#x3D;&quot;span1&quot;&gt;&lt;&#x2F;span&gt;&lt;script&gt; window.onload &#x3D; function()&#123; var oDiv &#x3D; document.getElementById(&#39;div1&#39;); var oSpan &#x3D; document.getElementById(&#39;span1&#39;); bindEvent(oDiv, &#39;click&#39;, function()&#123; alert(1); &#125;); bindEvent(oDiv, &#39;click&#39;, function()&#123; alert(2); &#125;); bindEvent(oSpan, &#39;show&#39;, function()&#123; alert(3); &#125;); bindEvent(oSpan, &#39;show&#39;, function()&#123; alert(4); &#125;); bindEvent(oSpan, &#39;hide&#39;, function()&#123; alert(5); &#125;); fireEvent(oSpan, &#39;show&#39;); &#x2F;&#x2F;执行结果 3 function bindEvent(obj, events, fn)&#123; &#x2F;&#x2F; obj : 楼层 &#x2F;&#x2F; events : 书架 &#x2F;&#x2F; fn : 一本书 obj.listeners &#x3D; obj.listeners || &#123;&#125;; obj.listeners[events] &#x3D; obj.listeners[events] || []; obj.listeners[events].push(fn); if (obj.addEventListener) &#123; obj.addEventListener(events, fn, false); &#125; else &#123; &#x2F;&#x2F;兼容IE obj.attachEvent(&#39;on&#39;+events, fn); &#125; &#125; function fireEvent(obj, events)&#123; &#x2F;&#x2F;主动触发自定义事件 for (var i &#x3D; 0; i &lt; obj.listeners[events].length; i++) &#123; obj.listeners[events][i](); &#125; &#125; &#125;;&lt;&#x2F;script&gt; EventTarget.addEventListener() JS综合应用12345678&lt;div id&#x3D;&quot;div1&quot;&gt; &lt;div id&#x3D;&quot;div2&quot;&gt;&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;script&gt; var oDiv &#x3D; document.getElementById(&#39;div1&#39;); oDiv.onmouseover &#x3D; function()&#123;&#125;; oDiv.onmouseout &#x3D; function()&#123;&#125;;&lt;&#x2F;script&gt; 子集影响父级的bug（在IE下使用onmouseover和onmouseout时）解决方案： 1.js：onmouseenter onmouseleave（子集不会影响父级）（最早IE支持，可能会有兼容性问题，做兼容非常麻烦） 123function elContains(a, b)&#123; &#x2F;&#x2F;判断两个元素是否是嵌套关系 return a.contains ? a !&#x3D; b &amp;&amp; a.contains(b) : !!(a.compareDocumentPosition(b) &amp; 16);&#125; 2.css：加一个层 例子：图片放大镜效果例子：苹果菜单]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PS参考线小插件GuideGuide]]></title>
    <url>%2FPS%E5%8F%82%E8%80%83%E7%BA%BF%E5%B0%8F%E6%8F%92%E4%BB%B6GuideGuide.html</url>
    <content type="text"><![CDATA[下载/参考：http://iiidea.cn/guideguide-v4-6-4-macosx.html使用参考：标识设计中辅助参考线入门]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>前端</tag>
        <tag>PhotoShop</tag>
        <tag>设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS面向对象及组件开发学习笔记(2)]]></title>
    <url>%2FJS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%8F%8A%E7%BB%84%E4%BB%B6%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2).html</url>
    <content type="text"><![CDATA[JS是基于原型的程序尽量不要去修改或者添加系统对象下面的方法和属性 包装对象基本类型都有自己对应的包装对象：String Number Boolean（null undefined没有）123456789101112131415161718 var str &#x3D; new String(&#39;hello&#39;); alert(typeof str); &#x2F;&#x2F;object alert(str.charAt(1)); String.prototype.charAt &#x3D; function()&#123;&#125;;var str &#x3D; &#39;hello&#39;;str.charAt(0); &#x2F;&#x2F;基本类型会找到对应的包装对象类型，然后包装对象类型把所有的属性和方法给了基本类型，然后包装对象消失var str &#x3D; &#39;hello&#39;;&#x2F;&#x2F;给基本类型添加方法时，把方法添加到基本类型对应的包装对象上String.prototype.lastValue &#x3D; function()&#123; return this.charAt(this.length-1);&#125;alert(str.lastValue()); &#x2F;&#x2F;ovar str &#x3D; &#39;hello&#39;;str.number &#x3D; 10;alert(str.number); &#x2F;&#x2F;undefined 原型链实例对象与原型之间的连接，叫做原型链proto(隐式连接)Object对象类型是原型链的最外层 hasOwnProperty和constructor的使用面向对象的一些属性和方法 -hasOwnProperty():看是不是对象自身下面的属性 123456var arr &#x3D; [];arr.num &#x3D; 10;Array.prototype.num2 &#x3D; 20;alert(arr.hasOwnProperty(&#39;num&#39;)); &#x2F;&#x2F;truealert(arr.hasOwnProperty(&#39;num2&#39;)); &#x2F;&#x2F;false -constructor:查看对象的构造函数 每个原型都会自动添加constructor属性 For in 的时候有些属性是找不到的 避免修改constructor属性 1234567891011121314151617181920function A()&#123;&#125;&#x2F;&#x2F;A.prototype.constructor &#x3D; A; 自动添加，constructor属性的值为构造函数Avar a1 &#x3D; new A();alert(a1.constructor); &#x2F;&#x2F;Aalert(a1.hasOwnProperty &#x3D;&#x3D; Object.prototype.hasOwnProperty); &#x2F;&#x2F;truevar arr &#x3D; [];alert(arr.constructor &#x3D;&#x3D; Array); &#x2F;&#x2F;truefunction Person()&#123;&#125;Person.prototype.name &#x3D; &#39;xiaoming&#39;;Person.prototype.age &#x3D; 20;Person.prototype &#x3D; &#123; constructor: Person, &#x2F;&#x2F;这里需要添加这句话修正指向 name: &#39;xiaoming&#39;, age: 20&#125;;for(var attr in Person.prototype)&#123; alert(attr);&#125;&#x2F;&#x2F;系统自带的属性不能被for in到，自己添加的属性可以 -isntanseof:运算符 对象与构造函数在原型链上是否有关系 -toString():object上的方法 isntanseof类型判断12var arr &#x3D; [];alert(arr isntanseof Array); &#x2F;&#x2F;true 利用toString做类型判断123456789101112var arr &#x3D; [];alert( Object.prototype.toString.call(arr) &#x3D;&#x3D; &#39;[object Array]&#39; ); &#x2F;&#x2F;truewindow.onload &#x3D; function()&#123; var oF &#x3D; document.createElement(&#39;iframe&#39;); document.body.appendChild(oF); var ifArray &#x3D; window.frames[0].Array; var arr &#x3D; new ifArray(); alert(arr.constructor &#x3D;&#x3D; Array); &#x2F;&#x2F;false alert(arr isntanseof Array); &#x2F;&#x2F;false alert(Object.prototype.toString.call(arr) &#x3D;&#x3D; &#39;[object Array]&#39;); &#x2F;&#x2F;true&#125; 面向对象的继承-在原有对象的基础上，略作修改，得到一个新的对象-不影响原有对象的功能 子类不影响父类，子类可以继承父类的一些功能（代码复用）属性继承：调用父类的构造函数 使用call改变this指向方法继承：for in 拷贝继承（jquery也是采用拷贝继承extend） 123456789101112131415161718192021222324252627function CreatePerson(name, gender)&#123; this.name &#x3D; name; this.gender &#x3D; gender;&#125;CreatePerson.prototype.showName &#x3D; function()&#123; alert(this.name);&#125;var p1 &#x3D; new CreatePerson(&#39;xiaoming&#39;,&#39;male&#39;);p1.showName();function CreateStar(name, gender, job)&#123; CreatePerson.call(this, name, gender); this.job &#x3D; job;&#125;&#x2F;&#x2F;CreateStar.prototype &#x3D; CreatePerson.prototype; 这样会有对象引用问题extend(CreateStar.prototype, CreatePerson.prototype);var p2 &#x3D; new CreateStar(&#39;xxx&#39;, &#39;male&#39;, &#39;actor&#39;);p2.showName();&#x2F;&#x2F;对象拷贝会有引用问题，基本类型复制不会，可以通过把对象里的每一项赋给另一个对象的每一项&#x2F;&#x2F;函数虽然是对象类型，但是函数不能被修改，只能重新赋值function extend(obj1, obj2)&#123; for(var attr in obj2)&#123; obj1[attr] &#x3D; obj2[attr]; &#125;&#125; 例子：继承的拖拽 继承的其他形式-类式继承 利用构造函数(类)继承的方式-原型继承 借助原型来实现对象继承对象 类式继承JS中没有类的概念，把JS中的构造函数看作是类属性和方法要分开继承12345678910111213141516171819function A()&#123; this.name &#x3D; &#39;xiaoming&#39;;&#125;A.prototype.showName &#x3D; function()&#123; alert(this.name);&#125;function B()&#123; A.call(this);&#125;var F &#x3D; function()&#123;&#125;;F.prototype &#x3D; A.prototype;B.prototype &#x3D; new F();B.prototype.constructor &#x3D; B; &#x2F;&#x2F;修正指向问题var b1 &#x3D; new B();b1.showName(); 原型继承JS 拓展对象原型方法的正确姿势]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS面向对象及组件开发学习笔记(1)]]></title>
    <url>%2FJS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%8F%8A%E7%BB%84%E4%BB%B6%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(1).html</url>
    <content type="text"><![CDATA[面向对象this js中,所有的函数都是通过一个对象进行调用的,是谁调用this就指向谁例如定时器，打印里面的this会指向window - 定时器是window下面的方法window object是所有浏览器都支持的，代表当前窗口。全局变量是window对象的属性，全局函数是window的方法。所以你不写window，也会默认对象是window，此种情况window对象可以省略. 1234567891011121314151617181920212223242526&lt;script&gt; var obj &#x3D; new Object(); &#x2F;&#x2F;创建了一个空的对象 obj.name &#x3D; &#39;小明&#39;; &#x2F;&#x2F;属性 obj.showName &#x3D; function()&#123; &#x2F;&#x2F;方法 alert(this); &#x2F;&#x2F;打印出来的this是obj &#125;; obj.showName();&lt;&#x2F;script&gt;&lt;script&gt; var obj &#x3D; new Object(); &#x2F;&#x2F;创建了一个空的对象 obj.name &#x3D; &#39;小明&#39;; &#x2F;&#x2F;属性 obj.showName &#x3D; function()&#123; &#x2F;&#x2F;方法 alert(this); &#x2F;&#x2F;打印出来的this是document &#125;; document.onclick &#x3D; obj.showName; &lt;&#x2F;script&gt; &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt; var obj &#x3D; &#123; showName() &#123; console.dir(this); &#125; &#125; var f &#x3D; obj.showName; obj.showName(); &#x2F;&#x2F;obj对象 f(); &#x2F;&#x2F;window&lt;&#x2F;script&gt; 工厂方式与构造函数工厂方式： 面向对象中的封装函数 改成与系统对象类似写法 -首字母大写 -New关键字提取 -This指向为新创建的对象 构造函数 -用来创建对象的函数，叫做构造函数 存在的问题 -对象的引用 -浪费内存 当new去调用一个函数：这个时候函数中的this就是创建出来的对象，而且函数的返回值就是this(隐式返回)new 后面调用的函数叫做构造函数12345678910111213141516171819202122232425262728293031323334function createPerson(name)&#123; &#x2F;&#x2F; 1.原料 var obj &#x3D; new Object(); &#x2F;&#x2F; 2.加工 obj.name &#x3D; name; obj.showName &#x3D; function()&#123; alert(this.name); &#125; &#x2F;&#x2F; 3.出厂 return obj;&#125;var p1 &#x3D; createPerson(&#39;xiaoming&#39;);p1.showName();var p2 &#x3D; createPerson(&#39;xiaoqiang&#39;);p2.showName();var arr &#x3D; new Array();var date &#x3D; new Date();&#x3D;&gt;function CreatePerson(name)&#123; this.name &#x3D; name; this.showName &#x3D; function()&#123; alert(this.name); &#125;&#125;var p1 &#x3D; new CreatePerson(&#39;xiaoming&#39;);p1.showName();var p2 &#x3D; new CreatePerson(&#39;xiaoqiang&#39;);p2.showName();alert(p1.showName &#x3D;&#x3D; p2.showName); &#x2F;&#x2F;false 引用地址不同 对象引用基本类型：赋值的时候只是值的复制对象类型：赋值不只是值的复制，而且也是引用的传递1234567891011121314151617var a &#x3D; 5;var b &#x3D; a;b +&#x3D; 3;alert(b); &#x2F;&#x2F;8alert(a); &#x2F;&#x2F;5var a &#x3D; [1,2,3];var b &#x3D; a;b.push(4);alert(b); &#x2F;&#x2F;[1,2,3,4]alert(a); &#x2F;&#x2F;[1,2,3,4]var a &#x3D; [1,2,3];var b &#x3D; a;var b &#x3D; [1,2,3,4];alert(b); &#x2F;&#x2F;[1,2,3,4]alert(a); &#x2F;&#x2F;[1,2,3]基本类型：==运算的时候值相同就是true对象类型：==运算的时候值和引用都相同时才为true 原型：去改写对象下面公用的方法或者属性，让公用的方法或者属性在内存中存在一份(提高性能) 面向对象的写法和使用1234567function 构造函数()&#123; this.属性&#125;构造函数.原型.方法 &#x3D; function()&#123;&#125;;var 对象1 &#x3D; new 构造函数();对象1.方法(); 面向对象的选项卡原则 -先写出普通的写法，然后改成面向对象写法 普通方法变型 尽量不要出现函数嵌套函数 可以有全局变量 把onload中不是赋值的语句放到单独函数中 改成面向对象 全局变量就是属性 函数就是方法 Onload中创建对象 改this指向问题：事件或者定时器中容易出问题，尽量让面向对象中的this指向对象 示例：点击查看 面向对象的拖拽注意 -Event对象 示例：点击查看]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ECMAScript测试题]]></title>
    <url>%2FECMAScript%E6%B5%8B%E8%AF%95%E9%A2%98.html</url>
    <content type="text"><![CDATA[1.12345678910111213A.if(&#39;21&#39;&lt;&#39;15&#39;)&#123;alert(1)&#125;B.if(15-15)&#123;alert(1)&#125;C.if(&#39;21&#39;&lt;15)&#123;alert(1)&#125;D.if(&#39;5&#39;+0)&#123;alert(1)&#125;哪项会弹1? Bif (表达式-条件) &#123; &#x2F;&#x2F; 条件为真执行的代码&#125;A.字符串之间的比较，是按照从左到右的顺序，逐位进行比较，按照unicode码的大小 charCodeAt(index) 用于获取指定索引值位置的unicode 12345var a &#x3D; &#39;21&#39;, b &#x3D; &#39;15&#39;;console.log(a.charCodeAt(0)); &#x2F;&#x2F; 50console.log(b.charCodeAt(0)); &#x2F;&#x2F; 4950 &lt; 49 &#x3D;&gt; false;&#x2F;&#x2F; 注：当前位大小相同时会继续比较下一位B.减法运算 15-15=0 =&gt; falseC.隐式类型转换 ‘21’ =&gt; 21 字符串转为数字 21 &lt; 15 =&gt; falseD.’5’+0 =&gt; ‘50’ =&gt; true +作用： 加法运算：左右两侧都是数字 字符串拼接：左右两侧只要有一侧是字符串，那么就是字符串拼接 正号 2.123456789101112131415161718var i &#x3D; 0, j &#x3D; 0;for (; i &lt; 10,j&lt;6; i++,j++) &#123; k &#x3D; i + j;&#125;console.log(k);&#x2F;&#x2F; 10for (; i &lt; 6,j&lt;10; i++,j++) &#123; k &#x3D; i + j;&#125;console.log(k);&#x2F;&#x2F; 18&#x2F;*for (变量初始化; 执行条件; 改变变量) &#123;&#125; *&#x2F;注意：判断条件,运算符而不是&amp;&amp;，只返回,最后的一个，判断条件前面的i&lt;10会被忽略 变量不定义直接赋值会默认为全局变量 3.1234567891011fn1();var fn1 &#x3D; function(a)&#123;alert(a);&#125;&#x2F;&#x2F; fn1 is not a function&#x2F;*变量预解析var fn1; &#x2F;&#x2F; undefinedfn1(); &#x2F;&#x2F; 只有函数才能调用，此时fn1还没被赋值fn1 &#x3D; function(a)&#123;alert(a);&#125; *&#x2F; 4.12345var x &#x3D; 1;function fn(n)&#123;n &#x3D; n + 1;&#125;y &#x3D; fn(x);&#x2F;&#x2F; undefined注意：函数fn没有返回值，必须return才能接收返回值 5.1234567891011121314function fn1()&#123; var a &#x3D; 0; function fn2()&#123; ++a; alert(a); &#125; return fn2;&#125;fn1()(); &#x2F;&#x2F; 1var newFn &#x3D; fn1();newFn(); &#x2F;&#x2F; 1newFn(); &#x2F;&#x2F; 2 这里并没有重新创建a变量&#x2F;&#x2F; 1,1,2作用域链：一层层向上查找垃圾回收：把用不到的变量等进行回收1234567function fn()&#123; var a &#x3D; 1; a &#x3D; a + 1; console.log(a);&#125;fn();fn(); 6.1234567891011121314151617181920212223for(var i &#x3D; 0; i &lt; 5; i++)&#123; setTimeout(function()&#123; console.log(i); &#125;, i * 1000);&#125;&#x2F;&#x2F; 55555for(var i &#x3D; 0; i &lt; 5; i++)&#123; setTimeout(function(i)&#123; console.log(i); &#125;(i), i * 1000);&#125;&#x2F;&#x2F; 0 1 2 3 4for(let i &#x3D; 0; i &lt; 5; i++)&#123; setTimeout(function()&#123; console.log(i); &#125;, i * 1000);&#125;&#x2F;&#x2F; 0 1 2 3 4 7.12345678910111213141516(!+[]+[]+!+[]).length &#x2F;&#x2F; 8&#x3D;&gt; (!(+[])+[]+!(+[])).length&#x3D;&gt; (!0+[]+!0).length&#x3D;&gt; (true+[]+true).length&#x3D;&gt; (true+&#39;&#39;+true).length&#x3D;&gt; (&#39;true&#39;+true).length&#x3D;&gt; (&#39;truetrue&#39;).length&#x2F;*! 取反+号： 1.加法运算 2.字符串拼接 3.正号隐式类型转换 +[] &#x3D;&gt; &#39;&#39; &#x3D;&gt; 0 &#x2F;&#x2F; 空数组先调用toString转字符串再调用toNumber转数字进行计算 *&#x2F; | 优先级 | 运算符 | 结合性 | | :-: | :-: | :-: | | 1 | () [] | 从左向右 | | 2 | ! +(正) -(负) ~ ++ -- | 从右向左 | | 3 | * / % | 从左向右 | | 4 | +(加) -(减) | 从左向右 | | 5 | &lt;&lt; &gt;&gt; &gt;&gt;&gt; | 从左向右 | | 6 | &lt; &lt;= &gt; &gt;= instanceof | 从左向右 | | 7 | == != | 从左向右 | | 8 | &amp;(按位与) | 从左向右 | | 9 | ^ | 从左向右 | | 10 | &#124; | 从左向右 | | 11 | &amp;&amp; | 从左向右 | | 12 | &#124;&#124; | 从左向右 | | 13 | ?: | 从右向左 | | 14 | = += -= *= /= %= &amp;= &#124;= ^= ~= &lt;&lt;= &gt;&gt;= &gt;&gt;&gt;= | 从右向左 | 8.1console.log(100[&#39;toString&#39;][&#39;length&#39;]) &#x2F;&#x2F; 1length 表示的是toString调用时候的参数长度1234function fn1()&#123;&#125;function fn2(x,y)&#123;&#125;console.dir(fn1);console.dir(fn2);toString(进制) 接收的参数是进制12var a &#x3D; 4;console.log(a.toString(2)); &#x2F;&#x2F; 100 9.123456789可以判断数组中是否有大于10的值 arr.some()arr.every()&#x2F;&#x2F; 循环数组中的每一项，执行一个指定的函数，返回truearr.push() &#x2F;&#x2F; 向数组的末尾添加一个或多个元素，并返回新的长度arr.some() &#x2F;&#x2F; 循环数组中的每一项，执行一个指定的函数，只要其中有一个符合条件，返回truearr.splice() &#x2F;&#x2F; 向&#x2F;从数组中添加&#x2F;删除项目，然后返回被删除的项目 10.123456789101112var arr &#x3D; [1,2];var arr2 &#x3D; arr.concat();arr2.push( arr.splice()1,0 );&#x2F;&#x2F; 第一个参数，开始的index&#x2F;&#x2F; 第二个参数，删除的个数&#x2F;&#x2F; 返回删除的&#x2F;&#x2F; [1,2,[]]arr; &#x2F;&#x2F; [1,2]arr2; &#x2F;&#x2F; [1,2,[]]&#x2F;&#x2F; arr.concat() 用于合并函数，返回的函数是新的函数，不会影响在合并过程中用到的函数 null = undefined; // truenull == 0; // falsenull == [] // falsenull == null // truenull == undefined == null // false 运算符优先级相同，从左到右计算 null == undefined == null =&gt; true == null =&gt; falsenull &gt;= 0 // truenull &lt;= 0 // true http://www.ecma-international.org/http://www.fengfly.com/document/ECMAScript5.1/]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生JS逐行实现购物车功能]]></title>
    <url>%2F%E5%8E%9F%E7%94%9FJS%E9%80%90%E8%A1%8C%E5%AE%9E%E7%8E%B0%E8%B4%AD%E7%89%A9%E8%BD%A6%E5%8A%9F%E8%83%BD.html</url>
    <content type="text"><![CDATA[常见问题1.开发思路混乱2.代码不够简洁3.格式不统一4.知识点运用知其然不知其所以然5.新增方法或语法看得懂不会用 制作第一步：功能分析 列表 -勾选商品 -数量控制 -小计 统计 -全选 -勾选商品件数统计 -总额计算 -现在结算的点击 var、let、const的差别 var -支持全局、函数作用域 -接受重复声明 -变量预解析 let -不接受重复声明 -不存在变量提升 -支持块作用域 const -特性同let -一旦声明，常量的值就不可以改变 JavaScript toFixed() 方法 Math方法 Math.min Math.maxArray方法String方法 every、some数组方法every -用于循环数组中的每一项，在指定的函数中做判断，如果全部符合返回true，有一项不符合就返回falsesome -只要有其中一项符合，就返回true 示例：点击查看]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git使用遇到的问题non-fast-forward]]></title>
    <url>%2Fgit%E4%BD%BF%E7%94%A8%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98non-fast-forward.html</url>
    <content type="text"><![CDATA[问题背景今天git push提交代码时被拒绝，提示 rejected non-fast-forward和别人在同一分支开发 问题排查git push提交前没有更新分支代码，远端仓库中代码有更新查阅资料得知，这是本地和远程的仓库中的文件出现了冲突所致，远端仓库中代码发生改变，它不允许直接把新的代码覆盖上去。提交之前需要将远端的改变合并到本地上。 解决方案 git fetch origin branch获取远程分支branch的修改 git merge origin branch合并远程分支branch git pull origin branch更新本地分支 git push origin branch提交本地分支 问题解决参考：1.https://blog.csdn.net/programerxiaoer/article/details/785853012.Pro-Git]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>前端</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人机验证初体验]]></title>
    <url>%2F%E4%BA%BA%E6%9C%BA%E9%AA%8C%E8%AF%81%E5%88%9D%E4%BD%93%E9%AA%8C.html</url>
    <content type="text"><![CDATA[无痕验证]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端测试题]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%E6%B5%8B%E8%AF%95%E9%A2%98.html</url>
    <content type="text"><![CDATA[获取元素的方法有哪些？ ABCA.getElementByIdB.getElementsByTagNameC.getElementsByClassNameD.getElements 1234567891011121314151617181920212223&lt;ul id&#x3D;&quot;list&quot;&gt; &lt;li&gt;&lt;&#x2F;li&gt; &lt;li&gt;&lt;&#x2F;li&gt; &lt;li&gt;&lt;&#x2F;li&gt;&lt;&#x2F;ul&gt;&lt;script&gt; var lis1 &#x3D; document.getElementsByTagName(&#39;li&#39;); var lis2 &#x3D; document.querySelectorAll(&#39;li&#39;); &#x2F;&#x2F; querySelectorAll接收css选择器 var lis3 &#x3D; list.children; var lis4 &#x3D; list.childNodes; console.log(lis1); &#x2F;&#x2F; HTMLCollection(3)[li,li,li] 类数组，不是数组，不能直接调用数组的方法 console.log(lis2); &#x2F;&#x2F; Nodelist(3)[li,li,li] 类数组，不是数组，不能直接调用数组的方法 list.innerHTML +&#x3D; &#39;&lt;li&gt;li&lt;&#x2F;li&gt;&#39;; &#x2F;* 这里直接写list会默认用id&#x3D;&#39;list&#39;去获取元素，但不建议这样写 list.innerHTML &#x3D; list.innerHTML + &#39;&lt;li&gt;li&lt;&#x2F;li&gt;&#39;; 重写list的html内容，会覆盖掉之前的li *&#x2F; console.log(lis1); &#x2F;&#x2F; HTMLCollection(4)[li,li,li,li] getElementsByTagName获取到的元素是动态变化的 console.log(lis2); &#x2F;&#x2F; Nodelist(3)[li,li,li] querySelectorAll不会动态执行 console.log(lis3); &#x2F;&#x2F; HTMLCollection(4)[li,li,li,li] children获取到的元素是动态变化的 console.log(lis4); &#x2F;&#x2F; Nodelist(9)[text,li,text,li,text,li,text,li,text] querySelectorAll不会动态执行&lt;&#x2F;script&gt; 123(&#123;&#125;+&#123;&#125;).length &#x2F;&#x2F; 30&#x2F;&#x2F; 计算过程，运算符优先级，隐式类型转换]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端技术的发展方向]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E7%9A%84%E5%8F%91%E5%B1%95%E6%96%B9%E5%90%91.html</url>
    <content type="text"><![CDATA[框架 jQuery（库） Angular React Vue 框架：为解决某种问题而设计的具有一定约束性的开发结构 -解决某种问题，而不是所有问题 -具有约束性，有它自己定义的规则 使用某个框架的同时要了解这个框架背后的逻辑，怎么产生的，解决了什么问题 从使用框架进行项目开发来看需要掌握什么 语言基础无论什么语言的框架（JAVA，PHP，JS……）都会需要对数据进行操作，所以必须得清楚各种不同语言对数据进行操作对方法什么是数据？怎么操作？ 变量、数据类型、运算符……得到的数据能做什么？如何使用数据？ 流程控制 /** 运算符 [运算符优先级](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence) 类型转换规则 ! : 隐式类型转换 对象转boolean为真 [] == !true [] == false Number([]) =&gt; 0 0 == false 0 == 0 =&gt; true */ console.log( [] == ![] ); // true /** [] == !true [] == false === 会先判断类型 */ console.log( [] === ![] ); // false 框架只是为我们封装（实现）了它所关心（通用）的部分，而很多其他的（比如具体的业务/业务逻辑）框架就无能为力了，同时我们又会根据自己的具体业务逻辑进行封装 函数 函数、参数、返回值、作用域…… 业务/业务逻辑：所谓的业务就是你想要完成的具体事情，业务逻辑就是完成这个事情的步骤条件等，比如“https://miaov.com/index.php/news/newsDetail/nid/378” 原生语言本身就是一个框架（最基础的），像前面数据类型、流程控制、函数都是它提供的，同时它也提供了一些常用的、有用的函数（对象）封装 内置对象（函数） String、Number、Boolean Array、Date、Math、Set、Map…… 定时器 客户端网页API比如DOM、Event这些，很多框架都有对应的封装处理，仍需要掌握Event实际上要操作的内容不止html和css，还有很多其他内容： 图形（canvas、svg、webgl） 音频（audio）、视频（video）还要与服务器（一般提供数据服务）打交道 HTTP - web数据传输的基础 ajax - 异步数据请求 fetch - 新一代的ajax（HTTP）API]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AJAX请求头Content-type]]></title>
    <url>%2FAJAX%E8%AF%B7%E6%B1%82%E5%A4%B4Content-type.html</url>
    <content type="text"><![CDATA[Content-TypeContent-Type 实体头部用于指示资源的MIME类型 media type 。 MIME type （现在称为“媒体类型(media type)”，但有时也是“内容类型(content type)”）是指示文件类型的字符串，与文件一起发送（例如，一个声音文件可能被标记为 audio/ogg，一个图像文件可能是 image/png）。 它与传统Windows上的文件扩展名有相同目的。 在响应中，Content-Type标头告诉客户端实际返回的内容的内容类型。浏览器会在某些情况下进行MIME查找，并不一定遵循此标题的值; 为了防止这种行为，可以将标题 X-Content-Type-Options 设置为 nosniff。 在请求中 (如POST 或 PUT)，客户端告诉服务器实际发送的数据类型。 Header type Entity header Forbidden header name no CORS-safelisted response-header yes 句法12Content-Type: text&#x2F;html; charset&#x3D;utf-8Content-Type: multipart&#x2F;form-data; boundary&#x3D;something 指令media-type资源或数据的 MIME type 。 charset字符编码标准。 boundary对于多部分实体，boundary 是必需的，其包括来自一组字符的1到70个字符，已知通过电子邮件网关是非常健壮的，而不是以空白结尾。它用于封装消息的多个部分的边界。 例子在通过HTML form提交生成的POST请求中，请求头的Content-Type由&lt;form&gt;元素上的enctype属性指定12345&lt;form action&#x3D;&quot;&#x2F;&quot; method&#x3D;&quot;post&quot; enctype&#x3D;&quot;multipart&#x2F;form-data&quot;&gt; &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;description&quot; value&#x3D;&quot;some text&quot;&gt; &lt;input type&#x3D;&quot;file&quot; name&#x3D;&quot;myFile&quot;&gt; &lt;button type&#x3D;&quot;submit&quot;&gt;Submit&lt;&#x2F;button&gt;&lt;&#x2F;form&gt;请求头看起来像这样（在这里省略了一些 headers）：1234567891011121314POST &#x2F;foo HTTP&#x2F;1.1Content-Length: 68137Content-Type: multipart&#x2F;form-data; boundary&#x3D;---------------------------974767299852498929531610575---------------------------974767299852498929531610575Content-Disposition: form-data; name&#x3D;&quot;description&quot;some text---------------------------974767299852498929531610575Content-Disposition: form-data; name&#x3D;&quot;myFile&quot;; filename&#x3D;&quot;foo.txt&quot;Content-Type: text&#x2F;plain(content of the uploaded file foo.txt)---------------------------974767299852498929531610575 参考：1.Content-Type2.MIME type3.Entity header4.Forbidden header name5.CORS-safelisted response-header6.HTTP Headers]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AJAX编码问题]]></title>
    <url>%2FAJAX%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98.html</url>
    <content type="text"><![CDATA[问题背景post请求时url参数中带有&amp;等特殊符号无法传递完整的url 解决方案javascript 实现方法avascript中的编码有三种方法:escape（不推荐，对ASCII符号正确编码）、encodeURI、encodeURIComponent escape简单来说，escape是对字符串(string)进行编码(而另外两种是对URL)，作用是让它们在所有电脑上可读。编码之后的效果是%XX或者%uXXXX这种形式。最关键的是，当你需要对URL编码时，请忘记这个方法，这个方法是针对字符串使用的，不适用于URL。 定义和用法escape() 函数可对字符串进行编码，这样就可以在所有的计算机上读取该字符串。 语法：1escape(string) 参数 描述 string 必需。要被转义或编码的字符串。 返回值已编码的 string 的副本。其中某些字符被替换成了十六进制的转义序列。说明该方法不会对 ASCII 字母和数字进行编码，也不会对下面这些 ASCII 标点符号进行编码： * @ _ + . / 。其他所有的字符都会被转义序列替换。 提示和注释提示：可以使用 unescape() 对 escape() 编码的字符串进行解码。注释：ECMAScript v3 反对使用该方法，应用使用 decodeURI() 和 decodeURIComponent() 替代它。 encodeURIencodeURI：用于对网址编码(不包含参数)encodeURI不编码字符有82个：! ，# ，$ ，&amp; ，&#39; ，( ，) ，* ，+ ，, ，- ，. ，/ ，: ，; ，= ，? ，@ ，_ ，~ ，0-9 ，a-z ，A-ZencodeURI就是为这个而设计的。encodeURI不对URI中的特殊字符进行编码，如冒号(:)、斜杠(/)。下面看个示例：1encodeURI(&quot;https:&#x2F;&#x2F;www.secretbase.vip&#x2F; &quot;) &#x2F;&#x2F; https:&#x2F;&#x2F;www.secretbase.vip&#x2F;%20可以看到仅仅把空格替换成了20%，所以此方法可用于对网址进行编码。由于encodeURI不对冒号(:)、斜杠(/)进行编码，所以如果参数(如把网址作为参数)中包含冒号(:)、斜杠(/)，就会解析出错，所以此方法不能对参数进行编码。 定义和用法encodeURI() 函数可把字符串作为 URI 进行编码。 语法1encodeURI(URIstring) 参数 描述 URIstring 必需。一个字符串，含有 URI 或其他要编码的文本。 返回值URIstring 的副本，其中的某些字符将被十六进制的转义序列进行替换。 说明该方法不会对 ASCII 字母和数字进行编码，也不会对这些 ASCII 标点符号进行编码： - _ . ! ~ * ‘ ( ) 。该方法的目的是对 URI 进行完整的编码，因此对以下在 URI 中具有特殊含义的 ASCII 标点符号，encodeURI() 函数是不会进行转义的：;/?:@&amp;=+$,# 提示和注释提示：如果 URI 组件中含有分隔符，比如 ? 和 #，则应当使用 encodeURIComponent() 方法分别对各组件进行编码。 encodeURIComponentencodeURIComponent:用于对网址参数进行编码encodeURIComponent不编码字符有71个：! ，&#39; ，( ，) ，* ，- ，. ，_ ，~ ，0-9 ，a-z ，A-Z可以看到此方法对:/都进行了编码，所以不能用它来对网址进行编码。由于此方法对中文，空格，井号(#)，斜线(/)，冒号(:)都进行了编码，所以适合对URI中的参数进行编码。看下面的示例：123var title&#x3D;&quot;慢时光小栈&quot;;var url&#x3D;&quot;https:&#x2F;&#x2F;blog.secretbase.vip&#x2F;categories&#x2F;学习笔记&#x2F;?title&#x3D;&quot; + title;console.log(encodeURIComponent(url)); &#x2F;&#x2F; https%3A%2F%2Fblog.secretbase.vip%2Fcategories%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F%3Ftitle%3D%E6%85%A2%E6%97%B6%E5%85%89%E5%B0%8F%E6%A0%88 定义和用法encodeURIComponent() 函数可把字符串作为 URI 组件进行编码。 语法1encodeURIComponent(URIstring) 参数 描述 URIstring 必需。一个字符串，含有 URI 组件或其他要编码的文本。 返回值URIstring 的副本，其中的某些字符将被十六进制的转义序列进行替换。 说明该方法不会对 ASCII 字母和数字进行编码，也不会对这些 ASCII 标点符号进行编码： - _ . ! ~ * ‘ ( ) 。其他字符（比如 ：;/?:@&amp;=+$,# 这些用于分隔 URI 组件的标点符号），都是由一个或多个十六进制的转义序列替换的。 提示和注释提示：请注意 encodeURIComponent() 函数 与 encodeURI() 函数的区别之处，前者假定它的参数是 URI 的一部分（比如协议、主机名、路径或查询字符串）。因此 encodeURIComponent() 函数将转义用于分隔 URI 各个部分的标点符号。 参考：1.https://www.cnblogs.com/panie2015/p/5885922.html2.https://www.cnblogs.com/season-huang/p/3439277.html3.http://www.w3school.com.cn/jsref/jsref_escape.asp4.http://www.w3school.com.cn/jsref/jsref_encodeuri.asp5.http://www.w3school.com.cn/jsref/jsref_encodeuricomponent.asp]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中的正则表达式]]></title>
    <url>%2FJavaScript%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html</url>
    <content type="text"><![CDATA[正则表达式复习字符串操作indexOf 查找substring 获取子字符串charAt 获取某个字符split 分割字符串，获得数组找出字符串中的所有数字用传统字符串操作完成用正则表达式完成 正则和正则的写法让计算机能够读懂人类的规则正则都是操作字符串的12var re &#x3D; &#x2F;a&#x2F;; &#x2F;&#x2F; 建议使用此种简写写法，性能较下面一种好;尽量不要让正则表达式为空，否则这里&#x2F;&#x2F;会被认为是注释，需要注意两个&#x2F;之间的内容不是字符串var re &#x3D; new RegExp(&#39;a&#39;); &#x2F;&#x2F; 当正则需要传参的时候，必须用此种写法 var re &#x3D; new RegExp(param); 正则表达式的常用方法testtest 字符串判断 返回真假 正则.test(字符串) 例子：是否有不是数字的字符正则去匹配字符串，如果匹配成功就返回真，如果匹配失败就返回假test的写法：正则.test(字符串)12345var str &#x3D; &#39;abcdef&#39;;var re &#x3D; &#x2F;b&#x2F;;var re2 &#x3D; &#x2F;w&#x2F;;alert(re.test(str)); &#x2F;&#x2F; truealert(re2.test(str)); &#x2F;&#x2F; false1234567891011121314151617181920&#x2F;&#x2F; 转义字符 (本来字符有自身的意思，加上反斜杠后就变成了另外的意思)&#x2F;&#x2F; \n 换行&#x2F;&#x2F; \r 回车&#x2F;&#x2F; \t 制表&#x2F;*\s: 空格\S: 非空格\d: 数字\D: 非数字\w: 字符 (字母、数字、下划线)\W: 非字符*&#x2F;var str &#x3D; &#39;234928t34820&#39;;var re &#x3D; &#x2F;\D&#x2F;;if(re.test(str))&#123; alert(&#39;不全是数字&#39;);&#125;else&#123; alert(&#39;全是数字&#39;);&#125; search字符串搜索 返回出现的位置 字符串.search(正则) 忽略大小写：i--ignore 正则去匹配字符串，如果匹配成功，就返回匹配成功的位置，如果匹配失败就返回-1search的写法：字符串.search(正则)正则默认是区分大小写的，加标识i不区分大小写12345678910var str &#x3D; &#39;abcdef&#39;;var re &#x3D; &#x2F;b&#x2F;;var re1 &#x3D; &#x2F;w&#x2F;;var re2 &#x3D; &#x2F;B&#x2F;;var re3 &#x3D; &#x2F;B&#x2F;i;&#x2F;&#x2F; var re3 &#x3D; new RegExp(&#39;B&#39;, &#39;i&#39;);str.search(re); &#x2F;&#x2F; 1str.search(re1); &#x2F;&#x2F; -1str.search(re2); &#x2F;&#x2F; -1str.search(re3); &#x2F;&#x2F; 1 matchmatch 获取匹配的项目 返回数组 量词：+ 全局匹配：g–global 例子：找出所有数字正则去匹配字符串，如果匹配成功，就返回匹配成功的数组，如果匹配不成功，就返回nullmatch的写法：字符串.match(正则)正则默认匹配成功就会结束，不会继续匹配，加标识g(全局匹配)全部查找 量词：匹配不确定的位置 : 至少出现一次 123456789var str &#x3D; &#39;234s28t34820&#39;;var re &#x3D; &#x2F;\d&#x2F;;var re1 &#x3D; &#x2F;\d&#x2F;g;var re2 &#x3D; &#x2F;\d\d&#x2F;g;var re3 &#x3D; &#x2F;\d+&#x2F;g;str.match(re); &#x2F;&#x2F; [1]str.match(re1); &#x2F;&#x2F; [2,3,4,2,8,3,4,8,2,0]str.match(re2); &#x2F;&#x2F; [23,28,34,82]str.match(re3); &#x2F;&#x2F; [234,28,34820] replacereplace 替换所有匹配 返回替换后的字符串 字符串.replace(正则，想替换的) 例子：敏感词过滤 匹配子项 例子：日期格式化 正则去匹配字符串，匹配成功的字符替换成新的字符串replace的写法：字符串.replace(正则,新的字符串)第二个参数可以是一个字符串，也可以是一个回调函数，函数的第一个参数就是匹配成功的字符12345678var str &#x3D; &#39;aaa&#39;;var re &#x3D; &#x2F;a&#x2F;;str.replace(re,&#39;b&#39;);alert(str); &#x2F;&#x2F; &#39;baa&#39;;str.replace(re,function()&#123; return &#39;b&#39;; &#125;);alert(str); &#x2F;&#x2F; &#39;baa&#39;; 练习：敏感词过滤 匹配子项：小括号()（还有另外一个意思，分组操作）12345678910111213141516var str &#x3D; &#39;2018-11-6&#39;;var re &#x3D; &#x2F;(\d+)(-)&#x2F;g;str.replace(re, function($0,$1,$2)&#123; &#x2F;&#x2F; 第一个参数：正则整体 &#x2F;&#x2F; 第二个参数：第一个小括号里的正则，即第一个子项 &#x2F;&#x2F; 第三个参数：第二个小括号里的正则，即第二个子项 &#x2F;&#x2F; alert($0); &#x2F;&#x2F; 2018- 11- &#x2F;&#x2F; alert($1); &#x2F;&#x2F; 2018 11 &#x2F;&#x2F; alert($2); &#x2F;&#x2F; - - return $1 + &#39;.&#39;; &#x2F;&#x2F; &#39;2018.11.6&#39; return $0.substring(0,$0.length-1) + &#39;.&#39;; &#x2F;&#x2F; &#39;2018.11.6&#39; &#125;);var str &#x3D; &#39;abc&#39;;var re &#x3D; &#x2F;(a)(b)(c)&#x2F;;alert(str.match(re)); &#x2F;&#x2F; [abc,a,b,c] (当match不加g的时候才可以获取到子项的集合) 正则表达式字符类字符类：一组相似的元素（字符） [] 中括号的整体代表一个字符12345var str &#x3D; &#39;abc&#39;;var str1 &#x3D; &#39;abdc&#39;;var re &#x3D; &#x2F;a[bde]c&#x2F;;alert(re.test(str)); &#x2F;&#x2F; truealert(re.test(str1)); &#x2F;&#x2F; false排除：^ 如果^写在[]里面的话，就代表排除123var str &#x3D; &#39;awc&#39;;var re &#x3D; &#x2F;a[^bde]c&#x2F;;alert(re.test(str)); &#x2F;&#x2F; true范围：123var str &#x3D; &#39;abc&#39;;var re &#x3D; &#x2F;a[a-z0-9A-Z]c&#x2F;;alert(re.test(str)); &#x2F;&#x2F; true练习：过滤标签 转义字符 . (点) 任意字符 (. 真正的点需要转义) \d \w \s \b \D \W \S \B \1 重复子项 例子 获取class元素 找重复项最多的字符和个数\b: 独立的部分 （起始，结束，空格）\B: 非独立的部分1234567891011121314151617181920212223242526272829303132var str &#x3D; &#39;onetwo&#39;;var re &#x3D; &#x2F;\bone&#x2F;;var re1 &#x3D; &#x2F;one\b&#x2F;;alert(re.test(str)); &#x2F;&#x2F; truealert(re1.test(str)); &#x2F;&#x2F; false&#x2F;&#x2F; ...var str&#x3D;&#39;thisis&#39;;console.log(&#x2F;\bthis&#x2F;.test(str)) &#x2F;&#x2F;truevar str&#x3D;&#39;啊thisis&#39;;console.log(&#x2F;\bthis&#x2F;.test(str)) &#x2F;&#x2F;truevar str&#x3D;&#39; thisis&#39;;console.log(&#x2F;\bthis&#x2F;.test(str)) &#x2F;&#x2F;truevar str&#x3D;&#39;.thisis&#39;;console.log(&#x2F;\bthis&#x2F;.test(str)) &#x2F;&#x2F;truevar str&#x3D;&#39;-thisis&#39;;console.log(&#x2F;\bthis&#x2F;.test(str)) &#x2F;&#x2F;true&#x2F;&#x2F; 关键点来了：var str&#x3D;&#39;wthisis&#39;;console.log(&#x2F;\bthis&#x2F;.test(str)) &#x2F;&#x2F;falsevar str&#x3D;&#39;3thisis&#39;;console.log(&#x2F;\bthis&#x2F;.test(str)) &#x2F;&#x2F;falsevar str&#x3D;&#39;_thisis&#39;;console.log(&#x2F;\bthis&#x2F;.test(str)) &#x2F;&#x2F;false&#x2F;&#x2F; 只有三面三种情况才会返回false，也就是t的前面不能是\w(字母、数字、下划线)，如果是就会匹配不成功。 练习：获取class元素 正则中的重复的子项\1 : 重复的第一个子项\2 : 重复的第二个子项123var str &#x3D; &#39;abca&#39;;var re &#x3D; &#x2F;(a)(b)(c)\1&#x2F;;alert(re.test(str)); &#x2F;&#x2F; true可以用于标签的匹配&lt;div&gt;&lt;/div&gt; 12345678910111213141516&#x2F;&#x2F; 找重复项最多的字符和个数var str &#x3D; &#39;dsjflajdjldf&#39;;var arr &#x3D; str.split(&#39;&#39;);str &#x3D; arr.sort().join(&#39;&#39;);var value &#x3D; &#39;&#39;;var index &#x3D; 0;var re &#x3D; &#x2F;(\w)\1+&#x2F;g;str.replace(re,function($0,$1)&#123; if(index &lt; $0.length)&#123; index &#x3D; $0.length; value &#x3D; $1; &#125;&#125;);alert(&#39;最多的字符：&#39;+value+&#39;，重复的次数：&#39;+index); 正则中的量词和首尾匹配量词 : {}{4,7} : 最少出现4次，最多出现7次{4,} : 最少出现4次{4} : 出现4次 : {1,} 最少出现1次? : {0,1} 出现0次或1次 : {0,} 最少出现0次 ^ : 在正则的开始位置，代表起始$ : 在正则的结尾位置，代表结束 例子： -判断是不是QQ号 -去掉前后空格 常用正则例子高级表单校验匹配中文：[\u4e00-\u9fa5]行首行尾空格：^\s|\s$Email：^\w+@[a-z0-9]+(.[a-z]+){1,3}$网址：[a-zA-Z]+://[^\s]*QQ号：[1-9][0-9]{4,9}邮政编码：[1-9]\d{5}身份证：[1-9]\d{14}|[1-9]\d{17}|[1-9]\d{16}x 正则与面向对象把方法包在一个空间里–命名空间(JSON对象，把同一类方法包在一起)12345var re &#x3D; &#123; qq: &#x2F;[1-9][0-9]&#123;4,9&#125;&#x2F;, email: &#x2F;^\w+@[a-z0-9]+(\.[a-z]+)&#123;1,3&#125;$&#x2F;&#125;;console.log(re.email);]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[豆瓣接口实例]]></title>
    <url>%2F%E8%B1%86%E7%93%A3%E6%8E%A5%E5%8F%A3%E5%AE%9E%E4%BE%8B.html</url>
    <content type="text"><![CDATA[豆瓣API搜索书籍、电影、音乐GET http://api.douban.com/book/subjectsGET http://api.douban.com/movie/subjectsGET http://api.douban.com/music/subjects 请求参数 参数 意义 备注 q 全文检索的关键词 tag 搜索特定tag start-index 起始元素 max-results 返回结果的数量 alt 返回数据格式 返回格式 获取书籍信息 如果请求中包含了API认证授权参数，则返回值中包含当前授权用户的对于这本书籍收藏的link。1GET http:&#x2F;&#x2F;api.douban.com&#x2F;book&#x2F;subject&#x2F;&#123;subjectID&#125;也可以通过isbn获得电影的信息1GET http:&#x2F;&#x2F;api.douban.com&#x2F;book&#x2F;subject&#x2F;isbn&#x2F;&#123;isbnID&#125;例如123GET http:&#x2F;&#x2F;api.douban.com&#x2F;book&#x2F;subject&#x2F;2023013GET http:&#x2F;&#x2F;api.douban.com&#x2F;book&#x2F;subject&#x2F;isbn&#x2F;7543639130GET http:&#x2F;&#x2F;api.douban.com&#x2F;book&#x2F;subject&#x2F;isbn&#x2F;9787543639133 获取音乐信息 如果请求中包含了API认证授权参数，则返回值中包含当前授权用户的对于这本音乐收藏的link。1GET http:&#x2F;&#x2F;api.douban.com&#x2F;music&#x2F;subject&#x2F;&#123;subjectID&#125;例如1GET http:&#x2F;&#x2F;api.douban.com&#x2F;music&#x2F;subject&#x2F;2272292 获取电影信息如果请求中包含了API认证授权参数，则返回值中包含当前授权用户的对于这本电影收藏的link。1GET http:&#x2F;&#x2F;api.douban.com&#x2F;movie&#x2F;subject&#x2F;&#123;subjectID&#125;也可以通过imdb获得电影的信息1GET http:&#x2F;&#x2F;api.douban.com&#x2F;movie&#x2F;subject&#x2F;imdb&#x2F;&#123;imdbID&#125;例如12GET http:&#x2F;&#x2F;api.douban.com&#x2F;movie&#x2F;subject&#x2F;1424406GET http:&#x2F;&#x2F;api.douban.com&#x2F;movie&#x2F;subject&#x2F;imdb&#x2F;tt0213338 获取用户信息1GET http:&#x2F;&#x2F;api.douban.com&#x2F;people&#x2F;&#123;userID&#125; 返回值说明 名称 意义 备注 db:location 用户的长居地 用户可能没有长居地 db:uid 用户在豆瓣上的个人域名 title 用户的名号 content 用户的自我介绍 link rel=”alternate” 用户的豆瓣页面 link rel=”icon” 用户的头像图片链接 link rel=”homepage” 用户的个人主页 例如1GET http:&#x2F;&#x2F;api.douban.com&#x2F;people&#x2F;ahbei返回结果为一个Entry，包含用户的各种信息 豆瓣图书开源API：https://developers.douban.com/wiki/?title=book_v2搜索图书https://api.douban.com/v2/book/search 参数 意义 备注 q 查询关键字 q和tag必传其一 tag 查询的tag q和tag必传其一 start 取结果的offset 默认为0 count 取结果的条数 默认为20，最大为100 返回：返回status=200,123456&#123; &quot;start&quot;: 0, &quot;count&quot;: 10, &quot;total&quot;: 30, &quot;books&quot;: [Book, ]&#125;注：对于登陆用户，若搜索结果图书在当前用户的图书收藏中，会在对应搜索结果信息中附加当前用户对此书的收藏信息，该部分的Book数据结构如下：123456789101112131415&#123; ...(图书信息的其他部分) &quot;current_user_collection&quot;: &#123; &quot;status&quot;: &quot;read&quot;, &quot;rating&quot;: &#123; &quot;max&quot;: 5, &quot;value&quot;: &quot;5&quot;, &quot;min&quot;: 0 &#125;, &quot;updated&quot;: &quot;2012-11-2012:08:04&quot;, &quot;user_id&quot;: &quot;33388491&quot;, &quot;book_id&quot;: &quot;6548683&quot;, &quot;id&quot;: 605519800 &#125;&#125; 电影API请求所携带的参数： Property Description Type Basic Advance Premium Default start start int N/A Y Y 0 count count int N/A Y Y 10 返回回来的参数： Property Description Type Basic Advance Premium Default start start int N/A Y Y 0 count count int N/A Y Y 10 total 总数 int N/A Y Y 0 subject 电影条数 dict N/A Y Y - reviews 影评列表 array N/A Y Y - 简单示例：请求2条：1https:&#x2F;&#x2F;api.douban.com&#x2F;v2&#x2F;movie&#x2F;in_theaters?count&#x3D;2从第二条开始请求三条：1https:&#x2F;&#x2F;api.douban.com&#x2F;v2&#x2F;movie&#x2F;in_theaters?start&#x3D;2&amp;count&#x3D;3]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AJAX学习笔记(2)]]></title>
    <url>%2FAJAX%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2).html</url>
    <content type="text"><![CDATA[AJAX实例：留言板、瀑布流瀑布流项目开发 - 瀑布流实现原理分析 - 浮动与定位、优缺点 - 数据格式分析 - 页面数据填充 - 判断数据加载时机 留言本实战开发 - 用户名验证 - 用户注册 - 用户登陆 - 留言 - 顶功能 - 踩功能 - 留言数据获取 - 留言列表展现（瀑布流的形式） 瀑布流布局原理固定列数和非固定列数 统一宽不统一高(每列宽度相同高度不同) 数据不是一次性加载的，而是分批加载的（第一批显示多少条，满足一定条件时，开始第二批第三批等的加载）固定列（例：蘑菇街） 列数固定 浮动布局非固定列（例：百度图片） 列数会根据当前可视区的宽度动态计算 首先定义好每一列的宽度，再用可视区的宽度除以每一列的宽度得出当前显示的最大列数，根据列数进行定位 定位布局 数据的分析及添加流的实现示例：点击查看 留言本初始配置工作留言本验证用户名留言本注册及状态处理留言内容的添加和显示留言本数据列表的处理留言本类瀑布流效果AJAX跨域解决方案：JSONP跨域的问题 域：域名 跨域请求（访问）：一个域名下的文件请求另外一个域名下的资源，就产生了跨域跨域的解决 Jsonp: json padding 问题回顾及跨域限制问题跨域：跨域名一个域名下的文件去请求了和他不一样的域名下的资源文件，那么就会产生跨域请求 AJAX跨域请求限制 跨域的解决1.flash2.通过服务端中转，通过服务端的代码进行代理3.JSONP (JSON with Padding) 原理 1.script标签 2.用script标签加载资源是没有跨域问题的 3.计算机中文件类型并不是根据文件后缀名来区分的，而是根据文件中的实质内容定的。后缀名是给人看的或者给某些软件辨识的，右键会自动关联相应的文件类型 在资源加载进来之前定义好一个函数，这个函数接收一个参数（数据），函数里面利用这个参数做一些事情；然后需要的时候通过script标签加载对应远程文件资源，当远程的文件资源被加载进来的时候，就会去执行前面定义好的函数，并且把数据当作这个函数的参数传入进去 参考 过程的实现123456789101112&lt;input type&#x3D;&quot;button&quot; type&#x3D;&quot;按钮&quot; id&#x3D;&quot;btn1&quot;&gt;&lt;script&gt; window.onload &#x3D; function()&#123; var oBtn &#x3D; document.getElementById(&#39;btn1&#39;); &#x2F;&#x2F; 当按钮点击的时候再去加载远程资源，让它执行 var oScript &#x3D; document.createElement(&#39;script&#39;); oScript.src &#x3D; &#39;&#39;; document.body.appendChild(oScript); &#125;&lt;&#x2F;script&gt; 百度下拉提示实例12345678910111213141516171819202122232425262728293031323334353637&lt;style&gt; #q&#123;width: 300px;height: 30px;padding: 5px;border: 1px solid #f90;font-size: 16px;&#125; #ul1&#123;width: 310px;margin: 0;padding: 0;border: 1px solid #f90;display: none;&#125; li a&#123;display: block;line-height: 30px;padding: 5px;text-decoration: none;color: black;&#125; li a:hover&#123;background: #f90;color: #fff;&#125;&lt;&#x2F;style&gt;&lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;q&quot; autocomplete&#x3D;&quot;off&quot;&gt;&lt;ul id&#x3D;&quot;ul1&quot;&gt;&lt;&#x2F;ul&gt;&lt;script&gt; function test(data)&#123; var oUl &#x3D; document.getElementById(&#39;ul1&#39;); var html &#x3D; &#39;&#39;; if (data.s.length) &#123; oUl.style.display &#x3D; &#39;block&#39;; for (var i &#x3D; 0; i &lt; data.s.length; i++) &#123; html +&#x3D; &#39;&lt;li&gt;&lt;a target&#x3D;&quot;_blank&quot; href&#x3D;&quot;http:&#x2F;&#x2F;www.baidu.com&#x2F;s?wd&#x3D;&#39; + data.s[i] + &#39;&quot;&gt;&#39; + data.s[i] + &#39;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&#39;; &#125; oUl.innerHTML &#x3D; html; &#125; &#125; window.onload &#x3D; function()&#123; var oQ &#x3D; document.getElementById(&#39;q&#39;); var oUl &#x3D; document.getElementById(&#39;ul1&#39;); oQ.onkeyup &#x3D; function()&#123;&#x2F;&#x2F; 应该用oninput事件 if(this.value !&#x3D; &#39;&#39;)&#123; var oScript &#x3D; document.createElement(&#39;script&#39;); oScript.src &#x3D; &#39;http:&#x2F;&#x2F;suggestion.baidu.com&#x2F;su?wd&#x3D;&#39; + this.value + &#39;&amp;cb&#x3D;test&#39;; document.body.appendChild(oScript); document.body.removeChild(oScript); &#125; else &#123; oUl.style.display &#x3D; &#39;none&#39;; &#125; &#125; &#125;&lt;&#x2F;script&gt; 【示例：点击查看】 豆瓣搜索实例练习：分页【示例：点击查看】]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AJAX学习笔记(1)]]></title>
    <url>%2FAJAX%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(1).html</url>
    <content type="text"><![CDATA[AJAX原理和封装AjaxAjax: Asynchronous JavaScript and XML(异步的JavaScript和XML) - 节省用户操作时间，提高用户体验，减少数据请求 - 传输获取数据 请求状态监控 onreadystatechange readyState属性：请求状态 0 (初始化) 还没有调用open()方法 1 (载入) 已调用send()方法，正在发送请求 2 (载入完成) send()方法完成，已收到全部响应内容 3 (解析) 正在解析响应内容 4 (完成) 响应内容解析完成，可以在客户端调用了 status属性：服务器(请求资源)的状态 返回的内容 responseText：返回以文本形式存放的内容 responseXML：返回XML形式的内容 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;按钮&quot; id&#x3D;&quot;btn&quot;&gt;&lt;script&gt;var oBtn &#x3D; document.getElementById(&#39;btn&#39;);oBtn.onclick &#x3D; function()&#123; &#x2F;&#x2F;类比浏览一个网页的行为 &#x2F;&#x2F;打开浏览器 &#x2F;* 1.创建一个ajax对象 IE6以下 new ActiveXObject(&#39;Microsoft.XMLHTTP&#39;) &#x2F;&#x2F;内置插件 *&#x2F; &#x2F;&#x2F;var xhr &#x3D; new XMLHttpRequest(); &#x2F;&#x2F;会有兼容问题，需要加个判断 var xhr &#x3D; null; &#x2F;*if(window.XMLHttpRequest)&#123; &#x2F;&#x2F;注意不要写成XMLHttpRequest，这个方法在IE6下不存在仍会报错 xhr &#x3D; new XMLHttpRequest(); &#125;else&#123; xhr &#x3D; new ActiveXObject(&#39;Microsoft.XMLHTTP&#39;); &#125;*&#x2F; try&#123; &#x2F;&#x2F; 代码尝试执行块中的内容，如果有错误，则会执行catch&#123;&#125;,并且传入错误信息参数 &#x2F;&#x2F; throw new Error(); &#x2F;&#x2F;手动抛错,也会执行catch&#123;&#125; xhr &#x3D; new XMLHttpRequest(); &#125;catch(e)&#123; &#x2F;&#x2F; alert(e); xhr &#x3D; new ActiveXObject(&#39;Microsoft.XMLHTTP&#39;); &#125; &#x2F;&#x2F;在地址栏输入地址 &#x2F;* open方法 参数（和表单有些像） 1.打开方式 get post 2.地址 发送请求的地址 3.是否异步 异步：非阻塞模式 前面的代码不会影响后面代码的执行 &#x2F;&#x2F; 参数值为true 同步：阻塞模式 前面的代码会影响后面代码的执行 &#x2F;&#x2F; 参数值为false *&#x2F; &#x2F;* get方式 *&#x2F; &#x2F;&#x2F; 缓存 在url?后面接连接一个随机数，时间戳 (这个地方为了避免与传进来的参数名冲突，时间戳不赋给变量)（get是用来获取数据的，获取数据会被缓存） &#x2F;&#x2F; 传递中文时乱码问题 编码encodeURI xhr.open(&#39;get&#39;, &#39;1.get.php?username&#x3D;&#39; + encodeURI(&#39;名字&#39;) + &#39;&amp;age&#x3D;3&amp;&#39; + new Date().getTime(), true); &#x2F;&#x2F; 异步 &#x2F;&#x2F;提交 发送请求 xhr.send(); &#x2F;* post方式 *&#x2F; xhr.open(&#39;post&#39;, &#39;1.post.php&#39;, true); &#x2F;&#x2F; post方式，数据放在send()里面作为参数传递 xhr.setRequestHeader(&#39;content-type&#39;, &#39;application&#x2F;x-www-form-urlencoded&#39;); &#x2F;&#x2F; 申明发送的数据类型，必须 &#x2F;&#x2F; post没有缓存问题（post是用来提交数据的，提交数据不会被缓存 web机制） &#x2F;&#x2F; 请求头指定了编码方式，无需再手动编码 xhr.send(&#39;username&#x3D;&#39; + encodeURI(&#39;名字&#39;) + &#39;&amp;age&#x3D;3&amp;&#39; + new Date().getTime()); &#x2F;&#x2F;等待服务器返回内容 &#x2F;* readyState : ajax工作状态 responseText : ajax请求返回的内容被存放到这个属性下面 onreadystatechange : 当readyState改变的时候触发 status : 服务器状态，http状态码 *&#x2F; xhr.onreadystatechange &#x3D; function()&#123; if(xhr.readyState &#x3D;&#x3D; 4)&#123; if(xhr.status &#x3D;&#x3D; 200)&#123; alert(xhr.responseText); alert(typeof xhr.responseText); &#x2F;&#x2F; string &#125;else&#123; alert(&#39;出错了，Err:&#39; + xhr.status); &#125; &#125; &#125;&#125;&lt;&#x2F;script&gt; 表单表单：数据的提交 action：数据提交的地址，默认是当前页面 method：数据提交的方式，默认是get方式 1.get 把数据名称和数据值用=连接，如果有多个的话，那么会把多个数据组合用&amp;进行连接，然后把数据放到url?后面传到指定页面 url长度限制的原因，不要通过get方式传递过多的数据 通过url传递，可能会被记录下来（历史记录），暴露在外，可能会对用户隐私造成泄露 传递的值是字符串类型，不能传递其他的数据类型 2.post 理论上无限制（实际上限制还是有的，后端php.ini中设置post_max_size,默认值post_max_size=8M，有些服务器会不一样，自身理论上无限制） 通过请求头发送，不会被缓存 可以传递很多种类型，比如文本格式、二进制 enctype：提交的数据格式，默认是application/x-www-form-urlencoded $_REQUEST可以获取get方式传过来的数据也可以获取post方式传过来的数据如果使用$_REQUEST获取数据则用get方式或post方式传递都可以但如果指明了用get方式或post方式获取数据，传递方式需要对应起来 123456789101112&lt;form action&#x3D;&quot;1.get.php&quot;&gt; &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;username&quot;&gt; &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot;&gt;&lt;&#x2F;form&gt;&#96;&#96;&#96; JSON对象IE7及以下浏览器不支持如果浏览器当前的语言不支持json和字符串互转，可以到 [json.org](json.org) 下载对应的语言包引入[json2.js](https:&#x2F;&#x2F;github.com&#x2F;douglascrockford&#x2F;JSON-js&#x2F;blob&#x2F;master&#x2F;json2.js)以支持IE7及以下浏览器不支持stringify：把一个对象转换成对应的字符串 var arr = [1, 2, 3];alert(JSON.stringify(arr)); // [1, 2, 3]alert(typeof JSON.stringify(arr)); // string var j = {left:100};alert(JSON.stringify(arr)); // {“left”:100}JSON的key值必须是双引号&quot;包裹的1parse: 把字符串转成对应的对象var s1 = ‘[100,200,300]’;var a1 = JSON.parse(s1);alert(a1); // 100,200,300 var s2 = ‘{“left”:100}’;var a2 = JSON.parse(s2);alert(a2.left); // 100 var s3 = “{left:100}”;var a2 = JSON.parse(s2);alert(a2.left); // 报错，JSON的key值必须是双引号&quot;包裹的`]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BOM/EVENT学习笔记-事件（EVENT）测试题]]></title>
    <url>%2FBOM%2FEVENT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8B%E4%BB%B6%EF%BC%88EVENT%EF%BC%89%E6%B5%8B%E8%AF%95%E9%A2%98.html</url>
    <content type="text"><![CDATA[涉及知识点： 原生EVENT： - 事件流：冒泡、捕获 - 事件代理（事件委托） 12345678910111213141516171819202122232425&lt;style&gt; .active&#123;background: red;&#125;&lt;&#x2F;style&gt;&lt;div id&#x3D;&quot;box&quot;&gt; &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;1&quot;&gt; &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;2&quot;&gt; &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;3&quot;&gt; &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;4&quot;&gt; &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;5&quot;&gt;&lt;&#x2F;div&gt;(function()&#123; let box &#x3D; document.querySelector(&#39;#box&#39;); let btns &#x3D; box.querySelectorAll(&#39;input&#39;); document.addEventListener(&#39;click&#39;, functon(e)&#123; &#x2F;&#x2F;e.target 事件源(事件目标) 事件具体发生在哪个元素上 if(e.target.tagName &#x3D;&#x3D;&#x3D; &#39;INPUT&#39;)&#123; console.log(e.target.value); btns.forEach((item)&#x3D;&gt;&#123; item.classList.remove(&#39;active&#39;); &#125;); e.target.classList.add(&#39;active&#39;); &#125;; &#125;)&#125;)(); - 事件对象 - 事件监听和事件绑定]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BOM/EVENT学习笔记(4)]]></title>
    <url>%2FBOM%2FEVENT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4).html</url>
    <content type="text"><![CDATA[事件深入应用拖拽的原理onmousedown: 选择元素onmousemove: 移动元素onmouseup: 释放元素 1234567891011121314151617181920&lt;div id&#x3D;&quot;div1&quot;&gt;&lt;&#x2F;div&gt;&lt;script&gt; var oDiv &#x3D; document.getElementById(&#39;div1&#39;); oDiv.onmousedown &#x3D; function(ev)&#123; var ev &#x3D; ev || event; &#x2F;&#x2F; 兼容 var disX &#x3D; ev.clientX - this.offsetLeft; &#x2F;&#x2F; 鼠标距离盒子左边缘的距离 var disY &#x3D; ev.clientY - this.offsetTop; &#x2F;&#x2F; 鼠标距离盒子上边缘的距离 document.onmousemove &#x3D; function(ev)&#123; &#x2F;&#x2F; content var ev &#x3D; ev || event; oDiv.style.left &#x3D; ev.clientX - disX + &#39;px&#39;; oDiv.style.top &#x3D; ev.clientY - disY + &#39;px&#39;; &#125; document.onmouseup &#x3D; function()&#123; &#x2F;&#x2F; content document.onmousemove &#x3D; document.onmouseup &#x3D; null; &#125; &#125;&lt;&#x2F;script&gt; 当鼠标移动过快时，鼠标会移出div区域，div的onmousemove事件就不会被执行解决方案：给document加onmousemove事件，不要加到div上当移动到被另一个更高层级的元素后面时，onmouseup事件就不会被执行解决方案：给document加onmouseup事件，不要加到div上 拖拽的问题及解决方法1.拖拽的时候，如果有文字被选中，会产生问题 原因：当鼠标按下时，如果页面中有文字被选中，会触发浏览器默认的拖拽文字的效果 解决方法： 标准下：阻止默认行为 非标准IE：全局捕获 setCapture(); 拖拽图片会有问题，原因及解决方法同上 示例：点击查看 拖拽的封装-限制范围、磁性吸附示例：点击查看 碰撞检测原理分析： 把拖动的对象记为div，被碰撞对象记为img 把整个区域通过img所在边划分成九宫格，当要拖拽的对象不在图像所在的方格时则不会碰上，否则会碰上 L1,R1,T1,B1 分别为div的左右上下边 L2,R2,T2,B2 分别为img的左右上下边 当R1 &lt; L2 或 L1 &gt; R2 或 B1 &lt; T2 或 T1 &gt; B2 时不会发生碰撞 示例：点击查看 拖拽改变层大小原理分析： 拖动右边时，只有盒子右边位置发生变化，，只改变盒子宽度 以向右拖动为例，盒子宽度增加，增加的宽度为鼠标最后停在的位置的X轴坐标值减去鼠标按下时的X轴坐标值（当向左拖动时，为负值，盒子宽度减小） 拖动左边时，只有盒子左边位置发生变化，改变盒子宽度和left值 以向右拖动为例，盒子宽度减小，减小的宽度为鼠标最后停在的位置的X轴坐标值减去鼠标按下时的X轴坐标值（当向左拖动时，为负值，盒子宽度增加），left值则要加上这段距离 拖动上边时，只有盒子上边位置发生变化，改变盒子高度和top值 拖动下边时，只有盒子下边位置发生变化，只改变盒子高度 考虑同时拖动两条边的情况 示例：点击查看 滚动条的模拟和扩展运用滚动条组成： 滚动区域 滚动条 示例：点击查看 鼠标滚轮和cookie鼠标滚轮鼠标滚轮事件IE/Chrome : onmousewheel event.wheelDelta //滚轮滚动方向判断 上：120 //向上滚动 下：-120 //向下滚动FireFox : DOMMouseScroll 必须用addEventListener(实现绑定) event.detail //标准浏览器下有这个属性值为0，IE下，非标准下：undefined；标准下：0 上：-3 //向上滚动 下：3 //向下滚动return false;阻止的是 obj.on事件名称=fn 所触发的默认行为addEventListener绑定的事件需要通过event下面的preventDefault() 123456789101112131415161718element.onmousewheel &#x3D; handlerFunction;var handlerFunction &#x3D; element.onmousewheel;if(element.addEventListener)&#123; &#x2F;&#x2F; 非标准IE没有addEventListener方法会报错，这里需要判断一下，兼容 element.addEventListener(&#39;DOMMouseScroll&#39;, fn, false);&#125;var b &#x3D; ture; &#x2F;&#x2F;布尔值 兼容IE，Firefoxif (ev.wheelDelta) &#123; b &#x3D; ev.wheelDelta &gt; 0 ? true : false;&#125; else &#123; b &#x3D; ev.detail &lt; 0 ? ture : false;&#125;if (ev.preventDefault) &#123; ev.preventDefault();&#125;return false; 参考：1.GlobalEventHandlers.onmousewheel cookiecookie : 存储数据，当用户访问了某个网站（网页）的时候，可以通过cookie来向访问者的电脑上存储数据 1.不同的浏览器存放的cookie位置不一样，也是不能通用的 2.cookie的存储是以域名的形式进行区分的 3.cookie的数据可以设置名字的 4.一个域名下存放的cookie的个数是有限制的，不同的浏览器存放的个数不一样 5.没个cookie存放的内容大小也是有限制的，不同的浏览器存放的大小不一样 通过document.cookie来获取当前网站下的cookie的时候，得到字符串形式的值，他包含了当前网站下所有的cookie。他会把所有的cookie通过一个分号+空格的形式 串联起来 如果想要长时间存放一个cookie，需要在设置这个cookie的时候同时给他设置一个过期时间 cookie默认是临时存储，当浏览器关闭进程时自动销毁 内容最好编码存放，encodeURI document.cookie = &apos;名字=值&apos;; alert(document.cookie); document.cookie = &apos;username=name&apos;; document.cookie = &apos;age=10&apos;; document.cookie = &apos;名称=值;expires=&apos; + (字符串格式)时间; //这里时间必须是字符串形式。不能是一个日期对象，必须是日期对象的字符串 var oDate = new Date(); oDate.setDate(oDate.getDate() + 5); oDate.toGMTString(); document.cookie = &apos;username=name;expires=&apos; + oDate; document.cookie = &apos;age=10&apos;; // 内容最好编码存放，encodeURI // (否则有些特殊字符可能会出现问题，比如换行符`\n`,`\n`之后的部分会被截断不被存储) document.cookie = &apos;username=name\n你好;expires=&apos; + oDate; alert(document.cookie); // username=name alert( encodeURI(&apos;你好&apos;) ); // %E4%BD%A0%E5%A5%BD alert( decodeURI(&apos;%E4%BD%A0%E5%A5%BD&apos;) ); // 你好 document.cookie = &apos;username=&apos; + encodeURI(&apos;name\n你好&apos;) + &apos;;expires=&apos; + oDate; alert(decodeURI(document.cookie)); //封装 function setCookie(key, value, t)&#123; var oDate = new Date(); oDate.setDate(oDate.getDate() + t); document.cookie = key + &apos;=&apos; + value + &apos;;expires=&apos; + oDate.toGMTString(); &#125; function getCookie(key)&#123; var arr1 = document.cookie.split(&apos;; &apos;); for(var i = 0;i &lt; arr1.length; i++)&#123; var arr2 = arr1[i].split(&apos;=&apos;); if(arr2[0] == key)&#123; return decodeURI(arr2[1]); &#125; &#125; &#125; function removeCookie(key)&#123; setCookie(key, &apos;&apos;, -1); &#125; chrome 不能操作本地的cookie(本地测试不能用Chrome浏览器？) 应用：记录用户名示例：点击查看]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BOM/EVENT学习笔记(3)]]></title>
    <url>%2FBOM%2FEVENT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(3).html</url>
    <content type="text"><![CDATA[Event事件详解事件捕获123456789&lt;div id&#x3D;&quot;div1&quot;&gt; &lt;div id&#x3D;&quot;div2&quot;&gt; &lt;div id&#x3D;&quot;div3&quot;&gt;&lt;&#x2F;div&gt; &lt;&#x2F;div&gt;&lt;&#x2F;div&gt;document.addEventListener(&#39;onclick&#39;, fn1, true);document.addEventListener(&#39;onclick&#39;, fn2, true);document.addEventListener(&#39;onclick&#39;, fn3, true); 事件的取消第一种事件绑定形式的取消12345678function fn1()&#123; alert(1);&#125;function fn2()&#123; alert(2);&#125;document.onclick &#x3D; fn1;document.onclick &#x3D; null; &#x2F;&#x2F;取消第二种事件绑定形式的取消IE: obj.detachEvent(事件名称, 事件函数);标准: obj.removeEventListener(事件名称, 事件函数, 是否捕获);12345678document.attachEvent(&#39;onclick&#39;, fn1);document.attachEvent(&#39;onclick&#39;, fn2);document.detachEvent(&#39;onclick&#39;, fn1);document.addEventListener(&#39;click&#39;, fn1, false);document.addEventListener(&#39;click&#39;, fn1, true);document.addEventListener(&#39;click&#39;, fn2, false);document.removeEventListener(&#39;click&#39;, fn1, false); 参考：1.HtmlDocument.DetachEvent Method)2.EventTarget.removeEventListener 键盘事件onkeydown：当键盘按键按下的时候触发（如果按下不抬起，那么会连续触发）onkeyup：当键盘按键抬起的时候触发event.keyCode: 数字类型 键盘按键的值 健值 ctrlKey,shiftKey,altKey 布尔值 当一个事件发生的时候，如果 ctrl || shift || alt 是按下的状态，返回true，否则返回false12345678910document.onkeydown &#x3D; function(ev)&#123; &#x2F;&#x2F; alert(1); var ev &#x3D; ev || event; alert(ev.keyCode);&#125;document.onclick &#x3D; function(ev)&#123; var ev &#x3D; ev || event; alert(ev.ctrlKey);&#125; 不是所有元素都能够接收键盘事件，能够响应用户输入的元素，能够接收焦点的元素能够接收键盘事件思考：解决连续输入时输入第一个字符和后面字符间隔时间较长的问题，解决方案：定时器 示例：点击查看 事件默认行为-默认事件事件默认行为：当一个事件发生的时候浏览器自己会默认做的事情如何阻止：当前这个行为是什么事件触发的，然后在这个事件的处理函数中使用return false;123document.onkeydown &#x3D; function()&#123; return false;&#125;oncontextmenu: 右键菜单事件，当右键菜单（环境菜单）显示出来的时候触发1234document.oncontextmenu &#x3D; function()&#123; &#x2F;&#x2F; alert(1); return false;&#125;示例：点击查看]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BOM/EVENT学习笔记(2)]]></title>
    <url>%2FBOM%2FEVENT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2).html</url>
    <content type="text"><![CDATA[Event事件详解焦点事件焦点：使浏览器能够区分用户输入的对象，当一个元素有焦点时，就可以接收用户的输入可以通过一些方式给元素设置焦点：1.点击2.tab键3.js注意：不是所有元素都能够接收焦点，能够响应用户操作的元素才有焦点 1234567891011121314151617181920212223242526272829&lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;text1&quot; value&#x3D;&quot;请输入内容&quot;&gt;&lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;全选&quot; id&#x3D;&quot;btn&quot;&gt;&lt;script&gt; var oText &#x3D; document.getElementById(&#39;text1&#39;); &#x2F;&#x2F;onfocus: 当元素获取到焦点时触发 oText.onfocus &#x3D; function()&#123; if(this.value &#x3D;&#x3D; &#39;请输入内容&#39;)&#123; this.value &#x3D; &#39;&#39;; &#125; &#125; &#x2F;&#x2F;onblur: 当元素失去焦点时触发 oText.onblur &#x3D; function()&#123; if(this.value &#x3D;&#x3D; &#39;&#39;)&#123; this.value &#x3D;&#x3D; &#39;请输入内容&#39;; &#125; &#125; &#x2F;&#x2F;obj.foucs() 给指定的元素设置焦点 &#x2F;&#x2F;obj.blur() 取消指定元素的焦点 &#x2F;&#x2F;obj.select() 选择指定元素里面的文本内容 oText.foucs(); var oBtn &#x3D; document.getElementById(&#39;btn&#39;); oBtn.onclick &#x3D; function()&#123; oText.select(); &#x2F;&#x2F;select 能操作可交互元素的文本内容 &#125;&lt;&#x2F;script&gt; 参考：1.HTML DOM Event 对象2.onfocus 事件3.onblur 事件4.onselect 事件 event事件对象和clientX,clientYevent：事件对象，当一个事件发生的时候，和当前的这个对象发生的这个事件有关的一些详细的信息都会被保存到一个指定地方–event对象中，以供在需要时调用。 事件对象必须在一个事件调用的函数里面使用才有内容事件函数：事件调用的函数//一个函数是不是事件函数并不是在函数定义时决定的，而是函数调用时决定 兼容ie/chrome：event是一个内置全局对象// firefox：事件对象是通过事件函数的第一个参数传入标准浏览器下：事件对象是通过事件函数的第一个参数传入 如果一个函数是被事件调用的，那么，这个函数定义的第一个参数就是事件对象 clientX/clientY: 当一个事件发生的时候，鼠标到页面可视区的距离12345678910111213141516171819&lt;script&gt;alert(event); &#x2F;&#x2F; 这里没有事件发生&#x2F;&#x2F; ie&#x2F;chrome undefined&#x2F;&#x2F; firefox 报错 event is not definedfunction fn1(ev)&#123; &#x2F;&#x2F; alert(event); &#x2F;&#x2F; alert(ev); var ev &#x3D; ev || event; alert(ev); for(var attr in ev)&#123; console.log(attr + &#39;&#x3D;&#39; + ev[attr]); &#125;&#125;fn1(); &#x2F;&#x2F; 不是事件调用的函数document.onclick &#x3D; fn1(); &#x2F;&#x2F; 是事件调用的函数，event有内容&lt;&#x2F;script&gt;1234567891011121314151617181920212223&lt;style&gt;#div1&#123;width: 100px;height: 100px;background: red;position: absolute;&#125;&lt;&#x2F;style&gt;&lt;div id&#x3D;&quot;div1&quot;&gt;&lt;&#x2F;div&gt;&lt;script&gt; window.onload &#x3D; function()&#123; &#x2F;&#x2F; onmousemove: 当鼠标在一个元素上移动时触发 &#x2F;&#x2F; 触发频率不是像素，而是间隔时间，在一个指定的时间内（很短），如果鼠标的位置和上一次的位置发生了变化，那么就会触发一次 var i &#x3D; 0; var oDiv &#x3D; document.getElementById(&#39;div1&#39;); document.onmousemove &#x3D; function(ev)&#123; &#x2F;&#x2F; document.title &#x3D; i++; var ev &#x3D; ev || event; oDiv.style.left &#x3D; ev.clientX + &#39;px&#39;; oDiv.style.top &#x3D; ev.clientY + &#39;px&#39;; &#125; &#125;&lt;&#x2F;script&gt;示例：点击查看 事件流、事件冒泡机制事件流 事件冒泡 取消冒泡：ev.cancelBubble=true 例子：仿select控件 事件捕获 IE下是没有的，在绑定事件中，标准下是有的 12345678910111213141516171819202122232425262728293031&lt;style&gt; div&#123;padding: 40px;&#125; #div1&#123;background: red;&#125; #div2&#123;background: green;&#125; #div3&#123;background: blue;position: absolute;top: 300px;&#125;&lt;&#x2F;style&gt;&lt;div id&#x3D;&quot;div1&quot;&gt; &lt;div id&#x3D;&quot;div2&quot;&gt; &lt;div id&#x3D;&quot;div3&quot;&gt;&lt;&#x2F;div&gt; &lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;script&gt; window.onload &#x3D; function() &#123; &#x2F;** * 事件冒泡机制：当一个元素接收到事件的时候，会把它接收到的所有传给它的父级，一直到顶层window。 *&#x2F; var oDiv1 &#x3D; document.getElementById(&#39;div1&#39;); var oDiv2 &#x3D; document.getElementById(&#39;div2&#39;); var oDiv3 &#x3D; document.getElementById(&#39;div3&#39;); function fn1()&#123; alert(this.id); &#125; &#x2F;&#x2F; oDiv1.onclick &#x3D; fn1; 通常说的给XXX加事件，其实是给元素加事件处理函数 &#x2F;&#x2F; 事件函数绑定 oDiv1.onclick &#x3D; fn1; &#x2F;&#x2F;告诉div1，如果它接收到了一个点击事件，那么它就去执行fn1 &#x2F;&#x2F; oDiv2.onclick &#x3D; fn1; &#x2F;&#x2F; 这句话注释掉后，事件发生后不做任何处理，但是不影响接收事件 oDiv3.onclick &#x3D; fn1; &#125;&lt;&#x2F;script&gt; 阻止冒泡：在当前要阻止冒泡的事件函数中调用 ev.cancelBubble=true;123456789101112131415161718192021222324252627282930&lt;style&gt;div&#123;width: 100px;height: 200px; border: 1px solid red;&#125;&lt;&#x2F;style&gt;&lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;按钮&quot; id&#x3D;&quot;btn&quot;&gt;&lt;div id&#x3D;&quot;div1&quot;&gt;&lt;&#x2F;div&gt;&lt;script&gt;window.onload &#x3D; function()&#123; var oBtn &#x3D; document.getElementById(&#39;btn&#39;); var oDiv &#x3D; document.getElementById(&#39;div1&#39;); oBtn.onclick &#x3D; function(ev)&#123; var ev &#x3D; ev || event; ev.cancelBubble &#x3D; true; &#x2F;&#x2F; 阻止当前对象的当前事件的冒泡 oDiv.style.display &#x3D; &#39;block&#39;; &#125; oBtn.onmouseover &#x3D; function(ev)&#123; var ev &#x3D; ev || event; ev.cancelBubble &#x3D; true; &#x2F;&#x2F; 阻止当前对象的当前事件的冒泡 &#125; document.onclick &#x3D; function()&#123; &#x2F;&#x2F;setTimeout(function()&#123; &#x2F;&#x2F; oDiv.style.display &#x3D; &#39;none&#39;; &#x2F;&#x2F;&#125;, 1000); oDiv.style.display &#x3D; &#39;none&#39;; &#125;&#125;&lt;&#x2F;script&gt; 事件绑定的第二种形式给一个对象绑定一个事件处理函数的第一种形式：赋值12doucument.onclick &#x3D; fn1;doucument.onclick &#x3D; fn2; &#x2F;&#x2F;会覆盖fn1后面的赋值会把前面的赋值覆盖掉 给一个对象的同一个事件绑定多个不同的函数给一个对象绑定一个事件处理函数的第二种形式：函数 IE：obj.attachEvent(事件名称, 事件函数); 没有捕获 事件名称有on 事件函数执行的顺序：标准IE-&gt;正序；非标准IE-&gt;倒序； this指向window12345document.attachEvent(&#39;onclick&#39;, fn1);document.attachEvent(&#39;onclick&#39;, function()&#123; fn1.call(document);&#125;);document.attachEvent(&#39;onclick&#39;, fn2); 标准：obj.addEventListener(事件名称, 事件函数, 是否捕获);是否捕获：默认是false false：冒泡 true：捕获 有捕获 事件名称没有on 事件执行的顺序是正序 this指向触发该事件的对象12document.addEventListener(&#39;onclick&#39;, fn1, false);document.addEventListener(&#39;onclick&#39;, fn2, false); call 函数下的一个方法，call方法第一个参数可以改变函数执行过程中的内部this的指向，call方法第二个参数开始就是原来函数的参数列表第一个参数为空，不会改变this指向12345678910function bind(obj, evname, fn)&#123; if(obj.addEventListener)&#123; obj.addEventListener(evname, fn, false); &#125;else&#123; obj.attachEvent(&#39;on&#39; + evname, function()&#123; fn.call(obj); &#125;); &#125;&#125;bind(doucument, &#39;click&#39;, fn1); 参考：1.HtmlDocument.AttachEvent Method)2.EventTarget.addEventListener()]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BOM/EVENT学习笔记(1)]]></title>
    <url>%2FBOM%2FEVENT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(1).html</url>
    <content type="text"><![CDATA[BOM相关方法及属性BOM : Browser Object Model 浏览器对象模型打开、关闭窗口open() 方法 打开一个新的窗口（页面）close() 方法，关闭一个窗口（页面）关闭时提示问题，兼容性问题 123456789101112131415161718192021222324252627282930313233343536373839&lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;打开新窗口&quot;&gt;&lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;关闭窗口&quot;&gt;&lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;关闭新窗口&quot;&gt;&lt;script&gt; window.onload &#x3D; function()&#123; var aInput &#x3D; document.getElementsByTagName(&#39;input&#39;); var opener &#x3D; null; &#x2F;&#x2F; window.open(页面的地址URL, 打开的方式) window可以省略，写为open() &#x2F;&#x2F; 如果url为空，则默认打开一个空白页面 &#x2F;&#x2F; 如果打开方式为空，默认为新窗口方式打开 aInput[0].onclick &#x3D; function()&#123; &#x2F;&#x2F; window.open(&#39;&#39;,&#39;_self&#39;); opener &#x3D; window.open(); &#x2F;&#x2F; alert(opener &#x3D;&#x3D; window) &#x2F;&#x2F;flase opener.document.body.style.background &#x3D; &#39;red&#39;; &#x2F;&#x2F; 如果修改的是其他域名的样式，涉及到跨域问题，样式不会被修改 &#125; aInput[1].onclick &#x3D; function()&#123; window.close(); &#x2F;&#x2F; FireFox: 默认无法关闭 &#x2F;&#x2F; Chrome: 默认直接关闭 &#x2F;&#x2F; IE: 询问用户 &#125; aInput[2].onclick &#x3D; function()&#123; opener.close(); &#x2F;&#x2F;可以关闭在本窗口中通过js方法打开的新窗口 &#125; &#125;&lt;&#x2F;script&gt; 参考:1.Window 对象2.HTML DOM open() 方法3.HTML DOM close() 方法 常用属性 window.navigator.userAgent 浏览器信息 window.location window.navigator.userAgent 浏览器信息判断当前使用的浏览器12345if(window.navigator.userAgent.indexOf(&#39;MSIE&#39;) !&#x3D; -1)&#123; alert(&#39;ie浏览器&#39;);&#125;else&#123; alert(&#39;非ie浏览器&#39;);&#125;window.location 浏览器地址信息window.location.href : urlwindow.location.search : url?后面的内容window.location.hash : url#后面的内容参考:1.Navigator 对象2.Location 对象 文档宽高及窗口事件窗口尺寸与大小 可视区尺寸document.documentElement.clientWidthdocument.documentElement.clientHeigth 滚动距离document.body.scrollTop/scrollLeftdocument.documentElement.scrollTop/scrollLeft 内容高度document.body.scrollHeight 文档高度document.documentElement.offsetHeightdocument.body.offsetHeight 事件：onscroll: 当滚动条滚动时触发onresize: 当窗口大小发生改变时触发1234567var i &#x3D; 0;window.onscroll &#x3D; function()&#123; document.title &#x3D; i++;&#125;window.onresize &#x3D; function()&#123; document.title &#x3D; i++;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM详解]]></title>
    <url>%2FDOM%E8%AF%A6%E8%A7%A3.html</url>
    <content type="text"><![CDATA[javascript 组成 ECMAscript（javaScript核心标准，也是一个解析器）； DOM（通过document提供的一些方法或者属性来操作页面）； BOM（通过window提供的一些方法或属性来操作浏览器） DOM（Document Object Model）文档对象模型整个页面文档document提供了一些API（接口），赋予了开发者操作页面的能力 一般分为： 父级关系：只有一层上下级关系（从当前往上找） 子集关系：只有以下一层的关系 兄弟关系：同一个父级（同一级） 父子节点：上下两层节点之间的关系 祖先节点：当前节点上面的所有节点的统称 子孙节点：当前节点下面的所有节点的统称 节点类型： 节点类型 节点描述 nodeName nodeValue NodeType element 元素节点 元素名 null 1 attribute 属性节点 属性名称 属性值 2 text 文本节点 #text 文本内容 3 CDATASection XMLCDATA片段 #cdata-section 节点内容 4 EntityReference 实体引用 实体引用名称 null 5 Entity 实体 实体名称 null 6 ProcessingInstruction 处理指令 target 节点内容 7 comment 注释 #comment 注释文本 8 document 文档 #document null 9 DocumentType 文档实体接口 doctype名称 null 10 DocumentFragment 轻量级文档对象 #documentfragment null 11 Notation DTD 中声明的符号 符号名称 null 12 节点例子示例：点击查看 offsetLeft、offsetParentDOM节点 node.offsetParentoffsetParent 就是最近的有定位属性的祖先节点。（如果祖先节点都没有定位，那么默认为body|想要正常使用，子集要有定位，父级也要有定位|其他浏览器下需要设置宽高，否则会有兼容性问题） node.offsetLeft/node.offsetTopoffsetLeft/offsetTop就是最近的有定位属性的祖先节点的距离。例子：实用的文字提示层 node.getBoundingClientRect()获取元素的盒模型信息返回值为一个对象 left top bottom right width height 相对于浏览器可视区域 例子：实用的文字提示层+]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[this对象]]></title>
    <url>%2Fthis%E5%AF%B9%E8%B1%A1.html</url>
    <content type="text"><![CDATA[全局环境 window 事件处理函数 DOM事件处理函数 内联事件处理函数 函数内部 函数直接执行 非严格模式下 默认指向全局对象 浏览器 node node交互界面中 js文件中 严格模式下(前面省略window，浏览器严格模式支持) undefined call，apply和bind 把this的值从一个执行环境传入另一个执行环境 call和apply的参数差异 如果传入的不是对象会调用相对的构造函数，进行隐式转换 bind 返回一个新函数，内部this指向被修改 只会改变一次 箭头函数内部 与定义时的环境中 this 一致 点击元素定时改变 bind，call不能修改其内部指向 全局中定义箭头函数 全局对象 对象内函数定义箭头函数 对象内函数返回箭头函数 对象方法内部 当函数作为对象里的方法被调用时 调用该函数的对象 对象后续附属上的方法调用 调用该函数的对象 作为函数内嵌套多层的方法调用 就近绑定 构造函数中 构造函数中没有显式return 构造函数中显式return return 对象 return 非对象 原型链上函数 调用该函数的对象 getter 和 setter 中 get访问 set设置]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript基础学习(7)]]></title>
    <url>%2FJavaScript%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0(7).html</url>
    <content type="text"><![CDATA[Json、数组方法、随机函数、数组去重json数据格式及json语法1234567891011121314151617181920212223242526var json &#x3D; &#123;name: &#39;name&#39;, age: 3&#125;; &#x2F;&#x2F;安全性差var json2 &#x3D; &#123;&#39;name&#39;: &#39;name&#39;, &#39;age&#39;: 3&#125;; &#x2F;&#x2F;推荐格式var json3 &#x3D; &#123;&#39;name&#39;:[&#39;name1&#39;,&#39;name2&#39;], &#39;age&#39;:[3, 30]&#125;;var arr &#x3D; [&#123;&#39;name&#39;: &#39;name1&#39;, &#39;age&#39;: 3&#125;,&#123;&#39;name&#39;: &#39;name2&#39;, &#39;age&#39;: 30&#125;];alert(json2.name); &#x2F;&#x2F;namealert(json2[&#39;name&#39;]); &#x2F;&#x2F;undefinedalert(json2[&#39;name&#39;]); &#x2F;&#x2F;namealert(arr[0].name + &#39; &#39; + arr[0][&#39;age&#39;]); &#x2F;&#x2F;name1 3var json4 &#x3D; &#123;&#39;name&#39;: &#39;name&#39;, &#39;age&#39;: 3, &#39;fun&#39;: &#39;前端开发&#39;&#125;;for(var attr in json4)&#123; alert(attr); &#x2F;&#x2F;键名 alert(json4[attr]); &#x2F;&#x2F;健值 alert(json4[&#39;attr&#39;]); &#x2F;&#x2F;undefined 需要注意，加引号后会找json4的子集&#39;attr&#39;&#125;;var json5 &#x3D; &#123; &#39;url&#39;: [&#39;url1&#39;, &#39;url2&#39;], &#39;text&#39;: [&#39;text1&#39;, &#39;text2&#39;]&#125;;for(var attr in json5)&#123; for(var i &#x3D; 0; i &lt; json5[attr].length; i++)&#123; alert(json5[attr][i]); &#125;&#125; for-in遍历json1234567var str &#x3D; &#39;&#39;;var num &#x3D; 0; &#x2F;&#x2F;统计属性个数for(var attr in window)&#123; str +&#x3D; num + &#39;. &#39; + attr + &#39;:&#39; + window[attr] + &#39;&lt;br&gt;&#39;; num ++;&#125;document.body.innerHTML &#x3D; str; json没有长度属性，无法使用for循环数组也可以使用for in循环12345678var json &#x3D; &#123;&#39;name&#39;: &#39;name&#39;, &#39;age&#39;: 3&#125;;alert(json.length); &#x2F;&#x2F;undefinedvar arr &#x3D; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];for(var i in arr)&#123; alert(i); &#x2F;&#x2F;i为数组下标 alert(arr[i]);&#125; 数组定义及清空数组效率问题1234567891011121314var arr &#x3D; [1, 2, 3];&#x2F;&#x2F;var arr &#x3D; new Array(1, 2, 3);arr.length &#x3D; 1;alert(arr); &#x2F;&#x2F;1var arr &#x3D; new Array(3); &#x2F;&#x2F;接收参数为数字时默认为数组的长度var arr &#x3D; new Array(&#39;3&#39;);arr.length &#x3D; 0; &#x2F;&#x2F;可以快速清空数组arr &#x3D; []; &#x2F;&#x2F;相当于重新赋值，数组中值比较多时，这种方法效率较高var str &#x3D; &#39;aaaaa&#39;;str.length &#x3D; 1;alert(str); &#x2F;&#x2F;&#39;aaaaa&#39; 字符串的length属性是不可以写的 数组的方法与技巧123456789var arr &#x3D; [1, 2, 3];arr.push(4); &#x2F;&#x2F;向数组的末尾添加一个或多个元素，并返回新的长度。arr.unshift(0); &#x2F;&#x2F;向数组的开头添加一个或更多元素，并返回新的长度。IE 6、7不支持unshift返回值arr.pop(); &#x2F;&#x2F;删除并返回数组的最后一个元素。arr.shift(); &#x2F;&#x2F;把数组的第一个元素从其中删除，并返回第一个元素的值。arr.unshift(arr.pop);arr.push(arr.shift);&#x2F;&#x2F;可以做轮播图效果 splice 方法、数组去重splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目。注释：该方法会改变原始数组。语法：arrayObject.splice(index,howmany,item1,…..,itemX) 参数 描述 index 必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。 howmany 必需。要删除的项目数量。如果设置为 0，则不会删除项目。 item1, …, itemX 可选。向数组添加的新项目。 返回值 类型 描述 Array 包含被删除项目的新数组，如果有的话。 说明splice() 方法可删除从 index 处开始的零个或多个元素，并且用参数列表中声明的一个或多个值来替换那些被删除的元素。如果从 arrayObject 中删除了元素，则返回的是含有被删除的元素的数组。123456var arr &#x3D; [1, 2, 3];&#x2F;&#x2F;删除、替换、添加arr.splice(0, 1); &#x2F;&#x2F;从数组第0位起，删除1个值arr.splice(0, 2, &#39;one or two&#39;); &#x2F;&#x2F;将数组第0位起的2个值替换为&#39;one or two&#39;arr.splice(1, 0, &#39;1.5&#39;, &#39;1.8&#39;); &#x2F;&#x2F;将数组第1位后添加&#39;1.5&#39;, &#39;1.8&#39;&#x2F;&#x2F;只有删除时有返回值，返回删除掉的值数组去重12345678910var arr &#x3D; [1, 2, 2, 4, 2];for(var i &#x3D; 0; i &lt; arr.length; i ++)&#123; for(var j &#x3D; i + 1; j &lt; arr.length; j ++)&#123; if(arr[i] &#x3D;&#x3D; arr[j])&#123; arr.splice(j, 1); j --; &#125; &#125;&#125; sort排序12345678910111213141516171819202122232425262728293031var arr &#x3D; [&#39;c&#39;, &#39;d&#39;, &#39;a&#39;, &#39;e&#39;];arr.sort();alert(arr); &#x2F;&#x2F;[&#39;a&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]var arr2 &#x3D; [4, 3, 5, 76, 2, 0, 8];arr2.sort();alert(arr2); &#x2F;&#x2F;[0, 2, 3, 4, 5, 76, 8] 默认会按照字符串方法排序&#x2F;&#x2F;从小到大排序arr2.sort(function(a, b)&#123; return a - b;&#125;);alert(arr2); &#x2F;&#x2F;[0, 2, 3, 4, 5, 8, 76]&#x2F;&#x2F;从大到小排序arr2.sort(function(a, b)&#123; return b - a;&#125;);alert(arr2); &#x2F;&#x2F;76,8,5,4,3,2,0&#x2F;&#x2F;按照数字从小到大排序var arrWidth &#x3D; [&#39;345px&#39;, &#39;23px&#39;, &#39;10px&#39;, &#39;1000px&#39;];arrWidth.sort(function(a, b)&#123; return parseInt(a) - parseInt(b);&#125;);&#x2F;&#x2F;随机排序var arr &#x3D; [1, 2, 3, 4, 5, 6, 7, 8];arr.sort(function(a, b)&#123; return Math.random() - 0.5; &#125;); 排序：快速、希尔、冒泡、归并、选择、插入…、 随机数及随机公式推理过程12345678Math.random(); &#x2F;&#x2F;返回介于 0 ~ 1 之间的一个随机数Math.round(); &#x2F;&#x2F;把一个数字舍入为最接近的整数。Math.round(Math.random()*10); &#x2F;&#x2F;返回介于 0 ~ 10 之间的一个随机整数Math.round(Math.random()*5 + 5); &#x2F;&#x2F;返回介于 5 ~ 10 之间的一个随机整数Math.round(Math.random()*(y-x) + x); &#x2F;&#x2F;返回介于 x ~ y 之间的一个随机整数Math.round(Math.random()*x); &#x2F;&#x2F;返回介于 0 ~ x 之间的一个随机整数Math.ceil(Math.random()*x); &#x2F;&#x2F;返回介于 1 ~ x 之间的一个随机整数 concat、reverse、练习123456789var arr1 &#x3D; [1, 2, 3];var arr2 &#x3D; [4, 5, 6];var arr3 &#x3D; [7, 8, 9];arr1.concat(arr2, arr3); &#x2F;&#x2F;[1, 2, 3, 4, 5, 6, 7, 8, 9]arr1.reverse(); &#x2F;&#x2F;[3, 2, 1]var str &#x3D; &#39;abcdef&#39;;str.split(&#39;&#39;).reverse().join(&#39;&#39;); &#x2F;&#x2F;&#39;fedcba&#39; 练习：1.随机产生 550 个从 0～1000 之间不重复的整数2.为数组编写indexOf()方法：indexOf(‘img/1.jpg’)【示例：点击查看】 练习：1.人民网多图片滚动（随机图片滚动）【示例：点击查看】2.自定义字体形状（动画）【示例：点击查看】3.消除表情小游戏（掉QQ表情）【示例：点击查看】4.排序【示例：点击查看】 参考：1.JavaScript push() 方法2.JavaScript unshift() 方法3.JavaScript pop() 方法4.JavaScript shift() 方法5.JavaScript splice() 方法6.JavaScript sort() 方法6.JavaScript random() 方法6.JavaScript round() 方法6.JavaScript concat() 方法6.JavaScript reverse() 方法]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript基础学习(6)]]></title>
    <url>%2FJavaScript%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0(6).html</url>
    <content type="text"><![CDATA[字符串、查找高亮显示字符串获取类、封装检测数字的方法12345var str &#x3D; new String;str.length; &#x2F;&#x2F;字符串长度str.charAt(); &#x2F;&#x2F;获取字符串中的字符str.charCodeAt(); &#x2F;&#x2F;返回对应字符的编码 0～9 48～57 a~z 97~122 A~Z 65~90String.fromCharCode(); &#x2F;&#x2F;根据字符编码返回字符 判断是否是数字isNaN() 无法判断空格12345678function detectNum(str)&#123; var n &#x3D; 0; for(var i &#x3D; 0; i &lt; str.length; i++)&#123; n &#x3D; str.charCodeAt(i); if(n &lt; 48 || n &gt; 57) return false; &#125; return true;&#125; formCharCode返回字符串实例、字符串加密12345678910111213141516&lt;input type&#x3D;&quot;text&quot;&gt;&lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;加密&quot;&gt;&lt;div id&#x3D;&quot;div1&quot;&gt;加密。。。&lt;&#x2F;div&gt;&lt;script&gt;var aInp &#x3D; document.getElementsByTagName(&#39;input&#39;);var oDiv &#x3D; document.getElementById(&#39;div1&#39;);aInp[1].onclick &#x3D; function()&#123; var str &#x3D; aInp[0].value; var str1 &#x3D; &#39;&#39;; for(var i &#x3D; 0; i &lt; str.length; i++)&#123; str1 +&#x3D; String.fromCharCode(str.charCodeAt(i) - 1000) + &#39;:&#39;; &#125; oDiv.innerHTML &#x3D; str1;&#125;;&lt;&#x2F;script&gt; indexOf、lastIndexOf1234567891011121314151617181920212223function judgeI(str)&#123; for(var i &#x3D; 0; i &lt; str.length; i++)&#123; if(str.charAt(i) &#x3D;&#x3D;&#x3D; &#39;i&#39;)&#123; alert(i); &#125; &#125;&#125;var str &#x3D; &#39;string string string&#39;;str.indexOf(&#39;i&#39;);str.indexOf(&#39;i&#39;, 7); &#x2F;&#x2F;第二个参数表示从第几个字符开始找, 如果为负数或超出字符串长度则默认为0str.indexOf(&#39;X&#39;); &#x2F;&#x2F; -1 表示没有找到function judgeLocation(str, target)&#123; &#x2F;&#x2F;for(;str.indexOf(target, i) !&#x3D; -1;)&#123; &#x2F;&#x2F; alert(str.indexOf(target, i)); &#x2F;&#x2F; i &#x3D; str.indexOf(target, i) + s.length; &#x2F;&#x2F;&#125; while(str.indexOf(target, i) !&#x3D; -1)&#123; alert(str.indexOf(target, i)); i &#x3D; str.indexOf(target, i) + s.length; &#125;&#125; 比较类、截取类、substring应用实例字符串比较大小：比较第一个字符的编码大小1234567891011121314151617181920212223&lt;div&gt; &lt;p&gt;这是一段文字。这是一段文字。这是一段文字。这是一段文字。这是一段文字。这是一段文字。&lt;&#x2F;p&gt; &lt;span&gt;&lt;&lt;收起&lt;&#x2F;span&gt;&lt;&#x2F;div&gt;&lt;script&gt; window.onload &#x3D; function()&#123; var oP &#x3D; document.getElementsByTagName(&#39;p&#39;)[0]; var oSpan &#x3D; document.getElementsByTagName(&#39;span&#39;)[0]; var str &#x3D; oP.innerHTML; var onOff &#x3D; true; oSpan.onclick &#x3D; function () &#123; if(onOff)&#123; oP.innerHTML &#x3D; str.substring(0, 6); oSpan.innerHTML &#x3D; &#39;&gt;&gt;展开&#39;; &#125;else&#123; oP.innerHTML &#x3D; str; oSpan.innerHTML &#x3D; &#39;&lt;&lt;收起&#39;; &#125; onOff &#x3D; !onOff; &#125; &#125;&lt;&#x2F;script&gt;【示例：点击查看】 大小写转换、split分割字符串toUpperCase() //转成大写toLowerCase() //转成小写用来做判断 string.split(‘’) //字符串拆分成数组array.join(‘’) //数组连接成字符串split彩色文字效果实例 高亮显示关键字实例、替换搜索关键字实例123456789101112&lt;input type&#x3D;&quot;text&quot;&gt;&lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;按钮&quot;&gt;&lt;p&gt;这是一段文字。这是一段文字。这是一段文字。这是一段文字。这是一段文字。这是一段文字。&lt;&#x2F;p&gt;&lt;script&gt; var aInp &#x3D; document.getElementsByTagName(&#39;input&#39;); var oP &#x3D; document.getElementsByTagName(&#39;p&#39;)[0]; aInp[1].onclick &#x3D; function()&#123; var str &#x3D; aInp[0].value; if(!str) return; oP.innerHTML &#x3D; oP.innerHTML.split(str).join(&#39;&lt;span&gt;&#39; + str + &#39;&lt;&#x2F;span&gt;&#39;); &#125;&lt;&#x2F;script&gt;【示例：点击查看】 字符串方法总结123456789101112131415161718192021var str &#x3D; &#39;String string&#39;;str.charAt(1); &#x2F;&#x2F;&quot;t&quot;str.charCodeAt(0); &#x2F;&#x2F;83String.fromCharCode(83); &#x2F;&#x2F;&quot;S&quot;str.indexOf(&#39;r&#39;, 3); &#x2F;&#x2F;9str.lastIndexOf(&#39;i&#39;); &#x2F;&#x2F;10&#39;1000&#39; &lt; &#39;2&#39; &#x2F;&#x2F;true&#39;1000&#39; &gt; 2 &#x2F;&#x2F;truestr.substring(0, 4); &#x2F;&#x2F;&quot;Stri&quot;str.slice(-3); &#x2F;&#x2F;&quot;ing&quot;str.toUpperCase(); &#x2F;&#x2F;STRING STRINGstr.toLowerCase(); &#x2F;&#x2F;string stringstr.split(&#39;i&#39;, 2); &#x2F;&#x2F;[&quot;Str&quot;, &quot;ng str&quot;]var arr &#x3D; [&#39;s&#39;,&#39;t&#39;,&#39;r&#39;,&#39;i&#39;,&#39;n&#39;,&#39;g&#39;];str.join(&#39;&#39;); &#x2F;&#x2F;&quot;string&quot; 练习：1.查找、替换、删除【示例：点击查看】2.文字搬运工【示例：点击查看】]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript基础学习(5)]]></title>
    <url>%2FJavaScript%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0(5).html</url>
    <content type="text"><![CDATA[日期对象、时钟倒计时时间对象实例 获取时间对象：new Date() getFullYear() getMonth() //从0开始计数 getDate() getDay() //星期 getHours() getMinutes() getSecends() 实例：网站电子时钟 练习：图片时钟扩展版 上下切换 倒计时 Date对象参数 数字形式：new Date(2018,9,12,17,01,35); //需要注意月份是从0开始的 字符串形式：new Date(&#39;September 12,2018 17:01:35&#39;); 月份取值 January、February、March、April、May、June、July、August、September、October、November、December； 时间转换公式 天：Math.floor(t/86400) 时：Math.floor(t%86400/3600) 分：Math.floor(t%86400%3600/60) 秒：t%60 时间戳：getTime() 返回从1970年1月1日0点0分0秒0毫秒 //时间戳是指格林威治时间1970年01月01日00时00分00秒(北京时间1970年01月01日08时00分00秒)起至现在的总秒数。倒计时原理现在的时间点（变）未来的时间点（不变）123456789101112131415161718192021222324252627282930距离：&lt;input type&#x3D;&quot;text&quot;&gt;&lt;br&gt;还剩：&lt;input type&#x3D;&quot;text&quot;&gt;&lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;点击&quot;&gt;&lt;script&gt; window.onload &#x3D; function()&#123; var aInp &#x3D; document.getElementsByTagName(&#39;input&#39;); var iNow &#x3D; null; var iNew &#x3D; null; var t &#x3D; 0; var str &#x3D; &#39;&#39;; var timer &#x3D; null; aInp[2].onclick &#x3D; function()&#123; iNew &#x3D; new Date(aInp[0].value); clearInterval(timer); setInterval(function()&#123; iNow &#x3D; new Date(); t &#x3D; Math.floor((iNew - iNow)&#x2F;1000); &#x2F;&#x2F;单位：毫秒 -&gt; 秒 if(t &gt;&#x3D; 0)&#123; str &#x3D; Math.floor(t&#x2F;86400) + &#39;天&#39; + Math.floor(t%86400&#x2F;3600) + &#39;时&#39; + Math.floor(t%86400%3600&#x2F;60) + &#39;分&#39; + t%60 + &#39;秒&#39;; &#125;, 1000); aInp[1].value &#x3D; str; &#125;else&#123; clearInterval(timer); &#125; &#125;; &#125;;&lt;&#x2F;script&gt;时间戳new Date().getTime();一般用来检测性能，看一段程序运行花费的时间或者用来判断cookie值等 练习：抢购商品练习（倒计时结束后下架商品抖动一下掉落并自动计算价格）【示例：点击查看】]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编辑器选择与配置]]></title>
    <url>%2F%E7%BC%96%E8%BE%91%E5%99%A8%E9%80%89%E6%8B%A9%E4%B8%8E%E9%85%8D%E7%BD%AE.html</url>
    <content type="text"><![CDATA[PhpStormSublimeAtom 安装插件file iconsemmetdocblockr 设置微信小程序代码高亮1、打开 config.cson 配置文件Atom -&gt; Config123456&quot;*&quot;: core: customFileTypes: &#39;text.html.basic&#39;: [&#39;wxml&#39;] &#39;source.css&#39;: [&#39;wxss&#39;] &#39;source.js&#39;: [&#39;wxs&#39;] 参考：http://www.okeydown.com/html/2018/06-16/545.html]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>编辑器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript基础学习(4)]]></title>
    <url>%2FJavaScript%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0(4).html</url>
    <content type="text"><![CDATA[return、定时器return：返回值 1）函数名+括号：fn1() ==&gt; return 后面的值； 2）所有函数默认返回值：未定义； 3）return 后面任何代码都不再执行 arguments实参集合与局部变量、参数关系当函数的参数个数无法确定时用arguments123456789alert(sum(1,2,3)); &#x2F;&#x2F;6alert(sum(1,2,3,4)); &#x2F;&#x2F;10function sum()&#123; var n &#x3D; 0; for(var i &#x3D; 0; i &lt; arguments.length; i++)&#123; n +&#x3D; arguments[i]; &#125; return n;&#125;小练习：alert(sum(1,2,3,’+’)); //6alert(sum(10,2,3,4,’-‘)); //1 currentSytle 与 getComputedStylegetComputedStyle 获取的是计算机（浏览器）计算后的样式 //IE 6 7 8 兼容问题currentSytle 获取当前样式 //标准浏览器不兼容1234567891011121314function getStyle(obj,attr)&#123; &#x2F;&#x2F;if(obj.currentStyle)&#123; &#x2F;&#x2F; return obj.currentStyle[attr]; &#x2F;&#x2F;&#125;else&#123; &#x2F;&#x2F; return getcomputedStyle(obj)[attr]; &#x2F;&#x2F;&#125; return obj.currentStyle?obj.currentStyle[attr]:getcomputedStyle(obj)[attr];&#125;alert(getStyle(oDiv,&#39;width&#39;));alert(getStyle(oDiv,&#39;background&#39;)); &#x2F;&#x2F;获取复合样式会有问题alert(getStyle(oDiv,&#39;backgroundColor&#39;)); &#x2F;&#x2F;获取单一样式可以得到值，但会有兼容性问题，不要用来做判断不要有空格不要获取未设置的样式：不兼容 12345678定时器：时间概念var timer &#x3D; setInterval(函数, 毫秒); 重复执行（发动机）clearInterval(timer); 清除var timer &#x3D; setTimeout(函数, 毫秒); 执行一次（炸弹）clearTimeout(timer);定时器如果是由事件控制的，要先关后开，否则可能会出问题 【示例：点击查看】 定时器应用：自动切换焦点图、qq延时菜单1.延时消失的菜单2.凤凰网科技频道自动轮换选项卡3.按钮控制商品图片上下滚动4.淘宝商品广告效果 定时器管理、函数封装 练习：点击往下掉的小块，再点击回来，掉落过程中不可操作 抖动原理及实现过程12345678910111213141516171819202122232425262728function getStyle(obj, attr)&#123; return obj.currentStyle?obj.currentStyle[attr]:getcomputedStyle(obj)[attr];&#125;function shake(obj, attr, endFn)&#123; var pos &#x3D; parseInt(getStyle(obj, attr)); &#x2F;&#x2F;有隐患 var arr &#x3D; []; &#x2F;&#x2F;20,-20,18,-18...0 var num &#x3D; 0; var obj.shake &#x3D; null; for(var i &#x3D; 20; i &gt; 0; i -&#x3D; 2)&#123; arr.push(i, -i); &#125; arr.push(0); clearInterval(obj.shake); obj.shake &#x3D; setInterval(function()&#123; obj.style[attr] &#x3D; pos + arr[num] + &#39;px&#39;; num++; if(num &#x3D;&#x3D;&#x3D; arr.length)&#123; clearInterval(obj.shake); endFn &amp;&amp; endFn(); &#125; &#125;, 50);&#125;function fnShake()&#123; var _this &#x3D; this; shake(_this, &#39;left&#39;, function()&#123; shake(_this, &#39;top&#39;); &#125;);&#125; 【示例：点击查看】练习： 抖动函数的隐患、修复 点击加分效果-可重复点击 图片自动切换 新浪数码频道选项卡注：抖函数的问题在于每次移入的时候,是获取的当前的位置,可以从如下方向解决:1-在元素停止抖动之前, 再次移入是无效的2-在鼠标移入的时候获取不在尝试修改元素的相同属性,比如元素的位置是使用 定位控制的,那么控制元素抖动的时候,使用margin来改变]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript基础学习(3)]]></title>
    <url>%2FJavaScript%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0(3).html</url>
    <content type="text"><![CDATA[函数传参、重用、价格计算参数：JS的数据类型12345678910111213141516&lt;script&gt;fn1(100);fn1(&#39;abc&#39;);fn1(function()&#123;alert(1);&#125;);function fn1(a)&#123; if(typeof a &#x3D;&#x3D;&#x3D; &#39;number&#39; &amp;&amp; a &#x3D;&#x3D;&#x3D; a)&#123;&#x2F;&#x2F;判断为数字类型 alert(a+20); &#125;else if(typeof a &#x3D;&#x3D;&#x3D; &#39;string&#39;)&#123; alert(a.charAt(2)); &#125;else if(typeof a &#x3D;&#x3D;&#x3D; &#39;function&#39;)&#123; a(); &#125;&#125;&lt;&#x2F;script&gt; 传参应用：类型判断及多组图片切换实例重用代码：1.尽量保证HTML代码结构一致，可以通过父级选取子元素2.把核心主程序实现，用函数包起来3.把每组里不同的值找出来，通过传参实现 传参实例：商品价格计算及小练习练习1:- 0 + 单价：12.5元 小计：0元- 0 + 单价：8.5元 小计：0元- 0 + 单价：10元 小计：0元- 0 + 单价：14.5元 小计：0元商品合计共：0件，共花费了：0元其中最贵的商品单价是：0元练习2:修改文本框的值|分类名称|||-|-||分类1|编辑||分类2|编辑|点击编辑后：|分类名称||||-|-|-||分类1（可以编辑的文本框）|保存|取消|练习3:搜狐视频纪录片列表展示 鼠标移入改变样式练习4:选择卡里套选择卡 JS作用域概念-预解析规则、表达式作用域：域：空间、范围、区域…作用：读、写 script 全局变量、全局函数 自上而下函数 由里到外{} 浏览器： “JS解析器” 1）”找一些东西”：var function 参数(参数本质上就是一个局部变量) a = … 所有的变量，在正式运行代码之前，都提前赋了一个值：未定义 fn1 = function fn1()&#123;alert(2);&#125; 所有的函数，在正式运行代码之前，都是整个函数块 JS的预解析 遇到重名的：只留一个 变量和函数重名了，就只留下函数 2）逐行解读代码： 表达式：`=` `+` `-` `*` `/` `%` `++` `--` `!` 参数... 表达式可以修改预解析的值！ 函数调用 1234567var a &#x3D; 1;function fn1()&#123; alert(a); &#x2F;&#x2F; undefined var a &#x3D; 2;&#125;fn1();alert(a); &#x2F;&#x2F; 1 1234567var a &#x3D; 1;function fn1()&#123; alert(a); &#x2F;&#x2F; 1 a &#x3D; 2;&#125;fn1();alert(a); &#x2F;&#x2F; 2 1234567var a &#x3D; 1;function fn1(a)&#123; alert(a); &#x2F;&#x2F; undefined var a &#x3D; 2;&#125;fn1();alert(a); &#x2F;&#x2F; 1 1234567var a &#x3D; 1;function fn1(a)&#123; alert(a); &#x2F;&#x2F; 1 var a &#x3D; 2;&#125;fn1(a);alert(a); &#x2F;&#x2F; 1 想要获取函数内的值：12345678910111213141516var str &#x3D; &#39;&#39;;function fn1()&#123; var a &#x3D; &#39;goods&#39;; str &#x3D; a;&#125;fn();alert(str);function fn2()&#123; var a &#x3D; &#39;something&#39;; fn(a);&#125;fn2();function fn3(a)&#123; alert(a);&#125;if(){}for(){}while(){}do{}while()中花括号包含的代码块不是作用域FireFox不能对扩展代码块中的函数预解析总结：尽量不要在if、for等语句里定义变量或函数，定义在代码块外 运算符、程序流程控制 运算符算术：+加、-减、*乘、/除、%取模（求余数） 实例：腾讯首页隔行变色 实例：隔行变色扩展 实例：京东商城秒转时间赋值：=、+=、-=、*=、/=、%=关系：&lt;、&gt;、&lt;=、&gt;=、==、!=、===、!==逻辑：&amp;&amp;与、||或、!否 实例：全选、不选与反选运算符优先级：括号 程序流程控制判断：if、switch（case break default）、?:循环：while、for跳出：break、continue什么是真、什么是假 真：非零的数字、非空字符串、true、函数、object:[]{}元素（存在） 假：零、NaN、空字符串、false、null、未定义1234567891011121314151617181920212223&lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;反选&quot;&gt;&lt;ul&gt; &lt;li&gt;&lt;input type&#x3D;&quot;checkbox&quot; checked&gt;&lt;&#x2F;li&gt; &lt;li&gt;&lt;input type&#x3D;&quot;checkbox&quot;&gt;&lt;&#x2F;li&gt; &lt;li&gt;&lt;input type&#x3D;&quot;checkbox&quot; checked&gt;&lt;&#x2F;li&gt; &lt;li&gt;&lt;input type&#x3D;&quot;checkbox&quot;&gt;&lt;&#x2F;li&gt; &lt;li&gt;&lt;input type&#x3D;&quot;checkbox&quot;&gt;&lt;&#x2F;li&gt;&lt;&#x2F;ul&gt;&lt;script&gt;window.onload &#x3D; function()&#123; var aInp &#x3D; document.getElementsByTagName(&#39;input&#39;); aInp[0].onclick &#x3D; function()&#123; for(var i &#x3D; 1; i &lt; aInp.length; i++)&#123; aInp[i].checked &#x3D; !aInp[i].checked; &#x2F;*if(aInp[i].checked)&#123; aInp[i].checked &#x3D; false; &#125;else&#123; aInp[i].checked &#x3D; true; &#125;*&#x2F; &#125; &#125;&#125;&lt;&#x2F;script&gt; 真假的问题：数据类型-数字（NaN）、字符串、布尔、函数、对象（element、[]、{}、null）、未定义真：非0的数字、非空字符串、true、函数、能找到的元素、[]、{}假：0、NaN、空字符串、false、不能找到的元素、null、未定义 练习：1.百度文库评分；【示例：点击查看】2.百度音乐-全选操作；【示例：点击查看】]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript基础学习(2)]]></title>
    <url>%2FJavaScript%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0(2).html</url>
    <content type="text"><![CDATA[JS数据类型、类型转换ECMAScript：标准、核心 JS中的数据类型：数字、字符串、布尔、函数、对象（obj、[]、{}、null）、未定义typeof 判断数据类型 显式类型转换(强制类型转换)：Number()parseInt()parseFloat() Number() 函数把对象的值转换为数字。123456789101112131415161718192021222324var s &#x3D; &#39;123&#39;;Number(s); &#x2F;&#x2F;123var s &#x3D; &#39;00000123&#39;;Number(s); &#x2F;&#x2F;123var s &#x3D; &#39;+123&#39;;Number(s); &#x2F;&#x2F;123var b &#x3D; true;Number(b); &#x2F;&#x2F;0var f &#x3D; function()&#123;alert(1);&#125;;Number(f); &#x2F;&#x2F;NaNvar json &#x3D; &#123;&#125;;Number(json); &#x2F;&#x2F;NaNvar arr &#x3D; [];Number(arr); &#x2F;&#x2F;0var arr &#x3D; [1];Number(arr); &#x2F;&#x2F;1var arr &#x3D; [&#39;1&#39;];Number(arr); &#x2F;&#x2F;1var arr &#x3D; [1,2];Number(arr); &#x2F;&#x2F;NaNvar o &#x3D; null;Number(o); &#x2F;&#x2F;0var u;Number(u;) &#x2F;&#x2F;NaN parseInt与parseFloat的区别123var b &#x3D; &#39;100px&#39;;Number(b); &#x2F;&#x2F;NaNparseInt(b); &#x2F;&#x2F;100 parseInt与parseFloat可用于判断是整数还是小数 隐式类型转换 + 运算会把数字转换为字符串 - * / % 运算会把字符串转换为数字 ++ -- 运算会把字符串转换为数字 &gt; &lt; 数字的比较、字符串的比较- `alert(&apos;10&apos; &gt; 9); //true` - `alert(&apos;10&apos; &gt; &apos;9&apos;); //false` - 数字的比较(比较大小)与字符串的比较(一位一位的比较)是不同的 ! 取反 把右边的数据类型转换成布尔值 isNaN应用实例NaN === NaN //flase(除NaN外其他类型数据都等于其自身)isNaN：判断某些值是不是数字isNaN内部是根据Number()进行转换的 数据类型转换小练习12345678910111213141516171819&lt;script&gt;var arr &#x3D; [&#39;100px&#39;,&#39;abc&#39;-6,[],-98765,34,-2,0,&#39;300&#39;, ,function()&#123;alert(1);&#125;,null,document,[],true,&#39;200px&#39;-30,&#39;23.45元&#39;,5,Number(&#39;abc&#39;),function()&#123;alert(3)&#125;];&#x2F;*1.找到arr里所有的数字：-98765,34,-2,0,52.找到可以转成数字的：&#39;100px&#39;,-98765,34,-2,0,&#39;300&#39;,53.把转成数字以后，最大值判断出来：3004.把NaN所在的位置找出来：1 14 17 *&#x2F;&#x2F;*qq号码 判断1.有没有输入2.输入的是不是数字3.不能有0在前面4.不能是小数5.输入的数字必须在5位以上、10位以内 *&#x2F;&lt;&#x2F;script&gt; 【示例：点击查看】]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript基础学习(1)]]></title>
    <url>%2FJavaScript%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0(1).html</url>
    <content type="text"><![CDATA[HTML 属性操作 属性读操作：获取、找到元素.属性名 属性写操作：(添加)替换、修改元素.属性名 = 新的值 oP.innerHTML 读取元素内的所有HTML内容oP.innerHTML = 新的值 替换元素内的所有HTML内容oP.innerHTML += 新的值 添加元素内的所有HTML内容 属性操作实例：模拟手机短信发送 属性操作注意事项JS不允许出现的特殊字符 实例：网页字体大小控制 JS中操作属性名不允许出现‘-’，要把‘-’去掉，‘-’后的单词首字母大写 css3中浏览器前缀也同 给元素添加class 实例：替换皮肤 - 行间样式与className 关键字、保留字 不能使用保留字、关键字,如需要操作class属性时要将其替换成className class 保留字 关键字：js语言中用到的单词 var function class =&gt; className 相对路径的读取问题 所有的相对路径都不要用来做判断 - img src - href 颜色值不要用来做判断 - color innerHTML值不要用来做判断 //会引发兼容性问题 表单元素的type值修改 IE6、IE7、IE8兼容性问题及解决思路 可以考虑使用控制元素隐藏显示的方式实现 float的兼容性问题 IE（sytleFloat）、非IE（cssFLoat） 12oDiv.sytle.styleFloat &#x3D; &#39;left&#39;;oDiv.sytle.cssFloat &#x3D; &#39;left&#39;; 可以考虑把浮动样式写到css里，用添加class的方式实现 属性操作中的：[] 实例：任意修改DIV的值 JS中允许把“.”替换成“[]” 条件判断缺少判断条件时 for循环重复执行某些代码每次执行的时候，有个数字在变化性能问题。for循环内部尽量不要直接操作dom元素或者复杂计算比如需要用arr.length可以先存到一个变量中，12345678910for( var i&#x3D;0; i&lt;arr.length; i++ )&#123; document.body.innerHTML +&#x3D; ‘&lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;按钮&quot;&gt;’;&#125;&#x3D;&gt; var len &#x3D; arr.length; var str &#x3D; &#39;&#39;; for( var i&#x3D;0; i&lt;len; i++ )&#123; str +&#x3D; &#39;&lt;imput type&#x3D;&quot;button&quot; value&#x3D;&quot;按钮&quot;&gt;&#39;; &#125; document.body.innerHTML +&#x3D; str;循环生成坐标（利用绝对定位来做）小练习 一字排开；逢十换行；v字形坐标 for循环遍历二维数组、嵌套元素 123456789101112&lt;script&gt; var arr &#x3D; [ [ 1,2,3 ], [ 4,5,6 ], [ 7,8,9 ] ]; for( var i&#x3D;0; i&lt;arr.length; i++ )&#123; for( var j&#x3D;0; j&lt;arr[i].length; j++ )&#123; alert(arr[i][j]); &#125; &#125;&lt;&#x2F;script&gt; cssText文本格式化与属性操作var oDiv.style.cssText = &#39; width:200px; height:200px &#39;; //该操作会替换行间样式 实例：生成一组新闻及思路分析思路：1.按钮不可操作（用户体验不好）a. oBtn.disabled = true; b. oBtn.display = ‘none’;2.先清空，再生成（很多时候会用到，但性能会有影响）3.判断 关键字：this this是什么当前方法、函数的调用对象通过事件调用函数的对象 函数套函数中的this指向嵌套函数中的thisthis的变量引用 this运用this选取当前元素this选取当前元素内的子元素 this指向及this应用this：指的是调用当前方法(函数)的那个对象 1234567891011121314151617181920212223function fn1()&#123; alert(this);&#125;fn1(); this &#x3D;&gt; windowoDiv.onclick &#x3D; fn1(); this &#x3D;&gt; oDivoDiv.onclick &#x3D; function()&#123; fn1(); &#x2F;&#x2F;fn1()里的this &#x3D;&gt; window&#125;&lt;div onclick&#x3D;&quot;this&quot;&gt;&lt;&#x2F;div&gt; this &#x3D;&gt; oDiv&lt;div onclick&#x3D;&quot;fn1();&quot;&gt;&lt;&#x2F;div&gt; fn1()里的this &#x3D;&gt; windowthisfn1(this);function fn1(obj)&#123; obj &#x3D;&gt; window&#125;oDiv.onclick &#x3D; function()&#123; this fn1(this);&#125;function fn1(obj)&#123; obj &#x3D;&gt; oDiv&#125; 小练习逢十往下一行小v字形【示例：点击查看】 自定义属性、自定义一组开关应用 什么是自定义属性运用for循环为一组元素添加开关 实例：点击当前列表，切换各自的class 添加索引值index索引值索引值运用：图片切换实例 思路一：全部清除 思路二：消除上一个 图片切换实例扩展this引用函数合并 JS可以为任何HTML元素添加任意个自定义属性12345678910111213&lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;按钮1&quot;&gt;&lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;按钮2&quot;&gt;&lt;script&gt;window.onload &#x3D; function()&#123; oBtn &#x3D; document.getElementsByTagName(&#39;input&#39;); for(var i &#x3D; 0; i &lt; oBtn.length; i ++)&#123; oBtn[i].abc &#x3D; 123; oBtn[i].xyz &#x3D; true; &#125;&#125;&lt;&#x2F;script&gt; 获取自身递增数字及匹配数组内容 添加索引值、匹配数组、HTML元素 图片切换综合实例1:布局图片切换综合实例2:数据与初始化图片切换综合实例3:两种图片切换思路 思路1:全部清除 当前添加 思路2:消除上一个 当前添加图片切换综合实例4:代码简化函数合并QQ菜单实例1：实现折叠与展开QQ菜单实例2：实现点击高亮显示、3道作业要求练习： qq菜单【示例：点击查看】 带缩略图的图片轮换【示例：点击查看】 花瓣【示例：点击查看】]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bootstrap学习]]></title>
    <url>%2Fbootstrap%E5%AD%A6%E4%B9%A0.html</url>
    <content type="text"><![CDATA[栅格系统 分12列rowcol 阈值1200 &gt;=992 &gt;=768 &gt;=768 &lt; 语法col-lg-col-md-col-sm-col-xs- 组合模式实例：bs官网 其他列偏移 col-[]-offset-列排序 col-[]-push- col-[]-pull-嵌套清浮动 响应式工具 概念 针对不同设备展示或隐藏页面内容 可见类 visible-- lg md sm xs block inline inline-blockhidden-* 打印类 visible-print-* hidden-print实例：天猫侧边栏 Glyphicons 字体图标 好处减少请求容易控制样式例子：淘宝 用法font-face字体路径 自制图标http://jingyan.baidu.com/article/f79b7cb346cf499145023e78.html 预定义样式风格 primary 首选项 success 成功 info 一般信息 warning 警告 danger 危险 实例：登录框 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;div class&#x3D;&quot;containter&quot;&gt; &lt;br&gt; &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;默认样式&quot;&gt; &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;首选项&quot; class&#x3D;&quot;btn btn-primary&quot;&gt; &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;成功&quot; class&#x3D;&quot;btn btn-success&quot;&gt; &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;一般信息&quot; class&#x3D;&quot;btn btn-info&quot;&gt; &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;警告&quot; class&#x3D;&quot;btn btn-waring&quot;&gt; &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;危险&quot; class&#x3D;&quot;btn btn-danger&quot;&gt; &lt;br&gt; &lt;br&gt; &lt;p&gt;默认段落&lt;&#x2F;p&gt; &lt;p class&#x3D;&quot;bg-primary&quot;&gt;首选项&lt;&#x2F;p&gt; &lt;p class&#x3D;&quot;bg-success&quot;&gt;成功&lt;&#x2F;p&gt; &lt;p class&#x3D;&quot;bg-info&quot;&gt;一般信息&lt;&#x2F;p&gt; &lt;p class&#x3D;&quot;bg-warning&quot;&gt;警告&lt;&#x2F;p&gt; &lt;p class&#x3D;&quot;bg-danger&quot;&gt;危险&lt;&#x2F;p&gt; &lt;br&gt; &lt;span&gt;默认文字&lt;&#x2F;span&gt; &lt;span class&#x3D;&quot;text-primary&quot;&gt;首选项&lt;&#x2F;span&gt; &lt;span class&#x3D;&quot;text-success&quot;&gt;成功&lt;&#x2F;span&gt; &lt;span class&#x3D;&quot;text-info&quot;&gt;一般信息&lt;&#x2F;span&gt; &lt;span class&#x3D;&quot;text-warning&quot;&gt;警告&lt;&#x2F;span&gt; &lt;span class&#x3D;&quot;text-danger&quot;&gt;危险&lt;&#x2F;span&gt; &lt;br&gt; &lt;a href&#x3D;&quot;#&quot; class&#x3D;&quot;btn btn-primary&quot;&gt;链接1&lt;&#x2F;a&gt; &lt;a href&#x3D;&quot;#&quot; class&#x3D;&quot;bg-success&quot;&gt;链接2&lt;&#x2F;a&gt; &lt;a href&#x3D;&quot;#&quot; class&#x3D;&quot;text-danger&quot;&gt;链接3&lt;&#x2F;a&gt; &lt;br&gt; &lt;br&gt; &lt;div class&#x3D;&quot;alert alert-warning&quot;&gt;我是警告框&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;alert alert-danger&quot;&gt;我是危险信息&lt;&#x2F;div&gt; &lt;br&gt; &lt;div class&#x3D;&quot;panel panel-primary&quot;&gt; &lt;div class&#x3D;&quot;panel-heading&quot;&gt; &lt;h4&gt;我是面板的标题&lt;&#x2F;h4&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;panel-body&quot;&gt; 我是面板的主体内容！ &lt;&#x2F;div&gt; &lt;&#x2F;div&gt;&lt;&#x2F;div&gt; 123456789101112&lt;div class&#x3D;&quot;panel panel-primary&quot;&gt; &lt;div class&#x3D;&quot;panel-heading&quot;&gt; &lt;div class&#x3D;&quot;form-group&quot;&gt; &lt;label for&#x3D;&quot;&quot;&gt;用户名&lt;&#x2F;label&gt;&lt;input type&#x3D;&quot;text&quot; class&#x3D;&quot;form-control&quot;&gt; &lt;div class&#x3D;&quot;alert alert-warning&quot;&gt;用户名不能为空！&lt;&#x2F;div&gt; &lt;label for&#x3D;&quot;&quot;&gt;密码&lt;&#x2F;label&gt;&lt;input type&#x3D;&quot;password&quot; class&#x3D;&quot;form-control&quot;&gt; &lt;&#x2F;div&gt; &lt;a href&#x3D;&quot;#&quot; class&#x3D;&quot;text-primary&quot;&gt;忘记密码？&lt;&#x2F;a&gt; &lt;input type&#x3D;&quot;button&quot; class&#x3D;&quot;btn btn-primary pull-right&quot; value&#x3D;&quot;登录&quot;&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;panel-body&quot;&gt;&lt;&#x2F;div&gt;&lt;&#x2F;div&gt; 按钮 基类 btn 样式 btn-default 默认 btn-link 链接 大小 btn-*[lg,sm,xs] 状态 active disabled 种类 a, input, button 块级 btn-block 按钮组 btn-group btn-group-justified btn-group-vertical-实例：GitHub按钮组 下拉菜单 属性 data- aria- role open dropdown-menu-right dropdown-header divider 例子：运动且带图标的菜单 标签页 头部 nav nav-tabs nav-justified nav-tabs-justified nav-pills nav-stacked 带下拉菜单的头部 内容 tab-content tab-pane data-toggle=”tab” href对应id 淡入淡出方式 鼠标移入方式 带下拉菜单的切换 导航条 navbar navbar-default nav navbar-nav navbar-inverse navbar-static-top navbar-fixed-top navbar-fixed-bottom 遮挡内容的问题 navbar-header navbar-brand navbar-left navbar-right navbar-btn navbar-link navbar-text navbar-form 例子：知乎导航条 下拉菜单 响应式导航条navbar-toggle collapse navbar-collapse 滚动监听data-spy data-target data-offset 引用参考：https://study.miaov.com/v_show/59]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>前端</tag>
        <tag>bootstrap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SVG学习(8)]]></title>
    <url>%2FSVG%E5%AD%A6%E4%B9%A0(8).html</url>
    <content type="text"><![CDATA[哪些属性适合做动画只要补引起页面布局改变的属性都不会太影响性能例如：opacity autoprefixer库 自动添加需要前缀的属性前缀]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>svg</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>svg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SVG学习(7)]]></title>
    <url>%2FSVG%E5%AD%A6%E4%B9%A0(7).html</url>
    <content type="text"><![CDATA[SVG动画动画原理SMIL for SVG 参考资料http://www.w3.org/TR/SVG/animate.htmlhttp://www.zhangxinxu.com/wordpress/?p=4333 动画标签&lt;animate&gt;、&lt;animateTransform&gt;、&lt;animateMotion&gt;… 动画元素、属性定位以及动画参数设置attributeName、attributeTypefrom、to、dur、repeatCount、fill…calcMode… 定位动画目标 Internal Resource Identifier定位 1&lt;animate xlink:href&#x3D;&quot;url(#rect1)&quot;&gt;&lt;&#x2F;animate&gt; 被包含在目标元素里 123&lt;rect x&#x3D;&quot;0&quot; ...&gt; &lt;animate&gt;&lt;&#x2F;animate&gt;&lt;&#x2F;rect&gt; 基本动画 设置要进行动画的属性以及变化范围、时间长度 1234567&lt;animate xlink:herf&#x3D;&quot;url(#rect1)&quot; attributeType&#x3D;&quot;XML&quot; attributeName&#x3D;&quot;x&quot; from&#x3D;&quot;10&quot; to&#x3D;&quot;110&quot; dur&#x3D;&quot;3s&quot;&gt;&lt;&#x2F;animate&gt; svg创建默认的大小为300*1501234567891011121314151617181920212223242526272829303132333435&lt;style&gt; html, body, svg&#123;margin: 0;padding: 0;width: 100%;height: 100%&#125;&lt;&#x2F;style&gt;&lt;svg&gt; &lt;rect x&#x3D;&quot;100&quot; y&#x3D;&quot;100&quot; width&#x3D;&quot;100&quot; height&#x3D;&quot;100&quot; fill&#x3D;&quot;red&quot;&gt; &lt;animate id&#x3D;&quot;goright&quot; attributeType&#x3D;&quot;XML&quot; attributeName&#x3D;&quot;x&quot; begin&#x3D;&quot;0; goleft.end + 1s&quot; from&#x3D;&quot;100&quot; to&#x3D;&quot;500&quot; dur&#x3D;&quot;3s&quot; fill&#x3D;&quot;freeze&quot; repeatCount&#x3D;&quot;indefinite&quot;&gt; &lt;&#x2F;animate&gt; &lt;animate id&#x3D;&quot;goleft&quot; attributeType&#x3D;&quot;XML&quot; attributeName&#x3D;&quot;x&quot; begin&#x3D;&quot;goright.end + 1s&quot; from&#x3D;&quot;500&quot; to&#x3D;&quot;100&quot; dur&#x3D;&quot;3s&quot; fill&#x3D;&quot;freeze&quot; repeatCount&#x3D;&quot;indefinite&quot;&gt; &lt;&#x2F;animate&gt; &lt;animate attributeType&#x3D;&quot;XML&quot; attributeName&#x3D;&quot;fill&quot; from&#x3D;&quot;red&quot; to&#x3D;&quot;yello&quot; dur&#x3D;&quot;6s&quot; fill&#x3D;&quot;freeze&quot;&gt; &lt;&#x2F;animate&gt; &lt;&#x2F;rect&gt;&lt;&#x2F;svg&gt; 变换动画 设置要进行动画的属性以及变化范围、时间长度 123456&lt;animateTransform xlink:href&#x3D;&quot;url(#rect1)&quot; type&#x3D;&quot;translate&quot; from&#x3D;&quot;0 0&quot; to&#x3D;&quot;100 100&quot; dur&#x3D;&quot;3s&quot;&gt;&lt;&#x2F;animateTransform&gt; 1234567891011121314151617&lt;style&gt; html, body, svg&#123;margin: 0;padding: 0;width: 100%;height: 100%&#125;&lt;&#x2F;style&gt;&lt;svg viewBox&#x3D;&quot;-400 -400 800 800&quot;&gt; &lt;rect x&#x3D;&quot;0&quot; y&#x3D;&quot;0&quot; width&#x3D;&quot;100&quot; height&#x3D;&quot;100&quot; fill&#x3D;&quot;red&quot;&gt; &lt;animateTransform id&#x3D;&quot;rotate&quot; attributeType&#x3D;&quot;XML&quot; attributeName&#x3D;&quot;transform&quot; type&#x3D;&quot;rotate&quot; from&#x3D;&quot;0&quot; to&#x3D;&quot;360&quot; dur&#x3D;&quot;3s&quot; fill&#x3D;&quot;freeze&quot; repeatCount&#x3D;&quot;indefinite&quot;&gt; &lt;&#x2F;animateTransform&gt; &lt;&#x2F;rect&gt;&lt;&#x2F;svg&gt; 示例：点击查看 轨迹移动 设置轨迹路径 12345&lt;animateMotion xlink:href&#x3D;&quot;url(#rect1)&quot; path&#x3D;&quot;M0,0h100v100h-100v-100z&quot; rotate&#x3D;&quot;auto&quot; dur&#x3D;&quot;3s&quot;&gt;&lt;&#x2F;animateMotion&gt; 123456789101112131415&lt;svg viewBox&#x3D;&quot;-400 -400 800 800&quot;&gt; &lt;rect x&#x3D;&quot;-25&quot; y&#x3D;&quot;-25&quot; width&#x3D;&quot;50&quot; height&#x3D;&quot;50&quot; fill&#x3D;&quot;rgba(0, 255, 255, .6)&quot;&gt; &lt;animateMotion path&#x3D;&quot;M 0 0L 100 100A 200 200 0 1 0 0 -100&quot; dur&#x3D;&quot;3s&quot; rotate&#x3D;&quot;auto&quot;&gt; &lt;&#x2F;animateMotion&gt; &lt;&#x2F;rect&gt; &lt;path id&#x3D;&quot;motion-path&quot; d&#x3D;&quot;M 0 0L 100 100A 200 200 0 1 0 0 -100&quot; stroke&#x3D;&quot;gray&quot; fill&#x3D;&quot;none&quot;&gt;&lt;&#x2F;path&gt;&lt;&#x2F;svg&gt;&lt;svg viewBox&#x3D;&quot;-400 -400 800 800&quot;&gt; &lt;rect x&#x3D;&quot;-25&quot; y&#x3D;&quot;-25&quot; width&#x3D;&quot;50&quot; height&#x3D;&quot;50&quot; fill&#x3D;&quot;rgba(0, 255, 255, .6)&quot;&gt; &lt;animateMotion dur&#x3D;&quot;3s&quot; rotate&#x3D;&quot;auto&quot;&gt; &lt;mpath xlink:href&#x3D;&quot;#motion-path&quot;&gt;&lt;&#x2F;mpath&gt; &lt;&#x2F;animateMotion&gt; &lt;&#x2F;rect&gt; &lt;path id&#x3D;&quot;motion-path&quot; d&#x3D;&quot;M 0 0L 100 100A 200 200 0 1 0 0 -100&quot; stroke&#x3D;&quot;gray&quot; fill&#x3D;&quot;none&quot;&gt;&lt;&#x2F;path&gt;&lt;&#x2F;svg&gt; 脚本动画Scripting Animation 核心思想requestAnimationFrame(update) 示例力导向图 弹簧模型 两个点之间:Fi = k · xi (假设弹性系数是一样的) 可以计算合:F = ∑Fi 加速度:a = F / m (可以假设每个点质量一样) 速度:v = v0 + a · Δt (Δt 为一帧的时间) 位移:s = s0 + v · Δt 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129&lt;style&gt; html, body, svg &#123;margin: 0;padding: 0;width: 100%;height: 100%;&#125;&lt;&#x2F;style&gt;&lt;svg viewBox&#x3D;&quot;-400 -400 800 800&quot;&gt; &lt;path id&#x3D;&quot;links&quot; fill&#x3D;&quot;none&quot; stroke&#x3D;&quot;gray&quot;&gt;&lt;&#x2F;path&gt;&lt;&#x2F;svg&gt;&lt;script&gt; &#x2F;&#x2F; vector.js (function() &#123; function Vector(x, y) &#123; this.x &#x3D; x || 0; this.y &#x3D; y || 0; &#125; Vector.prototype &#x3D; &#123; constructor: Vector, square: function() &#123; return this.x * this.x + this.y * this.y &#125;, length: function() &#123; return Math.sqrt(this.square()); &#125;, add: function(q) &#123; return new Vector(this.x + q.x, this.y + q.y); &#125;, minus: function(q) &#123; return new Vector(this.x - q.x, this.y - q.y); &#125;, multiply: function(scale) &#123; return new Vector(this.x * scale, this.y * scale); &#125;, normalize: function(length) &#123; if(length &#x3D;&#x3D;&#x3D; undefined) &#123; length &#x3D; 1; &#125; return this.multiply(length &#x2F; this.length()); &#125; &#125;; Vector.fromPoints &#x3D; function(p1, p2) &#123; return new Vector(p2.x - p1.x, p2.y - p1.y); &#125;; window.Vector &#x3D; Vector; &#125;)();&lt;&#x2F;script&gt;&lt;script&gt; var points &#x3D; &#39;a,b,c&#39;.split(&#39;,&#39;).map(function(name, index, arr) &#123; return &#123; name: name, color: &#39;hsl(&#39; + (360 * index &#x2F; arr.length) + &#39;, 100%, 60%)&#39; &#125;; &#125;); var relation &#x3D; 300; var svg &#x3D; document.querySelector(&#39;svg&#39;); var k &#x3D; 0.05; var Vector &#x3D; window.Vector; function random(min, max) &#123; return Math.round(min + (max - min) * Math.random()); &#125; points.forEach(function(point) &#123; var circle &#x3D; document.createElementNS(&#39;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&#39;, &#39;circle&#39;); var x &#x3D; random(-400, 400); var y &#x3D; random(-400, 400); circle.setAttribute(&#39;cx&#39;, x); circle.setAttribute(&#39;cy&#39;, y); circle.setAttribute(&#39;r&#39;, 10); circle.setAttribute(&#39;fill&#39;, point.color); svg.appendChild(circle); point.circle &#x3D; circle; point.s &#x3D; new Vector(x, y); point.v &#x3D; new Vector(); point.a &#x3D; new Vector(); &#125;); var lastFrameTime &#x3D; +new Date(); function update() &#123; var frameTime &#x3D; +new Date(); var t &#x3D; frameTime - lastFrameTime; t &#x2F;&#x3D; 100; &#x2F;&#x2F; 点位置更新 points.forEach(function(pa) &#123; var f &#x3D; new Vector(); &#x2F;&#x2F; 计算合力 points.forEach(function(pb) &#123; if (pa &#x3D;&#x3D; pb) return; var x &#x3D; Vector.fromPoints(pa.s, pb.s); var delta &#x3D; x.length() - relation; &#x2F;&#x2F; f &#x3D; k * x f &#x3D; f.add(x.normalize(delta * k)); &#125;); pa.a &#x3D; f; pa.v &#x3D; pa.v.add(pa.a.multiply(t)).multiply(0.98); pa.s &#x3D; pa.s.add(pa.v.multiply(t)); pa.circle.setAttribute(&#39;cx&#39;, pa.s.x); pa.circle.setAttribute(&#39;cy&#39;, pa.s.y); &#125;); &#x2F;&#x2F; 连线更新 var linkPath &#x3D; []; points.forEach(function(pa) &#123; var sa &#x3D; pa.s; points.forEach(function(pb) &#123; if (pa &#x3D;&#x3D; pb) return; var sb &#x3D; pb.s; linkPath &#x3D; linkPath.concat([ &#39;M&#39;, sa.x, sa.y, &#39;L&#39;, sb.x, sb.y ]); &#125;); &#125;); document.getElementById(&#39;links&#39;).setAttribute(&#39;d&#39;, linkPath.join(&#39; &#39;)); lastFrameTime &#x3D; frameTime; window.requestAnimationFrame(update); &#125; window.requestAnimationFrame(update);&lt;&#x2F;script&gt; 示例：点击查看 根据慕课网课程整理]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>svg</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>svg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SVG学习(6)]]></title>
    <url>%2FSVG%E5%AD%A6%E4%B9%A0(6).html</url>
    <content type="text"><![CDATA[图形的引用、裁切和蒙版&lt;use&gt;标签创建图形引用例子：满天星星 &lt;clip&gt;标签裁切图形例子：绘制灯塔的光线 &lt;mask&gt;标签创建蒙版例子：绘制月牙及湖面倒影 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293&lt;style&gt; html,body&#123;margin: 0;padding: 0;width: 100%;height: 100%;background: #012;line-height: 0;font-size: 0;&#125;&lt;&#x2F;style&gt;&lt;svg width&#x3D;&quot;100%&quot; height&#x3D;&quot;100%&quot; viewBox&#x3D;&quot;-400 -300 800 600&quot; preserveAspectRatio&#x3D;&quot;xMidYMid slice&quot;&gt; &lt;defs&gt; &lt;polygon id&#x3D;&quot;star&quot; points&#x3D;&quot;0 -10 2 -2 10 0 2 2 0 10 -2 2 -10 0 -2 -2&quot; fill&#x3D;&quot;white&quot;&gt;&lt;&#x2F;polygon&gt; &lt;&#x2F;defs&gt; &lt;g id&#x3D;&quot;real&quot;&gt; &lt;g id&#x3D;&quot;star-group&quot;&gt;&lt;&#x2F;g&gt; &lt;g id&#x3D;&quot;moon-group&quot;&gt; &lt;mask id&#x3D;&quot;moon-mask&quot;&gt; &lt;circle cx&#x3D;&quot;-250&quot; cy&#x3D;&quot;-150&quot; r&#x3D;&quot;100&quot; fill&#x3D;&quot;white&quot;&gt;&lt;&#x2F;circle&gt; &lt;circle cx&#x3D;&quot;-200&quot; cy&#x3D;&quot;-200&quot; r&#x3D;&quot;100&quot; fill&#x3D;&quot;black&quot;&gt;&lt;&#x2F;circle&gt; &lt;&#x2F;mask&gt; &lt;circle cx&#x3D;&quot;-250&quot; cy&#x3D;&quot;-150&quot; r&#x3D;&quot;100&quot; fill&#x3D;&quot;yellow&quot; mask&#x3D;&quot;url(#moon-mask)&quot;&gt;&lt;&#x2F;circle&gt; &lt;&#x2F;g&gt; &lt;g id&#x3D;&quot;light-tower&quot; transform&#x3D;&quot;translate(250, 0)&quot;&gt; &lt;defs&gt; &lt;linearGradient id&#x3D;&quot;tower&quot; x1&#x3D;&quot;0&quot; y1&#x3D;&quot;0&quot; x2&#x3D;&quot;1&quot; y2&#x3D;&quot;0&quot;&gt; &lt;stop offset&#x3D;&quot;0&quot; stop-color&#x3D;&quot;#999&quot;&gt;&lt;&#x2F;stop&gt; &lt;stop offset&#x3D;&quot;1&quot; stop-color&#x3D;&quot;#333&quot;&gt;&lt;&#x2F;stop&gt; &lt;&#x2F;linearGradient&gt; &lt;radialGradient id&#x3D;&quot;light&quot; cx&#x3D;&quot;0.5&quot; cy&#x3D;&quot;0.5&quot; r&#x3D;&quot;0.5&quot;&gt; &lt;stop offset&#x3D;&quot;0&quot; stop-color&#x3D;&quot;rgba(255,255,255,.8)&quot;&gt;&lt;&#x2F;stop&gt; &lt;stop offset&#x3D;&quot;1&quot; stop-color&#x3D;&quot;rgba(255,255,255,0)&quot;&gt;&lt;&#x2F;stop&gt; &lt;&#x2F;radialGradient&gt; &lt;clipPath id&#x3D;&quot;light-clip&quot;&gt; &lt;polygon points&#x3D;&quot;0 0 -400 -15 -400 15&quot; fill&#x3D;&quot;rgba(255,0,0,.5)&quot;&gt; &lt;animateTransform attributeName&#x3D;&quot;transform&quot; attributeType&#x3D;&quot;XML&quot; type&#x3D;&quot;rotate&quot; from&#x3D;&quot;0&quot; to&#x3D;&quot;360&quot; dur&#x3D;&quot;10s&quot; repeatCount&#x3D;&quot;indefinite&quot; &gt;&lt;&#x2F;animateTransform&gt; &lt;&#x2F;polygon&gt; &lt;circle cx&#x3D;&quot;0&quot; cy&#x3D;&quot;0&quot; r&#x3D;&quot;2&quot;&gt;&lt;&#x2F;circle&gt; &lt;&#x2F;clipPath&gt; &lt;&#x2F;defs&gt; &lt;polygon points&#x3D;&quot;0 0 5 50 -5 50&quot; fill&#x3D;&quot;url(#tower)&quot;&gt;&lt;&#x2F;polygon&gt; &lt;ellipse cx&#x3D;&quot;0&quot; cy&#x3D;&quot;0&quot; rx&#x3D;&quot;300&quot; ry&#x3D;&quot;100&quot; fill&#x3D;&quot;url(#light)&quot; clip-path&#x3D;&quot;url(#light-clip)&quot;&gt;&lt;&#x2F;ellipse&gt; &lt;&#x2F;g&gt; &lt;&#x2F;g&gt; &lt;g id&#x3D;&quot;reflact&quot; transform&#x3D;&quot;translate(0 50)&quot; mask&#x3D;&quot;url(#fading)&quot;&gt; &lt;defs&gt; &lt;linearGradient id&#x3D;&quot;fade&quot; x1&#x3D;&quot;0&quot; y1&#x3D;&quot;0&quot; x2&#x3D;&quot;0&quot; y2&#x3D;&quot;1&quot;&gt; &lt;stop offset&#x3D;&quot;0&quot; stop-color&#x3D;&quot;rgba(255,255,255,.3)&quot;&gt;&lt;&#x2F;stop&gt; &lt;stop offset&#x3D;&quot;0.5&quot; stop-color&#x3D;&quot;rgba(255,255,255,0)&quot;&gt;&lt;&#x2F;stop&gt; &lt;&#x2F;linearGradient&gt; &lt;mask id&#x3D;&quot;fading&quot;&gt; &lt;rect x&#x3D;&quot;-400&quot; y&#x3D;&quot;0&quot; width&#x3D;&quot;800&quot; height&#x3D;&quot;300&quot; fill&#x3D;&quot;url(#fade)&quot;&gt;&lt;&#x2F;rect&gt; &lt;&#x2F;mask&gt; &lt;&#x2F;defs&gt; &lt;use xlink:href&#x3D;&quot;#real&quot; transform&#x3D;&quot;scale(1, -1) translate(0 -50)&quot; &#x2F;&gt; &lt;&#x2F;g&gt; &lt;line x1&#x3D;&quot;-400&quot; y1&#x3D;&quot;50&quot; x2&#x3D;&quot;400&quot; y2&#x3D;&quot;50&quot; stroke&#x3D;&quot;white&quot;&gt;&lt;&#x2F;line&gt;&lt;&#x2F;svg&gt;&lt;script&gt; var SVG_NS &#x3D; &#39;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&#39;; var XLINK_NS &#x3D; &#39;http:&#x2F;&#x2F;www.w3.org&#x2F;1999&#x2F;xlink&#39;; var paper &#x3D; document.querySelector(&#39;svg&#39;); renderStar(); function use(origin) &#123; var _use &#x3D; document.createElementNS(SVG_NS, &#39;use&#39;); _use.setAttributeNS(XLINK_NS, &#39;xlink:href&#39;, &#39;#&#39; + origin.id); return _use; &#125; function random(min, max) &#123; return min + (max - min) * Math.random(); &#125; function renderStar()&#123; var starRef &#x3D; document.getElementById(&#39;star&#39;); var starGroup &#x3D; document.getElementById(&#39;star-group&#39;); var starCount &#x3D; 500; var star; while (starCount--) &#123; star &#x3D; use(starRef); star.setAttribute(&#39;opacity&#39;, random(0.1, 0.4)); star.setAttribute(&#39;transform&#39;, &#39;translate(&#39; + random(-400, 400) + &#39;,&#39; + random(-300,50) + &#39;)&#39; + &#39;scale(&#39; + random(0.1, 0.6) + &#39;)&#39; ); starGroup.appendChild(star); &#125; &#125;&lt;&#x2F;script&gt; 示例：点击查看 总结 &lt;use&gt;xlink:href=”#id” &lt;clipPath&gt;clip-path=”url(#clip-id)” &lt;mask&gt;mask=”url(#mask-id)” 根据慕课网课程整理]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>svg</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>svg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SVG学习(5)]]></title>
    <url>%2FSVG%E5%AD%A6%E4%B9%A0(5).html</url>
    <content type="text"><![CDATA[SVG文本&lt;text&gt;和&lt;tspan&gt;创建文本 x和y属性 - 定位标准 dx和dy属性 - 字形偏移 style属性 - 设置样式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;svg xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&quot; width&#x3D;&quot;100%&quot; height&#x3D;&quot;100%&quot;&gt; &lt;defs&gt; &lt;pattern id&#x3D;&quot;grid&quot; x&#x3D;&quot;0&quot; y&#x3D;&quot;0&quot; width&#x3D;&quot;20&quot; height&#x3D;&quot;20&quot; patternUnits&#x3D;&quot;userSpaceOnUse&quot;&gt; &lt;path stroke&#x3D;&quot;#F0F0F0&quot; fill&#x3D;&quot;none&quot; d&#x3D;&quot;M0,0H20V20&quot;&gt;&lt;&#x2F;path&gt; &lt;&#x2F;pattern&gt; &lt;&#x2F;defs&gt; &lt;rect width&#x3D;&quot;1200&quot; height&#x3D;&quot;1000&quot; fill&#x3D;&quot;url(#grid)&quot;&gt;&lt;&#x2F;rect&gt; &lt;text id&#x3D;&quot;sintext&quot; x&#x3D;&quot;100&quot; y&#x3D;&quot;150&quot;&gt;&lt;&#x2F;text&gt; &lt;text x&#x3D;&quot;100&quot; y&#x3D;&quot;150&quot;&gt; &lt;tspan fill&#x3D;&quot;red&quot; dy&#x3D;&quot;-20 20&quot;&gt;AB&lt;&#x2F;tspan&gt; &lt;tspan stroke&#x3D;&quot;green&quot; fill&#x3D;&quot;none&quot; dy&#x3D;&quot;-40 20&quot;&gt;CDE&lt;&#x2F;tspan&gt; &lt;&#x2F;text&gt; &lt;path d&#x3D;&quot;M100,0V200M0,100H200&quot; stroke&#x3D;&quot;red&quot; fill&#x3D;&quot;none&quot;&gt;&lt;&#x2F;path&gt;&lt;&#x2F;svg&gt;&lt;script&gt; &#x2F;&#x2F; y &#x3D; s * sin(w * x + t) &#x2F;&#x2F; x &#x3D; [20, 20, 20...] var NS &#x3D; &#39;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&#39;; var text &#x3D; &#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;; var n &#x3D; text.length; var x &#x3D; []; var y &#x3D; null; var i &#x3D; n; var s &#x3D; 100; var w &#x3D; 0.02; var t &#x3D; 0; while(i--) &#123; x.push(10); var tspan &#x3D; document.createElementNS(NS, &#39;tspan&#39;); tspan.textContent &#x3D; text[n - i - 1]; sintext.appendChild(tspan); var h &#x3D; Math.round(360 &#x2F; 26 * i); tspan.setAttribute(&#39;fill&#39;, &#39;hsl(&#39; + h + &#39;, 100%, 80%)&#39;); &#125; function arrange(t)&#123; y &#x3D; []; var ly &#x3D; 0, cy; for(var i &#x3D; 0; i &lt; n; ++i)&#123; cy &#x3D; -s * Math.sin(w * i * 20 + t); y.push(cy - ly); ly &#x3D; cy; &#125; &#x2F;&#x2F; y &#x3D; x.map(function(x)&#123; &#x2F;&#x2F; return s * Math.sin(w * x + t); &#x2F;&#x2F; &#125;); &#125; function render()&#123; sintext.setAttribute(&quot;dx&quot;, x.join(&#39; &#39;)); sintext.setAttribute(&quot;dy&quot;, y.join(&#39; &#39;)); &#125; function frame()&#123; t +&#x3D; 0.01; arrange(t); render(); requestAnimationFrame(frame); &#125; frame();&lt;&#x2F;script&gt; &lt;tspan&gt;中dy是向下传递的text和tspan中同时设置dy时，text中的dy属性会被覆盖 垂直居中问题 text-anchor - 水平居中属性 dominant-baseline 属性(http://www.w3.org/TR/SVG/text.html#DomainantBaselineProperty) 自己模拟 模拟var box = text.getBBox(); 渲染的盒子顶线: box.y中线: box.y + box.height / 2底线: box.y + box.height文本基线: y &lt;textPath&gt; 让文本在指定路径上排列路径文本 使用方法 123456&lt;path id&#x3D;&quot;path1&quot; d&#x3D;&quot;M 100 200 Q 200 100 300 200 T 500 200&quot; stroke&#x3D;&quot;rgb(0,255,0)&quot; fill&#x3D;&quot;none&quot; &#x2F;&gt;&lt;text style&#x3D;&quot;font-size: 24px;&quot;&gt; &lt;textPath xlink:href&#x3D;&quot;#path1&quot;&gt; 这个文字先上去，又下来了。Upside down in english! &lt;&#x2F;textPath&gt;&lt;&#x2F;text&gt; 布局原理 渲染原理浏览器会把字符从字体表中查到这个字符要占的宽度charWidth，然后从路径最开始的位置找到了一个点，根据这个宽度，在这个路径经过多少长度之后找到另一个点，这两个点将作为计算的基点，通过这两个基点算出来一个点是这个点到这两个基点的位置在路径上的长度都是一样的，最终算出中间的点将会作一条切线以及法线，在这条法线上会把这个文字对齐到文字中央并且把文字的基线位置对齐到切线的位置，这样就完成了第一个文字的排列。上一个文字排列的时候算出来的三个点中的最后一个点会作为下一次计算的开始的点。 定位属性 x,y,dx,dy的作用 x、text-anchor和startOffset属性 - 确定排列起始位置 dx、dy属性 - 切线和法线方向的偏移 12345678910&lt;path id&#x3D;&quot;path1&quot; d&#x3D;&quot;M 100 200 Q 200 100 300 200 T 500 200&quot; stroke&#x3D;&quot;rgb(0,255,0)&quot; fill&#x3D;&quot;none&quot; &#x2F;&gt;&lt;text style&#x3D;&quot;font-size: 24px;&quot;&gt; &lt;textPath xlink:href&#x3D;&quot;#path1&quot;&gt; &lt;tspan&gt;这个文字先&lt;&#x2F;tspan&gt; &lt;tspan fill&#x3D;&quot;blue&quot; dy&#x3D;&quot;-30&quot;&gt;上去&lt;&#x2F;tspan&gt; &lt;tspan dy&#x3D;&quot;30&quot;&gt;，又&lt;&#x2F;tspan&gt; &lt;tspan fill&#x3D;&quot;red&quot; dy&#x3D;&quot;30&quot;&gt;下来&lt;&#x2F;tspan&gt; &lt;tspan dy&#x3D;&quot;-30&quot;&gt;了。Upside down in english!&lt;&#x2F;tspan&gt; &lt;&#x2F;textPath&gt;&lt;&#x2F;text&gt; 示例：点击查看 脚本控制 setAttributeNS()方法设置xlink:href属性 把文本节点替换为节点 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;form&gt; &lt;label&gt;Path:&lt;&#x2F;label&gt; &lt;select id&#x3D;&quot;text-path-select&quot;&gt; &lt;option value&#x3D;&quot;none&quot;&gt;none&lt;&#x2F;option&gt; &lt;option value&#x3D;&quot;#path1&quot;&gt;path1&lt;&#x2F;option&gt; &lt;option value&#x3D;&quot;#path2&quot;&gt;path2&lt;&#x2F;option&gt; &lt;option value&#x3D;&quot;#path3&quot;&gt;path3&lt;&#x2F;option&gt; &lt;&#x2F;select&gt;&lt;&#x2F;form&gt;&lt;svg xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&quot; width&#x3D;&quot;800&quot; height&#x3D;&quot;600&quot;&gt; &lt;path id&#x3D;&quot;path1&quot; d&#x3D;&quot;M 100 200 Q 200 100 300 200 T 500 200&quot; stroke&#x3D;&quot;rgb(0,255,0)&quot; fill&#x3D;&quot;none&quot; &#x2F;&gt; &lt;path id&#x3D;&quot;path2&quot; d&#x3D;&quot;M100,300l100-50,200,100,100,-50&quot; stroke&#x3D;&quot;rgb(255,0,0)&quot; fill&#x3D;&quot;none&quot; &#x2F;&gt; &lt;path id&#x3D;&quot;path3&quot; d&#x3D;&quot;M100,400A400,300,0,0,0,500,400&quot; stroke&#x3D;&quot;blue&quot; fill&#x3D;&quot;none&quot; &#x2F;&gt; &lt;text id&#x3D;&quot;text&quot; x&#x3D;&quot;100&quot; y&#x3D;&quot;100&quot; style&#x3D;&quot;font-size: 20px;&quot;&gt; Text path scripting.&lt;tspan id&#x3D;&quot;tspan&quot;&gt;动态使用路径文本&lt;&#x2F;tspan&gt; &lt;&#x2F;text&gt;&lt;&#x2F;svg&gt;&lt;script&gt; var SVG_NS &#x3D; &#39;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&#39;; var XLINK_NS &#x3D; &#39;http:&#x2F;&#x2F;www.w3.org&#x2F;1999&#x2F;xlink&#39;; var select &#x3D; document.getElementById(&#39;text-path-select&#39;); var text &#x3D; document.getElementById(&#39;text&#39;); var tspan &#x3D; document.getElementById(&#39;tspan&#39;); function addTextPath() &#123; var textPath &#x3D; document.createElementNS(SVG_NS, &#39;textPath&#39;); while (text.firstChild) &#123; textPath.appendChild(text.firstChild); &#125; text.appendChild(textPath); &#125; function setTextPath(path) &#123; var textPath &#x3D; text.firstChild; textPath.setAttributeNS(XLINK_NS, &#39;xlink:href&#39;, path); var pathElement &#x3D; document.querySelector(path); tspan.setAttribute(&#39;fill&#39;, pathElement.getAttribute(&#39;stroke&#39;)); &#125; function removeTextPath() &#123; var textPath &#x3D; text.firstChild; while (textPath.firstChild) &#123; text.appendChild(textPath.firstChild); &#125; text.removeChild(textPath); tspan.removeAttribute(&#39;fill&#39;); &#125; select.addEventListener(&#39;input&#39;, function() &#123; var value &#x3D; select.value; if (text.firstChild.tagName &amp;&amp; text.firstChild.tagName.toLowerCase() &#x3D;&#x3D; &#39;textpath&#39;) &#123; if (value &#x3D;&#x3D; &#39;none&#39;) &#123; removeTextPath(); &#125; else &#123; removeTextPath(); addTextPath(); setTextPath(value); &#125; &#125; else &#123; if (value !&#x3D; &#39;none&#39;) &#123; addTextPath(); setTextPath(value); &#125; &#125; &#125;);&lt;&#x2F;script&gt; 示例：点击查看 &lt;a&gt;插入超链接 可以添加到任意的图形上 xlink:href 指定链接地址 xlink:title 指定链接提示 target 指定打开目标 1234567891011121314&lt;svg xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&quot; width&#x3D;&quot;800&quot; height&#x3D;&quot;600&quot;&gt; &lt;a xlink:href&#x3D;&quot;http:&#x2F;&#x2F;baike.baidu.com&#x2F;search&#x2F;word?word&#x3D;正方形&quot; xlink:title&#x3D;&quot;正方形&quot; target&#x3D;&quot;_blank&quot;&gt; &lt;rect x&#x3D;&quot;100&quot; y&#x3D;&quot;100&quot; width&#x3D;&quot;100&quot; height&#x3D;&quot;100&quot; fill&#x3D;&quot;rgba(255,0,0,.5)&quot; stroke&#x3D;&quot;rgb(200,0,0)&quot; stroke-width&#x3D;&quot;2&quot;&gt;&lt;&#x2F;rect&gt; &lt;&#x2F;a&gt; &lt;a xlink:href&#x3D;&quot;http:&#x2F;&#x2F;baike.baidu.com&#x2F;search&#x2F;word?word&#x3D;圆形&quot; xlink:title&#x3D;&quot;圆形&quot; target&#x3D;&quot;_blank&quot;&gt; &lt;circle cx&#x3D;&quot;300&quot; cy&#x3D;&quot;150&quot; r&#x3D;&quot;50&quot; fill&#x3D;&quot;rgba(0,255,0,.5)&quot; stroke&#x3D;&quot;rgb(200,0,0)&quot; stroke-width&#x3D;&quot;2&quot;&gt;&lt;&#x2F;circle&gt; &lt;&#x2F;a&gt; &lt;a xlink:href&#x3D;&quot;http:&#x2F;&#x2F;baike.baidu.com&#x2F;search&#x2F;word?word&#x3D;三角形&quot; xlink:title&#x3D;&quot;三角形&quot; target&#x3D;&quot;_blank&quot;&gt; &lt;polygon points&#x3D;&quot;150 250 200 350 100 350&quot; fill&#x3D;&quot;rgba(0,0,255,.5)&quot; stroke&#x3D;&quot;rgb(200,0,0)&quot; stroke-width&#x3D;&quot;2&quot;&gt;&lt;&#x2F;polygon&gt; &lt;&#x2F;a&gt; &lt;a xlink:href&#x3D;&quot;http:&#x2F;&#x2F;baike.baidu.com&#x2F;search&#x2F;word?word&#x3D;平行四边形&quot; xlink:title&#x3D;&quot;平行四边形&quot; target&#x3D;&quot;_blank&quot;&gt; &lt;polygon points&#x3D;&quot;300 250 350 250 300 350 250 350&quot; fill&#x3D;&quot;rgba(255,255,0,.5)&quot; stroke&#x3D;&quot;rgb(200,0,0)&quot; stroke-width&#x3D;&quot;2&quot;&gt;&lt;&#x2F;polygon&gt; &lt;&#x2F;a&gt;&lt;&#x2F;svg&gt; 示例：点击查看 根据慕课网课程整理]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>svg</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>svg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SVG学习(4)]]></title>
    <url>%2FSVG%E5%AD%A6%E4%B9%A0(4).html</url>
    <content type="text"><![CDATA[PathPath概述 强大的绘图工具 规范:http://www.w3.org/TR/SVG11/paths.html 由命令及其参数组组成的字符串，如：&lt;path d=&quot;M0,0L10,20C30-10,40,20,100,100&quot; stroke=&quot;red&quot;&gt;tiger.svg Path字符串&lt;path d=&quot;M0,0L10,20C30-10,40,20,100,100&quot; stroke=&quot;red&quot;&gt;L(命令)10(参数),(参数之间可以用空格或逗号隔开，有一种情况例外，就是下一个字符是负数[负号可以表示上一参数的结束])20(参数) 命令汇总 命令 含义 M/m (x,y)+ 移动当前位置 L/l (x,y)+ 从当前位置绘制线段到指定位置 H/h (x)+ 从当前位置绘制水平线到达指定的x坐标 V/v (x)+ 从当前位置绘制竖直线到达指定的y坐标 Z/z 闭合当前路径 C/c (x1,y1,x2,y2,x,y)+ 从当前位置绘制三次贝塞尔曲线到指定位置 S/s (x2,y2,x,y)+ 从当前位置光滑绘制三次贝塞尔曲线到指定位置 Q/q (x1,y1,x,y)+ 从当前位置绘制二次贝塞尔曲线到指定位置 T/t (x,y)+ 从当前位置光滑绘制二次贝塞尔曲线到指定位置 A/a (rx,ry,xr,laf,sf,x,y) 从当前位置绘制弧线到指定位置 命令基本规律 区分大小写：大写表示坐标参数为绝对值，小写则为相对位置（相对上一个命令结束后画笔停留的位置） 最后的参数表示最终要到达的位置 上一个命令结束的位置就是下一个命令开始的位置 命令可以重复参数表示重复执行同一条命令 移动和直线命令 M(x,y)+ 移动画笔，后面如果有重复参数，会当作是L命令处理 L(x,y)+ 绘制直线到指定位置 H(x)+ 绘制水平线到指定的x位置 V(y)+ 绘制竖直线到指定的y位置 m,l,h,v使用相对位置绘制 弧线命令 A(rx,ry,xr,laf,sf,x,y) - 绘制弧线 最复杂的命令rx - (radius-x) 弧线所在椭圆的x半轴长ry - (radius-y) 弧线所在椭圆的y半轴长xr - (xAxis-rotation) 弧线所在椭圆的长轴角度laf - (large-arc-flag) 是否选择弧长较长的那一段弧 laf=0 弧长较短的那段 laf=1 弧长较长的那段sf - (sweep-flag) 是否选择逆时针方向的那一段弧 sf=0 逆时针 sf=1 顺时针x,y - 弧的终点位置 贝塞尔曲线命令 贝塞尔曲线概念 四条贝塞尔曲线的命令 贝塞尔曲线P0 P1 t=0 二次贝塞尔曲线命令起始点 结束点 控制点 控制线P0 P1 P2 t=0P0(x0,y0)起始点 C1(x1,y1)控制点 P(x,y)结束点M x0 y0 Q x1 y1 x y Q是quadratic的第一个字母起始点的位置是path的当前位置，可以通过move或者直线或者弧线命令修改到当前的位置，Q后跟的是控制点的坐标以及结束点的坐标，由于二次贝塞尔曲线之需要一个控制点所以Q的命令有四个参数，分别是控制点坐标和结束位置坐标 三次贝塞尔曲线命令起始点 结束点 控制点 控制线P0 P1 P2 P3 t=0P0(x0,y0)起始点 C1(x1,y1)控制点 C2(x2,y2)控制点 P(x,y)结束点M x0 y0 Q x1 y1 x2 y2 x y 四次贝塞尔曲线命令起始点 结束点 控制点 控制线P0 P1 P2 P3 P4 t=0 贝塞尔曲线通项公式 光滑曲线 T:Q的光滑版本（二次贝塞尔曲线）C1是上一段曲线的控制点关于当前曲线起始点的镜像位置 S:C的简化版本（三次贝塞尔曲线，第一个控制点的位置可以省略）C1是上一段曲线的控制点2关于当前曲线起始点的镜像位置 M100,200 C100,100 250,100 250,200 S400,300 400,200 回顾思考 Path命令的作用是什么，Path字符串的格式是什么 一共有多少个Path命令，它们分别的参数是什么 如何求贝塞尔曲线的长度，如何求整个Path的长度 如何求一个Path的子路径 如何求两个Path的补间 Raphael 矢量图形库 根据慕课网课程整理]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>svg</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>svg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SVG学习(3)]]></title>
    <url>%2FSVG%E5%AD%A6%E4%B9%A0(3).html</url>
    <content type="text"><![CDATA[颜色、渐变和画刷认识RGB和HSL都是css3支持的颜色表示方法互相转换的原理 RGB 红色、绿色、蓝色三个分量 表示方式：rgb(r,g,b)或#rrggbb 每个分量取值范围:[0,255] 优势：显示器容易解析 劣势：不符合人类描述颜色的习惯 R(255,0,0) redG(0,255,0) greenB(0,0,255) blue rgb(214,32,0)–亮一点–&gt;rgb(255,103,77)–淡一点–&gt;rgb(234,118,97)–偏黄一点–&gt;rgb(234,157,97)使用rgb修改颜色很困难，很难把直观的修改变成三个分量的修改，这种情况建议使用HSL表示颜色 HSL 三个分量分别表示颜色、饱和度和亮度 格式：hsl(h,s%,l%) 取值范围h:[0,359]s,l:[0,100] 优势：符合人类描述颜色的习惯H:表示颜色在色环上的度数S:表示色彩饱和度，100%的时候完全饱和，此时颜色最鲜艳，0%的时候完全不饱和，此时颜色是灰度的L:表示亮度，即明暗程度，0%的时候是暗的，此时为黑色，100%的时候是亮的，此时为白色 hsl(9,100%,42%)–亮一点–&gt;hsl(9,100%,65%)–淡一点–&gt;hsl(9,77%,65%)–偏黄一点–&gt;hsl(26,77%,65%)对于需要调色的场景，每次只需要修改一个分量 应用示例：http://paletton.com/ 透明度 rgba(r,g,b,a)和hsla(h,s%,l%,a)表示带透明度的颜色 opacity属性表示元素的透明度 a和opacity的取值范围:[0,1] 在SVG中应用颜色12&lt;rect fill&#x3D;&quot;rgb(255,0,0)&quot; opacity&#x3D;&quot;0.5&quot; &#x2F;&gt;&lt;rect stroke&#x3D;&quot;hsla(0,50%,60%,0.5)&quot; &#x2F;&gt; 线性渐变和径向渐变渐变 让图形更丰满 线性渐变和径向渐变 线性渐变 &lt;linearGradient&gt;和&lt;stop&gt; 定义方向 关键点位置及颜色 grandientUnitsobjectBoundingBox 默认值，是以图形的包围的盒子描述的两个端点的坐标userSpaceOnUse 使用世界坐标系 线性渐变使用linearGradient标签来定义，渐变的方向由两个坐标的点来决定，这两个点所用的坐标系是由grandientUnits来选择的，默认情况下是基于图形的百分比来决定的坐标系，渐变上每个位置的颜色由stop标签来定的 12345678910&lt;svg xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&quot;&gt; &lt;defs&gt; &lt;linearGradient id&#x3D;&quot;grad1&quot; gradientUnits&#x3D;&quot;objectBoundingBox&quot; x1&#x3D;&quot;0&quot; y1&#x3D;&quot;0&quot; x2&#x3D;&quot;1&quot; y2&#x3D;&quot;1&quot;&gt; &lt;stop offset&#x3D;&quot;0&quot; stop-color&#x3D;&quot;#1497FC&quot; &#x2F;&gt; &lt;stop offset&#x3D;&quot;0.5&quot; stop-color&#x3D;&quot;#A469BE&quot; &#x2F;&gt; &lt;stop offset&#x3D;&quot;1&quot; stop-color&#x3D;&quot;#FF8C00&quot; &#x2F;&gt; &lt;&#x2F;linearGradient&gt; &lt;&#x2F;defs&gt; &lt;rect x&#x3D;&quot;100&quot; y&#x3D;&quot;100&quot; fill&#x3D;&quot;url(#grad1)&quot; width&#x3D;&quot;200&quot; height&#x3D;&quot;150&quot;&gt;&lt;&#x2F;rect&gt;&lt;&#x2F;svg&gt; 径向渐变 &lt;radialGraeient&gt;和&lt;stop&gt; 定义方向 关键点位置及颜色 gradientUnits 焦点位置需要多定义参数r,fx,fyfx,fy表示焦点位置 12345678910&lt;svg xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&quot;&gt; &lt;defs&gt; &lt;radialGradient id&#x3D;&quot;grad2&quot; gradientUnits&#x3D;&quot;objectBoundingBox&quot; cx&#x3D;&quot;0.5&quot; cy&#x3D;&quot;0.5&quot; r&#x3D;&quot;0.5&quot; fx&#x3D;&quot;0.6&quot; fy&#x3D;&quot;0.3&quot;&gt; &lt;stop offset&#x3D;&quot;0&quot; stop-color&#x3D;&quot;rgb(20,151,252)&quot; &#x2F;&gt; &lt;stop offset&#x3D;&quot;0.5&quot; stop-color&#x3D;&quot;rgb(164,105,190)&quot; &#x2F;&gt; &lt;stop offset&#x3D;&quot;1&quot; stop-color&#x3D;&quot;rgh(255,140,0)&quot; &#x2F;&gt; &lt;&#x2F;radialGradient&gt; &lt;&#x2F;defs&gt; &lt;rect x&#x3D;&quot;100&quot; y&#x3D;&quot;100&quot; width&#x3D;&quot;200&quot; height&#x3D;&quot;150&quot; fill&#x3D;&quot;url(#grad2)&quot;&gt;&lt;&#x2F;rect&gt;&lt;&#x2F;svg&gt; 使用笔刷 绘制纹理 &lt;pattern&gt;标签 patternUnits和patternContentUnitspatternUnits：objectBoundingBox 默认，基于绘制图形的包围盒的百分比patternUnits：userSpaceOnUse 世界坐标系patternContentUnits：userSpaceOnUse 默认，世界坐标系patternContentUnits：objectBoundingBox，内部元素的单位都是基于绘制图形的包围盒的百分比 123456789&lt;svg xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&quot;&gt; &lt;defs&gt; &lt;pattern id&#x3D;&quot;p1&quot; x&#x3D;&quot;0&quot; y&#x3D;&quot;0&quot; width&#x3D;&quot;0.2&quot; height&#x3D;&quot;0.2&quot;&gt; &lt;circle cx&#x3D;&quot;10&quot; cy&#x3D;&quot;10&quot; r&#x3D;&quot;5&quot; fill&#x3D;&quot;red&quot;&gt;&lt;&#x2F;circle&gt; &lt;polygen points&#x3D;&quot;30 10 60 50 0 50&quot; fill&#x3D;&quot;green&quot;&gt;&lt;&#x2F;polygen&gt; &lt;&#x2F;pattern&gt; &lt;&#x2F;defs&gt; &lt;rect x&#x3D;&quot;100&quot; y&#x3D;&quot;100&quot; width&#x3D;&quot;800&quot; height&#x3D;&quot;300&quot; fill&#x3D;&quot;url(#p1)&quot; stroke&#x3D;&quot;blue&quot;&gt;&lt;&#x2F;rect&gt;&lt;&#x2F;svg&gt; 根据慕课网课程整理]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>svg</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>svg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SVG学习(2)]]></title>
    <url>%2FSVG%E5%AD%A6%E4%B9%A0(2).html</url>
    <content type="text"><![CDATA[SVG中的坐标系统与坐标变换SVG的世界、视野、视窗的概念视野与世界 世界是无穷大的 视野是观察世界的一个矩形区域 viewbox width,height - 控制视窗 SVG代码 - 定义世界 viewBox,preserveAspectRatio - 控制视野 123456&lt;svg xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&quot; width&#x3D;&quot;800px&quot; height&#x3D;&quot;400px&quot; viewBox&#x3D;&quot;0 0 400 300&quot; preserveAspectRatio&#x3D;&quot;xMidYMid meet&quot;&gt; &lt;!--SVG content--&gt;&lt;&#x2F;svg&gt; 世界是客观的，视野是可以改变的，svg中提供了viewbox控制视野的范围&lt;svg&gt;标签中可以指定宽高属性，表示svg文件渲染的区域大小，也可以使用样式表定义，这个区域就是浏览器中的视窗视窗是指浏览器开辟的用来渲染svg内容的区域，是根据样式上下文来进行，可能改变；视野是svg文件的编写者定义的要以多大的视野来观察定义的世界，理想的情况下视野和世界尺寸相同，如果定义的视野和视窗的大小不一致，如何进行填充，用preserveAspectRatio属性进行指定 SVG中的图形分组 &lt;g&gt;标签来创建分组 (可以对分组进行整体操作) 属性继承 transform属性定义坐标变换 可以嵌套使用 1234567891011&lt;svg xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&quot; width&#x3D;&quot;300&quot; height&#x3D;&quot;200&quot;&gt; &lt;g stroke&#x3D;&quot;green&quot; fill&#x3D;&quot;none&quot; transform&#x3D;&quot;translate(150,0)&quot;&gt; &lt;rect x&#x3D;&quot;100&quot; y&#x3D;&quot;50&quot; width&#x3D;&quot;100&quot; height&#x3D;&quot;50&quot;&gt; &lt;&#x2F;rect&gt; &lt;rect x&#x3D;&quot;140&quot; y&#x3D;&quot;100&quot; width&#x3D;&quot;20&quot; height&#x3D;&quot;120&quot;&gt; &lt;&#x2F;rect&gt; &lt;&#x2F;g&gt; &lt;g&gt; &lt;polygon points&#x3D;&quot;100,10 40,180 190,60 10,60 160,180&quot; style&#x3D;&quot;fill:red;stroke:blue;stroke-width:3;fill-rule:evenodd;&quot;&gt; &lt;&#x2F;g&gt;&lt;&#x2F;svg&gt; 坐标系统概述 笛卡尔直角坐标系 原点 互相垂直的两条数轴 角度定义 坐标系统的作用是为图形提供一个基本的定位基准基于原点和数轴的定义又可以定义角度，数学上，x轴方向水平向右，y轴方向水平向上，角度的正方向是逆时针方向，由于svg的阅读媒介一般都是屏幕，出于对人的阅读习惯的考虑和大多数浏览器上其他动元素的坐标的习惯，svg使用的坐标系是y轴方向水平向下的，角度的正方向是顺时针的角度的正方向是笛卡尔坐标系中从x轴正方向到y轴正方向旋转的方向 四个坐标系用户坐标系（User Coordinate）世界的坐标系 viewBox视野大小就是观察用户坐标系中的区域，用户坐标系是最原始的坐标系，即svg标签的坐标系，其他的坐标系都是从用户坐标系产生的，也被称为原始坐标系 自身坐标系（Current Coordinate）每个图形元素或分组独立与生俱来 前驱坐标系（Previous Coordinate）父容器的坐标系 坐标变换就是前驱坐标系经过了元素变换之后得到的自身坐标系 123456789&lt;svg&gt; &lt;rect id&#x3D;&quot;a&quot; x&#x3D;&quot;0&quot; y&#x3D;&quot;0&quot; width&#x3D;&quot;100&quot; height&#x3D;&quot;50&quot; transform&#x3D;&quot;translate(50,50)&quot;&gt; &lt;&#x2F;rect&gt;&lt;&#x2F;svg&gt; 自身坐标系和前驱坐标系.例子 12345678&lt;svg id&#x3D;&quot;A&quot; xmlns&#x3D;&quot;...&quot;&gt; &lt;g id&#x3D;&quot;B&quot; transform&#x3D;&quot;translate(0,50)&quot;&gt; &lt;rect id&#x3D;&quot;C&quot; x&#x3D;&quot;100&quot; y&#x3D;&quot;50&quot; width&#x3D;&quot;100&quot; height&#x3D;&quot;50&quot;&gt; &lt;&#x2F;rect&gt; &lt;rect id&#x3D;&quot;D&quot; x&#x3D;&quot;140&quot; y&#x3D;&quot;100&quot; width&#x3D;&quot;20&quot; height&#x3D;&quot;120&quot;&gt; &lt;&#x2F;rect&gt; &lt;&#x2F;g&gt;&lt;&#x2F;svg&gt; 分别定义对应的坐标系OA、OB、OC、OD世界坐标系 OA #B的前驱坐标系 用户坐标系 OA #C和#D的图形定义是基于坐标系 OC和OD （所有的图形，关于它自身图形描述的属性都是基于它自己的自身坐标系来进行定义） #C和#D的前驱坐标系 OB分组#B的自身坐标系 OB分组#B上的transform属性表示分组#B的自身坐标系OB是从它的前驱坐标系OA经过transform变换来的OB、OC、OD坐标系重合了，因为OB是OC和OD的前驱坐标系，而#C和#D都没有定义transform属性，#C和#D的自身坐标系和前驱坐标系重合 参考坐标系（Reference Coordinate）使用其他坐标系来考究自身的情况下使用 坐标变换定义 数学上，坐标变换是采用一定的数学方法将一个坐标系的坐标变换为另一个坐标系的坐标的过程 SVG中，坐标变换是对一个坐标系到另一个坐标系的变换的描述 线性变换 线性变换方程X‘ = aX + cY + eY‘ = bX + dY + f 变换矩阵，记为M「a c eb d f0 0 1」 原坐标系中的每个点经过线性运算之后得到新坐标系中的每个点 平移「1 0 10 0 1 10 0 0 1」X’ = 1X + 0Y + 10 = X + 10Y’ = 0X + 1Y + 10 = Y + 10 旋转 使用极坐标求变换矩阵极坐标方程:X = rcos(α)Y = rsin(α)旋转θ度后:X’ = rcos(α+θ)Y’ = rsin(α+θ)展开:X’ = rcos(α)cos(θ) - rsin(α)sin(θ) = cos(θ)X - sin(θ)Y + 0Y’ = rcos(α)sin(θ) + rsin(α)cos(θ) = sin(θ)X + cos(θ)Y + 0「cos(30o) -sin(30o) 0sin(30o) cos(30o) 00 0 1」 缩放 a和c直观控制缩放「2 0 00 2 00 0 1」 线性变换列表 表示一系列的变换，结果为变换的矩阵的乘积M = Mn Mn-1 … M2 M1 * M0 后面的变换乘在前面「1 0 10 「cos(30o) -sin(30o) 00 1 10 sin(30o) cos(30o) 00 0 1」 0 0 1」Mtranslate Mrotate transform属性 前驱坐标系：父容器的坐标系 transform属性：定义前驱坐标系到自身坐标系到线性变换 语法：ratate()translate(,)scale(,)matrix(,,,,,) demoviewBox加0.5的偏移，之后的坐标是对齐到整数的话(画线?)会比较锐利 浏览器渲染svg的1像素偏差 根据慕课网课程整理]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>svg</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>svg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SVG学习(1)]]></title>
    <url>%2FSVG%E5%AD%A6%E4%B9%A0(1).html</url>
    <content type="text"><![CDATA[SVG入门SVG简介简介 使用XML描述的矢量文件位图：基于颜色的描述 bmp、png、jpg等矢量图：基于数学的描述 svg、ai等 W3C标准(1.1) https://www.w3.org/TR/SVG11/ 浏览器支持 https://caniuse.com/#search=svg 使用方式 1.浏览器直接打开 2.在HTML中使用&lt;img&gt;标签引用 3.直接在HTML中使用SVG标签 4.作为CSS背景 svg的基本图形和属性基本图形和属性 1.基本图形 1&lt;rect&gt; &lt;cricle&gt; &lt;ellipse&gt; &lt;line&gt; &lt;polyline&gt; &lt;polygon&gt; （曲线一般用&lt;path&gt;绘制，&lt;path&gt;可以绘制任意图形） &lt;rect&gt; 矩形x,y,width,height,rx,ryx,y 定义了坐标,矩形左上角的位置width,height 定义了宽高rx,ry 定义了圆角&lt;circle&gt; 圆形cx,cy,rcx,cy 圆心位置r 半径&lt;ellipse&gt; 椭圆形cx,cy,rx,rycx,cy 圆心坐标rx,ry 半径&lt;line&gt; 直线x1,y1,x2,y2描述两个点(x1,y1)，(x2,y2)&lt;polyline&gt; 折线points格式:(xi,yi)+描述多个点&lt;polygon&gt; 多边形points格式:(xi,yi)+描述多个点，会把最后一个点和第一个点连起来形成一个封闭的图形 2.基本属性fill、stroke、stroke-width、transform填充、描边和变换fill 填充颜色stroke 描边颜色stroke-width 描边粗细transform 变形，其坐标与其父坐标相对变换值 svg基本操作API 3.基本操作API 1234567&#x2F;&#x2F; 创建图形document.createElementNS(ns,tagName)&#x2F;&#x2F; 添加图形element.appendChild(childElement)&#x2F;&#x2F; 设置&#x2F;获取属性element.setAttribute(name,value)element.getAttribute(name) 综合例子：简单的svg编辑器根据慕课网课程整理]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>svg</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>svg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经典布局方案]]></title>
    <url>%2F%E7%BB%8F%E5%85%B8%E5%B8%83%E5%B1%80%E6%96%B9%E6%A1%88.html</url>
    <content type="text"><![CDATA[值得反复推敲的经典布局方案 1.上中下一栏式把页面分为上中下3块，上面是导航，中间是主要内容，下面是底部12345678910&lt;style&gt;body&#123;margin:0;&#125;.wrap&#123;width:900px; margin:0 auto;&#125;#header&#123;height:100px;background:#6cf;&#125;#main&#123;height:500px;background:#fcc;&#125;#footer&#123;height:80px;background:#9cf;&#125;&lt;&#x2F;style&gt;header#header.wrapsection#main.wrapfooter#footer.wrap 2.左右两栏式一般左边是子菜单或菜单栏，右边是主要的内容部分为了控制整体需要给两栏加一个共同的父级 a)混合浮动+普通流12345678&lt;style&gt;.wrap&#123;margin:0 auto;width:900px;&#125;#left&#123;width:200px;height:500px;background:#cff;float:left;&#125;#right&#123;height:500px;margin-left:200px;background:#fcc;&#125;&lt;&#x2F;style&gt;div.wrap aside#left section#right b)纯浮动式12345678&lt;style&gt;.wrap&#123;margin:0 auto;width:900px;overflow:hidden;&#125;&#x2F;*子级都浮动，父级需要清浮动*&#x2F;#left&#123;width:200px;height:500px;background:#cff;float:left;&#125;#right&#123;width:700px;height:500px;background:#fcc;float:left;&#125;&lt;&#x2F;style&gt;div.wrap aside#left section#right c)绝对定位方式12345678&lt;style&gt;.wrap&#123;margin:0 auto;width:900px;position:relative;&#125;&#x2F;*子级都浮动，父级需要清浮动 ||| 可以设置.wrap&#123;width:80%;&#125;宽度为百分比，使左边栏固定，右边栏自适应*&#x2F;#left&#123;width:200px;height:500px;background:#cff;position:absolute;top:0;left:0;&#125;#right&#123;width:700px;height:500px;background:#fcc;position:absolute;top:0;right:0;&#125;&lt;&#x2F;style&gt;div.wrap aside#left section#right 3.左右两栏加页眉页脚先写上下三栏，然后中间一栏再分为左右两栏，中间栏当成一个整体来处理12345678910111213&lt;style&gt;.wrap&#123;margin:0 auto;width:900px;&#125;#header&#123;height:100px;background:#6cf;&#125;#main&#123;height:500px;background:#fcc;&#125;#footer&#123;height:80px;background:#9cf;&#125;#left&#123;width:200px;height:100%;background:#cff;float:left;&#125;#right&#123;width:700px;height:100%;background:#fcc;float:left;&#125;&lt;&#x2F;style&gt;header#header.wrapsection#main.wrap aside#left section#rightfooter#footer.wrap 4.左中右三栏左右两栏固定，中间栏自适应布局时一般有个原则：凡是遇到多栏式布局，一般情况下都要给它们加上一个共同的父级。 圣杯布局 双飞翼布局 左右浮动，中间自适应 a)左右浮动，中间自适应这种布局方式左右两边的标签一定要放在中间标签的前面解释：因为前面两个元素都是浮动元素，浮动元素是不占用高度的(脱离文档流)，所以第三个元素可以到上面去，但是如果把中间的元素section放到上面的话，section会独占一行，写在section之后的浮动元素则不会和section在同一行，会掉到下一行去，所以section必须要放在最后写12345678910&lt;style&gt;.wrap&#123;margin:0 auto;width:80%;&#125; &#x2F;* 设置宽度为百分比，使中间栏自适应 *&#x2F;#left&#123;width:200px;height:500px;background:#cff;float:left;&#125;#rigth&#123;width:200px;height:500px;background:#cff;float:right;&#125;#main&#123;height:500px;margin:0 210px;background:#fcc;&#125;&lt;&#x2F;style&gt;div.wrap aside#left adise#right section#main b)左中右三栏之双飞翼来自淘宝UED团队这种布局方式中间的主要内容section要放在最前面,section中还需要加入一个元素div.content，中间的主要内容123456789101112&lt;style&gt;.wrap&#123;margin:0 auto;width:80%;&#125; &#x2F;* 设置宽度为百分比，使中间栏自适应 *&#x2F;#main&#123;width:100%;float:left; background:#fcc;&#125;#left&#123;width:200px;float:left;height:500px;background:#cff;margin-left:-100%;&#125;#right&#123;width:200px;float:left;height:500px;background:#cff;margin-left:-200px;&#125;.content&#123;height:500px;margin:0 200px;&#125;&lt;&#x2F;style&gt;div.wrap section#main div.content aside#left aside#right 5.左中右三栏加页眉页脚1234567891011121314151617&lt;style&gt;.wrap&#123;margin:0 auto;width:900px;&#125;#header&#123;height:100px;background:#6cf;&#125;#main&#123;height:500px;background:#fcc;&#125;#footer&#123;height:80px;background:#9cf;&#125;#middle&#123;width:100%;float:left;&#125; &#x2F;* 浮动元素的宽度默认由内容来撑开，如果不设置宽度，middle的宽度只能由内容撑开，没有内容的时候宽度是0，所以这个地方必须要设置width:100%; *&#x2F;#left&#123;width:200px;height:100%;background:#cff;float:left;margin-left:-100%;&#125;#right&#123;width:200px;height:100%;background:#cff;float:left;margin-left:-200px;&#125;.content&#123;height:500px;margin:0 200px;&#125;&lt;&#x2F;style&gt;header#header.wrapsection#main.wrap section#middle div.content aside#left aside#rightfooter#footer.wrap 练习DUX主题]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>前端</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(XHTML)Strict下的嵌套规则]]></title>
    <url>%2F(XHTML)Strict%E4%B8%8B%E7%9A%84%E5%B5%8C%E5%A5%97%E8%A7%84%E5%88%99.html</url>
    <content type="text"><![CDATA[下面是一份在 HTML 4 Strict 和 XHTML 1.0 Strict 下必须遵守的标签嵌套规则，比如你不能在&lt;a&gt;里面再嵌入一个&lt;a&gt;这样的约定。 说明： 为了方便读者阅读，本文中的标签使用了大写（根据 XHTML 的规则，元素名必须小写，比如&lt;html&gt;而不应是&lt;HTML&gt;） 小写的单词表明一组或一系列 HTML 标签 每一项条目（标签）后都跟随一组标签列表，如果没有这个列表，那么表明该条目（标签）内部不允许包含任何标签。这意味着该条目内部只能包含纯文本内容（#PCDATA，见下文）。如果注明 (empty)，这意味着该条目内部不允许包含任何形式的内容。对于 flow，inline，block，OBJECT 和BODY，其内部允许包含的内容在文中会单独给出。 #PCDATA 的意思是“parsed character data”，即纯文本内容（不包括任何 HTML 标签，但是转义内容可以存在，比如&amp;auml;和&amp;#228;） CDATA 的意思是“character data”，这意味着不包括转义内容的纯文本内容，详细内容可以参考CDATA Confusion excluding … 意即不得直接或者间接的包含所列的元素 HTML HEAD TITLE (required) SCRIPT, STYLE CDATABASE, META, LINK (empty)OBJECT (see content model below) BODY INS, DEL (special rules apply) flow block inlineSCRIPT CDATAblock P, H1, H2, H3, H4, H5, H6 inline #PCDATA TT, I, B, BIG, SMALL, EM, STRONG, DFN, CODE, SAMP, KBD, VAR, CITE, ABBR, ACRONYM, SUB, SUP, Q, SPAN, BDO inline A inline excluding an enclosed A element OBJECT PARAM (empty) flow IMG, BR (empty) SCRIPT CDATA MAP AREA (empty) block INPUT (empty) SELECT OPTGROUP OPTIONOPTION TEXTAREA LABEL LABEL excluding enclosed LABEL BUTTON flow excluding A, INPUT, SELECT, TEXTAREA, LABEL, BUTTON, FORM, FIELDSET UL, OL LI flow DL DT inlineDD flow PRE inline excluding IMG, OBJECT, BIG, SMALL, SUB, SUP DIV flow BLOCKQUOTE block SCRIPT CDATA NOSCRIPT flow FORM block excluding an enclosed FORM SCRIPT CDATA HR (empty) TABLE CAPTION inlineCOLGROUP COL (empty)COL (empty)THEAD, TBODY, TBODY TR TH, TD flow ADDRESS inline FIELDSET #PCDATA inline flow LEGEND inline 注1. 以上内容基于 [HTML 4.01 Specification] 的 Strict DTD 。JunChen 翻译自 Allowed nesting of elements in HTML 4 Strict (and XHTML 1.0 Strict) 注2. 对于XHTML1.0，基本上一致，不同点如下：对于&lt;script&gt;和&lt;style&gt;的内容，在 HTML 4 里是 CDATA 而在 XHTML 里是 #PCDATA 在 XHTML 中，&lt;table&gt;标签后可以紧跟一个&lt;tr&gt;，而在 HTML 4.01 里，不允许这样，不过&lt;tbody&gt;标签又是可以省略的。意思就是说，如果代码中的&lt;table&gt;后紧跟&lt;tr&gt;，对于 HTML 4.01，会隐性的生成一个&lt;tbody&gt;标签，而在 XHTML 里面就没有。这会影响到样式表使用 tbody 作为选择器。]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>标签嵌套规则</tag>
        <tag>规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html5高级]]></title>
    <url>%2Fhtml5%E9%AB%98%E7%BA%A7.html</url>
    <content type="text"><![CDATA[cssdisplay：inline-block 框内行 块元素的特征 1.在没有设置宽度时，默认充满一行 2.默认独占一行 3.支持所有css命令 内嵌（内联、行内）的特征 1.同排可以继续跟同类的标签 2.内容撑宽度 3.不支持宽高 4.不支持上下margin 5.代码换行被解析 inline-block特征 1.块在一行显示 2.行内属性标签支持宽高 3.没有宽度的时候内容撑开宽度 4.代码换行被解析（两个inline-block之间会有个空白间距）（问题） 5.ie6、ie7不支持块属性标签inline-block（问题） 发现好店练习要求1.考虑标签语义化，使用合适的标签2.标签特性的转换3.小竖线使用哪种方式进行编码(图片、边框、背景颜色、字符)4.文字的行高设置5.标签默认样式的处理(reset css) 1.合理应用标签，标签语义化2.样式的配合，标签特性的转换3.思考：模块之间的边框如何重合？ float文档流是文档中可显示对象在排列时所占用的位置。浮动：使文档脱离文档流，按照指定的方向发生移动，遇到父级边界或者相邻的浮动元素停了下来。 float的特征 1.块在一排显示 2.内联支持宽高 3.默认内容撑开宽度 4.脱离文档流 5.提升层级半层 清除浮动的方法 1.加高度问题：扩展性不好 2.给父级加浮动问题：页面中所有元素都加浮动，margin左右自动失效（floats bad！） 3.inline-block清除浮动问题：margin左右auto失效 4.空标签清除浮动问题：IE6最小高度19px；（解决后IE6下还有2px偏差） 5.br清浮动问题：不符合工作中：结构、样式、行为，三者分离的要求 6.after伪类清浮动法（现在主流方法）.clear:after&#123;content:&#39;&#39;;display:block;clear:both;&#125;.clear&#123;zoom:1;&#125;after伪类：元素内部末尾添加内容；:after{content:’添加的内容’;} IE6,7下不兼容zoom缩放a、触发IE下haslayout，使元素根据自身内容计算宽高；b、FF不支持。 IE6下还要添加.clear&#123;*zoom:1;&#125; BFC（block formatting context）标准浏览器 a、float的值不为none b、overflow的值不为visible c、display的值为table-cell，table-caption，inline-block中的任何一个 d、position的值不为relative和static e、width|height|min-width|min-height（！auto） haslayout IE浏览器 a、writing-mode:tb-rl b、-ms-writing-mode:tb-rl c、zoom:(!normal) overflow:hidden 清浮动方法 问题：需要配合宽度或者zoom兼容IE6IE7 overflow:scroll|auto|hidden; overflow:hidden;溢出隐藏 浮动练习1.必须用浮动布局（对浮动的知识点进行检验）2.必须清浮动3.结构、标签语义化4.思考：扩展性，以后维护起来更方便 定位 position相对定位的特征 a、不影响元素本身的特性 b、不使元素脱离文档流（元素移动之后原始位置会被保留） c、如果没有定位偏移量，对元素本身没有任何影响 d、提升层级 绝对定位的特征 a、使元素完全脱离文档流 b、使内嵌支持宽高 c、块属性标签内容撑开宽度 d、如果有定位父级相对于定位父级发生偏移，没有定位父级相对于document发生偏移 e、相对定位一般都是配合绝对定位元素使用 f、提升层级 fixed 固定定位z-index 层级定位透明度 标准不透明度 opacity:0~1; IE滤镜 filter:alpha(opacity=0~100);/*IE6、7下的透明度设置*/ 定位练习要求1.定位的使用2.层级的理解和应用3.导航练习，当hover的时候需要有变化4.相对定位和决定定位的配合使用5.透明度的配合使用 表格/表单表格标签 table 表格 thead 表格头 tbody 表格主体 tr 表格行 th 元素定义表头 td 元素定义表格单元 表格样式重置 table&#123;border-collapse;&#125;单元格间隙合并 th,td&#123;padding:0&#125;重置单元格默认填充 &lt;table border=&quot;1&quot;&gt;&lt;/table&gt;加属性border可以让表中的每个单元格都有一个边框，而设置table{border: 1px solid #000;}只有table外围有边框 单元格合并 colspan 横向 删除该行()多出的单元格 rowspan 纵向 删除每一行()多出的单元格 表单/表单元素form表单 &lt;input type=&quot;&quot; name=&quot;&quot; value=&quot;&quot; /&gt; text 文本框 password 密码 radio 单选 checkbox 复选 submit 提交 reset 重置 button 按钮 image 图片 file 上传 hidden 隐藏 label 标签为input元素定义标注12&lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;&quot; id&#x3D;&quot;a&quot; &#x2F;&gt;&lt;label for&#x3D;&quot;a&quot;&gt;&lt;&#x2F;label&gt; checked 在页面加载时默认选定的input元素&lt;input type=&quot;checkbox&quot; name=&quot;&quot; checked /&gt; disabled 属性规定应该禁用input元素&lt;input type=&quot;checkbox&quot; name=&quot;&quot; disabled /&gt; select/option下拉选框 对高度的支持不兼容； textarea 文本域 各个浏览器下的滚动条显示不兼容 css3新增resize调整尺寸属性 表格表单练习要求一、表格练习1.表头、表主体的划分2.单元格的合并3.思考：在同一个table标签里如何处理行之间的空隙二、表单练习1.表单与表单控件的配合使用2.单选可以使用图片，也可以直接使用表单的单选控件3.思考：布局结构如何做到一个统一化 兼容性css常见问题 H5标签兼容IE6不识别 如header section footer 解决方法：通过js去动态的创建标签，创建的标签为自定义标签，默认为内联元素，document.createElement(“header”);所以还需要给元素设置样式display:block;但是每个标签都自定义会比较麻烦，可以使用插件html5shiv.js兼容h5标签 元素浮动之后，能设置宽度的话就给元素加宽度。如果需要宽度是内容撑开，就给它里边的块元素加上浮动第一块元素浮动，第二块元素加margin值等于第一块元素，在IE6下会有间隙问题解决方案：1.不建议这么写 2.用浮动解决，第二块元素也用浮动而不是加margin IE6下子元素超出父级宽高，会把父级的宽高撑开解决方案：不要让子元素的宽高超过父级 p包含块元素嵌套规则p、td、h标签不要嵌套块元素，在chrome下会有问题，块元素会自动把这些标签分开自动结束 margin兼容性问题1.margin-top传递 解决方法：触发BFC、haslayout2.上下margin叠压 解决方法：尽量使用同一方向的margin，比如都设置top或者bottom display:inline-block解决方案:*display:inline;*zoom:1; IE6最小高度问题IE6下最小高度19像素；解决方案：overflow:hidden; IE6双边距当元素浮动后再设置margin就会产生双倍边距解决方案：针对IE6 7添加*display:inline; li里元素都浮动 li在IE6 7 下方会产生4px间隙问题解决方案：针对IE6 7 添加*vertical-align:top; 浮动元素之间注释，导致多复制一个文字问题两个浮动元素中间有注释或者内联元素并且和父级宽度相差不超过3px解决方案：1.两个浮动元素中间避免出现内联元素或注释 2.与父级宽度相差3px或以上 IE6 7父级元素的overflow:hidden 是包不住子级的relative解决方案：针对IE6 7 给父级元素添加相对定位 *position:relative; IE6下绝对定位元素父级宽高是奇数，绝对定位元素的right和bottom值会有1px的偏差解决方案：避免父级宽高出现奇数 IE6下绝对定位元素和浮动元素并列绝对定位元素消失解决方案：浮动元素和绝对定位元素是同级的话定位元素就会消失，所以只要让他们不处于同级就可以避免 IE6下input的空隙解决方案：给input元素添加*float:left; IE6下输入类型表单控件背景问题解决方案：设置background-attachment:fixed; css hackhack 黑客？ （原意：修改）针对不同的浏览器写不同css样式的过程，就叫css hack！\9 所有的IE10及之前版本的IE浏览器+* IE7及IE7以下版本的ie浏览器认识_ IE6及IE6以下版本的ie浏览器认识远离css hack PNG24兼容性问题IE6不支持png24图片解决方案： js插件（问题：不能处理body之上png24）1DD_belatedPNG.fix(&#39;xxx&#39;); 原生滤镜1_background-image:none;_filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src&#x3D;&#39;xx.png&#39;,sizingMethod&#x3D;&#39;crop&#39;); 样式优先级、提升样式优先级默认 &lt; 类型 &lt; class &lt; id &lt; style(行间) &lt; !important!important提升样式优先级权重 123456&lt;!–[if IE 6]&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;下载下来的JS路径&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt;DD_belatedPNG.fix(&#39;CSS选择器, 应用类型&#39;);&lt;&#x2F;script&gt;&lt;![endif]–&gt;]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>前端</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[公爵之吻]]></title>
    <url>%2F%E5%85%AC%E7%88%B5%E4%B9%8B%E5%90%BB.html</url>
    <content type="text"><![CDATA[文 / [日]江国香织 一边走，我一边泪如泉涌。一个已经二十一岁的女孩，还边走边哭，难免会招来他人疑惑的目光。可是我怎么也止不住我的泪水。 公爵死了。 我的公爵死了。我悲伤到了极点。 公爵是一条灰眼睛、奶油色的长毛狗，是一种名叫Pully的牧羊犬。刚到我们家的时候，它还是一只才呱呱坠地的小狗崽儿，在走廊里跑的时候，总是轻轻地伸开四条腿，用肚皮飞快地往前滑。那样子实在太可爱了，我一遍又一遍地唤着它的名字，让他在走廊里跑（我说它那样子简直就像拖把，大家不禁哄堂大笑起来。）蛋、冰激凌和梨，是公爵最喜欢吃的东西。或许是五月出生的缘故吧，公爵与初夏特别相配。当大地绽出一片嫩绿的时候带它出去散步，芬芳的风一吹，他身上的毛就会轻轻飘动，连眼睛都眯成了一条缝，发脾气时的侧脸酷似詹姆斯•汀。公爵喜欢音乐。我只要一弹钢琴，它就会蹲在一边听。还有，公爵特别会接吻。 公爵是老死的。我打完工回家里时，它的身子还是微热的，可是我把它的头搁在我的腿上抚摸的时候，不知什么时候就变硬了，冷了下来。公爵死了。 第二天，我还必须去打工。在门口，我奇怪地用明快的声音喊了一声“我走了”，可是在关上门的一刹那，我的泪水禁不住夺眶而出。哭啊，哭啊，边哭边往车站走，边哭边在检票口掏出了月票，边哭边站到了站台上，边哭边乘上了电车。电车上还像往日一样拥挤。我不住地抽噎，那些抱着书包的女学生，还有那些穿着几乎一模一样风衣的上班族的目光，毫不掩饰地在我的脸上扫来扫去。 “请。” 一个男孩冷淡地说了一声，把座位让给了我。看样子也就是十九岁左右吧，白色的T恤衫外面套了一件藏蓝色的毛衣，一个相当酷的少年。 “谢谢。” 我好不容易才用像蚊子一样的哭声谢了他一句，坐到了座位上。少年站在我的面前，一双幽深的眸子目不转睛地盯着我那张哭泣的脸。我在少年的视线下蜷缩成了一团，不知为什么竟动弹不了。接着，我不知不觉地停止了哭泣。 在我下车的那站，少年也下了车。我换电车，少年也换电车。我们一起一直坐到了终点站。怎么了？不要紧吧？连问也不问一句，少年只是一直待在我的身边，在拥挤不堪的满员电车里若无其事地守护着我。渐渐地，我的心平静下来了。 “我请你喝咖啡吧。” 下了电车，我对少年说。 十二月的大街上，走着匆匆忙忙的行人，刮着凛冽的风。虽然距离圣诞节还有两个星期，然而圣诞树和天使已经举目皆是了，从大楼上也垂下了“年终大甩卖”的竖幅广告。走进咖啡店，少年朝菜单上瞥了一眼，问我： “还没吃早饭哪，点份煎蛋卷行吗？” 我回答说，请。他开心地笑了。 我在公用电话亭给打工的地方打了一个电话，说感冒了，请一天假。当我返回到桌边，少年像是听到了，粗声粗气地说： “这么说，你今天一天都闲着啦？” 走出咖啡店，我们往坡上走去。少年说，坡上有一个好地方。 “这里。” 他指的是一个游泳池。 “你不是在开玩笑吧，这么冷的天。” “是温水，没事。” “可我没带游泳衣啊。” “买不就行了。” 不是我推脱，我不会游泳。 “可是我不喜欢游泳……” “不会游？” 少年拿一种十分奇怪的眼神望着我，我火了，一声不吭地从钱包里掏出300元，买了门票。 除了我们这样一对疯狂的人，没有人会在十二月，而且是在一大清早跳进游泳池里！不过，也正因为如此，宽阔的游泳池被我们俩独占了。少年利落地做完准备体操，轻柔地跳进了水里。他游得像鱼一样好。池水呈现出人工的蓝色、漂白粉的味道，还有那波动的水声，都让我倍感思念。已经有多少年没进游泳池了？慢慢地下了水，看着身子随波飘荡起来。 蓦地，被谁猛地往前拉了一把，我想时摔倒了似的趴到了水面上，朝前游去。简直就像是有人在拉系在我头上的一根绳子，我不停地向前游去。刷的一下，拉绳子的力量弱了下来，我慌乱地直起身，一看，我已经是在游泳池的中央了。少年站在距我大约三米的地方，望着我的脸，微微地笑着。我想，游泳原来竟是这样惬意！ 少年与我，默默无语地一圈一圈地游着。 “上去吧。” 当少年说这话时，墙上的挂钟已经指向正午时分了。 出了游泳池，我们买了冰激凌，边走边吃。游泳后的那种疲惫感也让人觉得畅快，冰激凌的甜味，甜得连舌尖都发颤了。这一带，稍走几步，就是幽静的住宅区，与车站四周的喧嚣简直是天壤之别。少年走在我的身边，高挑的个子、端正的面孔，让我的心禁不住怦怦直跳。晴朗的白昼下，吹来一阵冬天的气息。 我们乘地铁到了银座。这次该轮到我告诉他“一个好地方”了。顺着一条背街小巷，走15分钟，有一座小小的美术馆。虽不惹眼，但却小巧玲珑，是座别具一格的美术馆。我们先欣赏了中世纪意大利的宗教画，随后，又看了古印度的工笔画。一幅一幅，看得仔细极了。 “我喜欢这幅画。” 少年说的是一幅以象及树为主题的暗绿色工笔画。 “我有一种古印度总是初夏的感觉。” “你好浪漫啊。” 给我这么一说，少年羞涩地笑了。 从美术馆出来，我们又去听了单口相声。因为碰巧从曲艺馆前面走过，少年说，我喜欢单口相声，所以就走了进去。可以进去，我就又开始变得忧郁起来。 公爵也喜欢单口相声。一天夜里，我醒过来下楼一看，已经关掉的电视机又打开了，公爵独自坐在那里听着单口相声。爸爸、妈妈，还有妹妹，谁也不相信，可我却确确实实看到了呀！ 公爵死了，悲痛欲绝的我，却和一个素不相识的男孩子一起喝茶、游泳、散步、去美术馆、听单口相声，我究竟是在干什么啊？ 演的段子是“木匠调子”。少年不时地被逗得哈哈大笑，而我却一声也笑不出来，岂止如此，我的心情还愈发沉重了。当听完单口相声，我们朝大街上走去时，悲伤又重新占据了我的心灵。 公爵不在了。 公爵死了。 大街上飘来一阵阵圣诞的歌声，浅蓝的暮色中，霓虹灯开始闪烁放光。 “今年就要结束了。”少年说。 “是哦。” “明年又是新的一年。” “是哦。” “直到今天，我都是好开心啊。” “是哦，我也是。” 我耷拉着脑袋说。少年轻轻地托起我的下颌： “直到今天哟。” 他用依依不舍、含情脉脉的目光凝视着我。接下来，少年吻了我。 我是那样诧异，不是因为他吻了我，而是他的吻太像公爵的吻了。我呆若木鸡地站在那里，连一句话也说不出来。 少年对我说：“我也好爱你啊。” 那凄凉的笑脸，酷似詹姆斯•汀。 “我只是来对你说这句话的！再见，保重啊。” 说完，少年就飞快地冲上了人行道，绿色信号灯已经开始闪烁了。 我伫立在那里，久久地听着圣诞的歌声，银座的夜，慢慢地开始了。]]></content>
      <categories>
        <category>书简</category>
      </categories>
      <tags>
        <tag>小说</tag>
        <tag>文学</tag>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html5基础]]></title>
    <url>%2Fhtml5%E5%9F%BA%E7%A1%80.html</url>
    <content type="text"><![CDATA[行间样式表1&lt;div style&#x3D;&quot;...&quot;&gt;&lt;&#x2F;div&gt;内部样式表1&lt;style&gt;...&lt;&#x2F;style&gt;外部样式表1&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;...&quot; &#x2F;&gt; 常见样式边框的语法规则、边框的单一方向/条件设置边框组成:边框粗细、边框样式、边框颜色 border-width border-style solid 实线 | dashed 虚线 | dotted 点线（IE6不兼容） border-color边框的方向:top right bottom left border-top border-top-width | border-top-style | border-top-color border-right border-right-width | border-right-style | border-right-color border-bottom border-bottom-width | border-bottom-style | border-bottom-color border-left border-left-width | border-left-style | border-left-color 边框的特性、使用边框实现三角形 边框的特征: 边框的形状:非矩形 边框三角形1234width:0;height:0;border:10px solid #fff;border-top-color:#ccc; 边框练习的步骤及要求1.先分析设计图的结构2.根据所分析的结构，进行结构编码3.根据所书写的结构，进行css编码4.利用ps工具，对设计图上的模块进行测量以及颜色的拾取5.样式添加 background内容是会撑开容器宽高，背景不会占用容器宽高，默认铺满整个容器大小 background-color 背景颜色颜色英文关键字 rgb 十六进制 background-image 背景图片 background-repeat 背景图是否重复 no-repeat 不重复 repeat-x x轴重复 repeat-y y轴重复 repeat x/y都重复 background-position 背景图位置1）具体数值2）方向关键字 left right center top bottom center当第二个属性没有填写，默认居中。 background-attachment 背景是否滚动fixed 固定在浏览器可视区域scroll 跟随滚动条滚动 background复合样式 不分属性值书写顺序 背景练习的要求1.头部区域（第一个块）直接切一张完整的图片2.内容区域里的每一个小块需要有ico并且还有背景颜色 文字着重、文字倾斜、文字大小、字体、行高 font-wight 文字着重 blod 加粗 normal 正常 font-style 文字样式 italic 斜体 font-size 文字大小 font-family 字体 line-height 行高 文字在一行里面所占用的位置注意：line-height 为奇数时，上面比下面少一像素 font-variant 设置小型大写字母的字体显示文本 small-caps 浏览器会显示小型大写字母的字体. normal 默认值 标准字体 css3属性 行高的特性、行高的测量方式当行高的值与容器高度一致时，文字会垂直居中显示多行文字测量行高的方法: 1.确认文字大小 2.确认两行文字之间的 空隙大小 3.空隙大小除以2，得出来的值就是每行文字的上下的空隙大小 3.1 当行高为奇数时，那么文字的上方要比下方少一个像素 3.2 当行高为偶数时，那么文字上下空隙值一致 4.通过辅助线测量多行文字的行高 font复合样式 需要注意书写顺序font:font-style | font-variant（设置小型大写字母的字体显示文本） | font-weight | font-size/line-height | font-family; 文本设置 文字颜色、文本对齐方式、首行缩进、文本修饰、字母间距、单词间距 color 文字颜色 text-align 文字对齐（显示）方式 left right center text-indent 首行缩进 使用em单位 em是根据字体大小来进行计算的 1em=当前字体大小 text-decoration 文本修饰 underline 下划线 none letter-spacing 字母间距 word-spacing 单词间距（以空格为解析单位）强制不换行、空格大小的测量 white-space 强制不换行 nowarp 不换行 normal 正常（text无复合样式）一个空格有多大？空格的大小:宋体字体下文字大小的一半;字体格式不一样时，空格大小也不一样。文字其实是一张张的图片，并非刚好是正正方方的，每个文字的右侧会留有一个间隙测量文字大小时，最好是使用从上到下的方式去测量文字大小，从左到右不确定文字之间留有的间隙大小 文本（font）属性练习 要求1.模块、单词间距、文字行高要与设计图统一2.思考题:每一行的前方粉色带三角的区域该如何实现？ padding 内填充margin 外边距标签与标签之间的间隔（距离）margin的问题 1.margin-top传递 :父子级包含的时候子级的margin-top会传递给父级解决方法:仅用已学知识点可以使用border解决（父级加边框） 2.margin上下叠压:上下边距会叠压（相邻元素）解决技巧: 1.还是使用margin，可以将某一个元素方向设置成预想的值。margin叠压会取最大的margin值。 2.如果元素没有特殊特征，也可以用padding代替。 盒模型 盒模型大小:border + padding + width/height 盒模型的宽度:border-left-width + padding-left + width + padding-right + border-right-width 盒模型的高度:border-top-width + padding-top + height + padding-bottom + border-bottom-width 常见复合属性: background border padding margin font:font-style|font-weight|font-size/line-height|font-family; 盒模型线框图（marign_padding）练习1.两个线框图都得做2.利用margin完成3.利用padding完成4.混合使用margin和padding同时完成注意:不管是结构还是样式的编码 从外往里（从大往小）进行编码 网易产品模块练习1.利用第一章所学的所有知识点完成2.思考:能否统一对该模块所有的文字进行行高统一的设置？ 常见标签a标签，超链接，伪类是什么，a标签的伪类，伪类的顺序a 超链接伪类 给元素添加特殊的效果link 未访问过的链接初始颜色visited 访问过后的链接颜色hover 鼠标移入（悬停）active 鼠标按下时链接的颜色 css reset原则但凡是浏览器默认的样式，都不要使用。因为每个浏览器下标签的默认样式可能会出现不一致的情况。 人为的将所有样式全部统一（清除），再根据实际情况（设计稿）进行设置。哪些样式是需要重置的？与盒模型相关的样式border | margin | padding标签特有的样式il&gt;liol&gt;li书写原则 用到什么标签就清除所用标签的默认样式 建议不要直接将所有标签全部加上。 不要将所有标签全部统一设置一致的reset，需根据标签默认样式特征来分类设置。1234body,h1,h2,h3,h4,h5,h6,p,dl,dd｛margin:0;｝ul，ol｛margin:0;padding:0;list-style:none;｝img｛border:none;vertacial-align:top;｝&#x2F;*当a标签包裹img时，IE6下会有缝隙和蓝边*&#x2F;a｛text-decoration:none;｝ 常用选择器 id选择器 当前页面唯一的 类选择器 可以是多个class加在同一个元素上.class名称 标签选择器 当前页面上所有标签名为xxx的元素 群组选择器 用逗号分隔，被逗号分隔的元素（选择器）全部执行统一的代码片段 包含选择器目标父级元素 目标元素空格-代表下一级（语法） 通配符 找到页面上符合规则的所有元素 ！！！不建议使用通配符 选择器优先级优先级 代码执行生效的顺序行间样式 &gt; id选择器 &gt; 类选择器 &gt; 标签选择器行间样式 1000id选择器 100类选择器 10标签选择器 1 块元素和内联元素块元素的特征 1.默认独占一行 2.没有宽度时，默认撑满一行 3.支持所有css命令内联（内嵌、行内）元素的特征 1.同排可以继续跟同类的标签 2.内容撑开宽度 3.不支持宽高 4.不支持上下的margin 5.代码换行被解析 display:inline 显示为内联使行块属性标签具备内联元素的特性display:block 显示为块使内联元素具备块属性标签的特性 display是将标签转换为页面中显示的类型display不会改变标签本质]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>前端</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[svg动画遇到的问题]]></title>
    <url>%2Fsvg%E5%8A%A8%E7%94%BB%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98.html</url>
    <content type="text"><![CDATA[问题背景​ 没有更改代码的情况下，svg动画在Chrome、Safari、Firefox下样式飞了，360浏览器、搜狗浏览器下样式正常（没有看其他浏览器的情况，IE浏览器不支持svg动画） 追溯问题​ 观察出问题动画，发现是元素旋转基点发生了变化，涉及到的相关属性transform-origin，修改transform-origin属性后，动画在Chrome、Safari、Firefox下表现正常了 ​ 但是在360浏览器、搜狗浏览器又错乱了。Chrome的私有属性-webkit-transform-origin在360浏览器 、搜狗浏览器同样生效。 ​ 又去查了一些svg相关的信息，但对本问题都没有帮助。 ​ 最后同事解决了这个问题– ​ 推测浏览器行为变了，推测是取父元素的标准变了 ​ 搜transform-origin找到相关文档，发现有个Percentages：refer to the size of bounding box ​ 搜索关键字，搜到transform-box属性，验证se也确实没有这个属性，将其值改为fill-box后正常了 后续​ 直接英文文档有困难，囧…找到了相关的中文文档https://cloud.tencent.com/developer/section/1072451 transform-box​ 该transform-box属性定义了与transform以及transform-origin属性相关的布局框。123456789&#x2F;* Keyword values *&#x2F;transform-box: border-box;transform-box: fill-box;transform-box: view-box;&#x2F;* Global values *&#x2F;transform-box: inherit;transform-box: initial;transform-box: unset;|Initial value|border-box|| - | - | - ||Applies to|transformable elements||Inherited|no||Media|visual||Computed value|as specified||Animation type|discrete||Canonical order|the unique non-ambiguous order defined by the formal grammar| 语法可能值 border-box——使用边框作为参考框。表的参考框是包裹着该表的边框，而不是其表框。 fill-box——使用对象边界框作为参考框。 view-box——使用最近的SVG视口作为参考框。如果viewBox属性为创建SVG视口元素指定了一个值，则参考框位于由viewBox属性建立的坐标系的原点处，并且参考框的尺寸被设置为该viewBox属性的宽度和高度值。 形式语法1border-box | fill-box | view-box 规范|Specification|Status|Comment||CSS Transforms Level 1The definition of ‘transform-box’ in that specification.|Working Draft|Initial definition| 浏览器兼容性 Feature Chrome Firefox (Gecko) Internet Explorer Opera Safari Basic support No support 55.0 (55.0)1 No support No support ? Feature Android Chrome for Android Firefox Mobile (Gecko) IE Mobile Opera Mobile Safari Mobile Basic support ? ? 55.0 (55.0)1 ? ? ? 总结 擅用搜索工具，svn+Google 先确认是不是浏览器行为变了，确认后找哪些属性的行为变了 多写码，在学习实践中拓宽思路 学好英语 transform-origin 的定位 transform-origin接受两个参数，它们可以是百分比，em，px等具体的值，也可以是left,center,right，或者 top,center,bottom等描述性参数，第一个参数表示X方向，第二个参数表示Y方向，但是，当用 left，right，center 来表示的时候，是不区分先后的！也就是说 left center 和 center left 是一回事。具体见下表： top left left top 等价于 0 0； top top center center top 等价于 50% 0 right top top right 等价于 100% 0 left left center center left 等价于 0 50% center center center 等价于 50% 50%（默认值） right right center center right 等价于 100% 50% bottom left left bottom 等价于 0 100% bottom bottom center center bottom 等价于 50% 100% bottom right right bottom 等价于 100% 100% svg中的transformHTML元素的CSS3 transform和SVG的transform坐标系统大相径庭；平常我们使用transform其坐标是相对于当前元素而言的，默认是元素的中心点变换，我们可以通过transform-origin属性改变变换的中心点。而SVG中的transform的坐标变换的是相对于画布的左上角计算的，跟HTML的transform差别较大，理解上也更加麻烦。体的语法细节有差异。SVG transform属性语法有些自带偏移。而CSS transform则更加纯粹些。]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>svg</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>svg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo建站记录]]></title>
    <url>%2Fhexo%E5%BB%BA%E7%AB%99%E8%AE%B0%E5%BD%95.html</url>
    <content type="text"><![CDATA[安装node安装hexo1npm install -g hexo-cli新建文件夹并打开1mkdir hexo &amp;&amp; cd hexo 站内搜索功能1)安装插件。进入本地hexo目录。输入以下命令:12$ npm install hexo-generator-search —save$ npm install hexo-generator-searchdb —save2)修改站点配置文件。在本地hexo根目录下的_config.yml文件中，添加以下配置:12345search: path: search.xml field: post format: html limit: 100003)修改主题配置文件。在主题目录下的_config.yml目录下，添加如下配置:12local_search: enable: true 评论功能来必力 https://livere.com/，稳定性较差，经常加载不出来 最后选了gitment，配置如下 12345678910111213141516# Gitment# Introduction: https:&#x2F;&#x2F;imsun.net&#x2F;posts&#x2F;gitment-introduction&#x2F;# You can get your Github ID from https:&#x2F;&#x2F;api.github.com&#x2F;users&#x2F;&lt;Github username&gt;gitment: enable: true mint: true # RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway count: true # Show comments count in post meta area lazy: false # Comments lazy loading with a button cleanly: false # Hide &#39;Powered by ...&#39; on footer, and more language: # Force language, or auto switch by theme github_user: # MUST HAVE, Your Github ID #开始设置为id（api里可以看到的一串数字），总是报&#96;Error: Not Found&#96;错误，改成username后就好了 github_repo: # MUST HAVE, The repo you use to store Gitment comments #例如：BlogDiscuss client_id: # MUST HAVE, Github client id for the Gitment client_secret: # EITHER this or proxy_gateway, Github access secret token for the Gitment proxy_gateway: # Address of api proxy, See: https:&#x2F;&#x2F;github.com&#x2F;aimingoo&#x2F;intersect redirect_protocol: # Protocol of redirect_uri with force_redirect_protocol when mint enabled 但是遇到一些问题，比如报[object ProgressEvent]的错，在网上找到了解决方法使用Heroku，解决gitment登录失败，报[object ProgressEvent]的错，这个地方需要注意的是，Heroku注册需要翻墙（可以使用蓝灯），否则注册页面不出现验证码，注册不了 统计功能https://leancloud.cn/ 版权声明模块修改站点配置文件。12345# Declare license on postspost_copyright: enable: true license: CC BY-NC-SA 4.0 license_url: https:&#x2F;&#x2F;creativecommons.org&#x2F;licenses&#x2F;by-nc-sa&#x2F;4.0&#x2F; 同时部署到GitHub和coding1)安装插件。进入本地hexo目录。输入以下命令:1npm install hexo-deployer-git --save2)修改站点配置文件。在本地hexo根目录下的_config.yml文件中，添加以下配置:1234567# Deployment## Docs: http:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;deployment.htmldeploy: type: git repository: git@github.com:username&#x2F;username.github.io.git repository: git@git.coding.net:username&#x2F;username.coding.me.git branch: master3)hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy 添加标签1)在要发布的新文章头部添加文章的标签tags数组1234tags: [1,2]tags: - 1 - 22)输入命令1$ hexo new page tags3)修改生成的sources/tags/index.md文件，头部添加1type: &quot;tags&quot;4)修改主题配置文件。打开标签页：12menu: tags: &#x2F;tags hexo插件安装记录sitemap 添加站点地图1)安装插件。分别安装百度和google插件，进入本地hexo目录。输入以下命令:12$ npm install hexo-generator-sitemap$ npm install hexo-generator-baidu-sitemap --save2)修改站点配置文件。在本地hexo根目录下的_config.yml文件中，添加以下配置:12345# 自动生成sitemapsitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xml把生成的sitemap提交到搜索引擎的站长平台来增加收录。 RSS1)安装插件。进入本地hexo目录。输入以下命令:1$ npm install hexo-generator-feed —save2)修改站点配置文件。在本地hexo根目录下的_config.yml文件中，添加以下配置:12345678910# Extensions## Plugins: http:&#x2F;&#x2F;hexo.io&#x2F;plugins&#x2F;#RSS订阅plugin:- hexo-generator-feed#Feed Atomfeed:type: atompath: atom.xmllimit: 203)修改主题配置文件。在主题目录下的_config.yml目录下，添加如下配置:1234# Set rss to false to disable feed link.# Leave rss as empty to use site&#39;s feed link.# Set rss to specific value if you have burned your feed already.rss: &#x2F;atom.xml DNS云解析coding 的项目 选 CNAME 解析线路选择默认线路 username.coding.megithub 的项目 选 CNAME 解析线路选择谷歌 username.github.io]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>建站</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[parallels desktop误删除config.pvs文件导致虚拟机无法使用的解决方法]]></title>
    <url>%2Fparallels%20desktop%E8%AF%AF%E5%88%A0%E9%99%A4config.pvs%E6%96%87%E4%BB%B6%E5%AF%BC%E8%87%B4%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95.html</url>
    <content type="text"><![CDATA[问题背景 工作时误删了mac最近使用的文件，与虚拟机相关的文件只有config.pvs，期间没有进行别的操作 解决方案 打开parallels desktop，点击右上角新建虚拟机 安装windows或其他操作系统 (从DVD或其他镜像文件) 继续 已找到操作系统 继续 选择您的操作系统 确定 主要把windows用于 XXX 继续 名称和位置 勾选安装前设定 继续 虚拟机配置 硬件tab 硬盘 源：选择一个镜像文件 打开之前正常工作的.pvm文件，继续打开其中的.hdd文件，选择里面的.hdd文件 打开 关闭配置对话框 继续 涉及到的其他问题：mac误删除不同路径的文件批量恢复困难，如果是刚完成的一次性操作，可以通过command+z快捷键恢复]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
        <tag>parallels desktop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何写好测试用例]]></title>
    <url>%2F%E5%A6%82%E4%BD%95%E5%86%99%E5%A5%BD%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B.html</url>
    <content type="text"><![CDATA[需求分析、测试方法、测试用例表格设计、测试用例编写评审、测试用例管理 前置知识点：软件相关概念数据、程序、文档的结合。操作数据，测试的主体是程序，文档是工作时的可视化，测试用例是文档的一部分 软件测试基础以满足需求为目的，保证软件质量的手段 测试流程需求分析、计划制定、用例的编写与执行、对测试结果的分析报告 测试生命周期测试计划、测试设计、测试开发、测试执行、测试评估 测试常用术语按照软件测试手段划分： 黑盒：把软件比作一个黑色盒子，不知道内部结构，通过外部暴露出来的接口和功能测试； 灰盒：把软件比作一个半透明盒子，可以看到内部少部分信息，通过外面暴露的功能和盒子内部的数据进行对比得出测试结论； 白盒：把软件比作一个透明盒子，通过观察内部结构，直接推测出软件是否满足用户需求；（难度最高）专项测试方向： 功能：验证软件是否满足用户提出的表面需求； 性能：测试软件的工作效率； 安全：测试软件是否能够保护用户的信息不被盗取；测试的测试点划分： 兼容性：测试软件在不同平台上的表现； 易用性：测试软件是否友好，满足用户的使用习惯； UI元素：检测软件的界面的布局显示是否一致、美观等； 测试用例介绍测试用例是什么（测试时使用的重要文档）测试工作的核心一组在测试时输入输出的标准软件需求的具体对照 测试用例的作用检验软件是否满足客户需求体现一个测试人员的工作量展现测试用例的设计思路 测试用例包含哪些内容 用例编号：唯一识别号码，通过下划线连接+其他信息添加详细描述，例如一个登陆模块，可以用login_001的形式 用例名称：言简意赅，用最少的文字描述准确 测试背景：说明该用例是什么样的用例，属于哪个项目，测试什么内容 前置条件：在执行这条测试之前要满足什么条件，比如测试登录功能，需要的前置条件是账号密码是已经注册的 优先级：优先级和重要级不一定成正比 重要级： 测试数据：比如登录功能，账号密码即为测试数据，有些测试用例不需要用键盘输入值，但也有测试数据，鼠标的操作也是一组测试数据 测试步骤：测试时应该按照测试步骤的描述第一步第二步第三步依次执行 预期结果：每一步操作对应的现象，例如登陆模块，输入账号密码点击登陆，预期结果为登录成功 实际结果：执行测试时出现的实际情况，可能和预期结果一致或者不一致 备注：描述一下特殊信息 其他信息：根据实际情况编写；测试用例编写流程需求分析、提取测试点、测试用例编写、测试用例评审注：（问答）优先级是事件的优先顺序，重要级是事件的轻重缓急； 一份测试用例本应该是不包含实际结果的，只有预期结果，因为实际结果是在执行用例之后才产生的，但是，此时的测试用例可以说是不完整的，测试人员只有将测试实际结果数据填充到每条用例后面，与预期结果进行对比，才知道这条用例是否通过，所以说一份完整的测试用例里面应该需要包含测试实际结果 就好比医院的化验单，必须得知道化验结果中各个指标当前情况（实际结果），以及正常值范围（预期结果）是多少，这时候医生才能诊断你的病情，从而得出结论 准确的说在测试设计阶段，做成测试用例本身是不需要实际结果。但是把测试用例文档化，做成测试用例表，就应该要加入实际结果这一项。目的是为了跟踪测试结果 需求分析与测试点编写需求分析 业务需求：关注系统是否满足业务 用户需求：关注系统是否满足用户习惯 功能需求：关注系统是否满足功能需求没有需求怎么办参考市面上已经上线的同类产品需求模糊怎么办 收集整理已有需求 和产品经理逐条确认 参考同类型产品的实现情况提取测试点什么是测试点测试点即通过需求分析后对得出的需要进行测试的具体内容测试点对测试用例的设计好处快速、覆盖、 方法、细节功能模块、测试点编号、测试点描述注：（问答）一条正规测试用例包括哪些内容2） 软件或项目的版本（内部版本号）3） 功能模块名4） 测试用例的简单描述，即该用例执行的目的或方法5） 测试用例的参考信息（便于跟踪和参考）6） 本测试用例与其他测试用例间的依赖关系7） 本用例的前置条件，即执行本用例必须要满足的条件，如对数据库的访问权限8） 用例的编号（ID），如可以是 软件名称简写-功能块简写-NO.。9） 步骤号、操作步骤描述、测试数据描述10）预期结果（这是最重要的）和实际结果（如果有BUG管理工具，这条可以省略）11）开发人员（必须有）和测试人员（可有可无）12）测试执行日期 测试用例编写方法注意事项1.根据项目的实际情况设计测试用例表格2.用例的表格不是固定的，不要生搬硬套3.根据具体的情况编写 测试用例编写方法（常用设计方法）等价类划分法：黑盒测试方法因为测试是无穷尽的，所以需要用等价类划分法选出最具有代表性的数据进行测试如何选择适当的数据子集，来代表整个测试集通过降低测试的数目去实现“合理的”覆盖，覆盖了更多的可能性数据，以发现更多的软件缺陷将程序所有可能的输入数据划分成若干等价类，然后从每个部分中选取最具有代表性的数据当作测试用例进行合理的分类，测试用例由有效等价类和无效等价类组成 测试用例具有完整性和代表性有效等价类：对于程序规格说明来说，合理的，有意义的输入数据构成的集合，可以检验程序是否符合规格说明预先规定的功能和性能，可以是一个或多个，根据系统的输入划分成若干个部分，然后从每个部分中选取少数有代表性的数据当作数据测试的测试用例，等价类是输入域的集合，符合规范的数据集合无效等价类：不合理的，没有意义的输入数据集合，通过无效等价类可以检验程序异常的情况，是否不符合规范要求等 边界值分析法：黑盒测试方法对输入或输出的边界值进行测试的黑盒测试方法，对等价类测试法的一种补充，可以用于快速选出等价类使用边界值分析法设计测试用例时一般与等价类划分法结合起来但它不是从一个等价类中任意选一个例子作为代表，而是将测试边界情况作为重点目标，选取正好等于、刚刚大于或刚刚小于边界值的测试数据 场景法：分析用户在使用软件时都会遇到哪些场景通过运用场景来对系统的功能点或业务流程的描述，从而提高测试效果。场景法一般包含基本流和备用流，从一个流程开始，通过描述经过的路径来确定的过程，经过遍历所有的基本流和备用流来完成整个场景。 猜测法：直觉90%-〉猜测50%，经验90%-〉结果80%。需要依靠测试经验猜测哪些地方容易出现问题，依靠经验分析哪些场景容易被开发忽略从而快速得到测试结果测试用例评审（所有的文档需求变动 都会进行评审） 简单来讲，评审就是对测试用例进行检查 评审包括同行评审，小组评审，部门评审，三方评审等 不同的评审类型会有不同的角色参与评审的意义在哪里1.通过评审可以发现测试用例的不足2.方便测试人员改进用例3.达到在测试时提高测试质量的目的评审的流程改进测试用例-〉评审-〉改进测试用例-〉评审 评审的过程不是一次性的，是一个持续改进的过程。 测试用例管理为什么要管理用例？1.测试用例数量巨大2.测试用例会随着需求变更3.测试用例需要补充完善 如何管理用例？1.原始的Excel管理方式 （整理起来比较不方便，只能应用于比较少量的测试用例上）2.专业的项目管理系统（可以跟踪变更，每一次的执行情况都可以记录，可以对测试出来的bug进行关联） 如何选择管理测试用例的工具 管理工具 成本 可扩展性 易用性 功能 ALM 5 5 4 5 （惠普的一个管理系统，商业版，成本高） 禅道 3 3 3 3 （有免费版和商业版） testlink 1 4 2 3 （开源） Bugzilla 1 4 2 3 JIRA 4 3 2 3 禅道基本应用1.专业的研发项目管理软件2.完整支持敏捷开发流程3.完整软件生命周期管理 根据慕课网课程：如何写好测试用例 整理。]]></content>
      <categories>
        <category>学习笔记</category>
        <category>测试</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2FHello%20World.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>test</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Grunt学习]]></title>
    <url>%2FGrunt%E5%AD%A6%E4%B9%A0.html</url>
    <content type="text"><![CDATA[什么是前端集成解决方案解决前端工程的根本问题一套包含框架和工具，便于开发者快速构建美丽实用的web应用程序的工作流，同时这套工作流必须是稳健强壮的。 解决哪些前端问题 开发团队代码风格不统一，如何强制开发规范； 前期开发的组件库如何维护和使用； 如何模块化前端项目； 服务器部署前必须的压缩，检查流程如何简化，流程如何完善 主流的方式有哪几种 Yeoman Bower Grunt/Gulp CodeKit https://incident57.com/codekit/ FIS http://fis.baidu.com/ Spirit http://alloyteam.github.io/Spirit/ Grunt的定位Build tool 目前Grunt的竞争者ant Gulp小众Buildy jasy Gmakehttps://github.com/zynga/jasyhttps://github.com/mosen/buildy]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Emmet 语法]]></title>
    <url>%2FEmmet%20%E8%AF%AD%E6%B3%95.html</url>
    <content type="text"><![CDATA[缩写缩写是Emmet工具包的关键：这些特殊的表达式在运行时解析和转化成结构化的代码块，例如HTML。缩写的语法看起来像CSS选择器，它有一些特定于代码生成的扩展。因此，每个Web开发者都已经知道如何使用它。 下面是一个例子：这个缩写1#page&gt;div.logo+ul#navigation&gt;li*5&gt;a&#123;Item $&#125;可以转化为12345678910&lt;div id&#x3D;&quot;page&quot;&gt; &lt;div class&#x3D;&quot;logo&quot;&gt;&lt;&#x2F;div&gt; &lt;ul id&#x3D;&quot;navigation&quot;&gt; &lt;li&gt;&lt;a href&#x3D;&quot;&quot;&gt;Item 1&lt;&#x2F;a&gt;&lt;&#x2F;li&gt; &lt;li&gt;&lt;a href&#x3D;&quot;&quot;&gt;Item 2&lt;&#x2F;a&gt;&lt;&#x2F;li&gt; &lt;li&gt;&lt;a href&#x3D;&quot;&quot;&gt;Item 3&lt;&#x2F;a&gt;&lt;&#x2F;li&gt; &lt;li&gt;&lt;a href&#x3D;&quot;&quot;&gt;Item 4&lt;&#x2F;a&gt;&lt;&#x2F;li&gt; &lt;li&gt;&lt;a href&#x3D;&quot;&quot;&gt;Item 5&lt;&#x2F;a&gt;&lt;&#x2F;li&gt; &lt;&#x2F;ul&gt;&lt;&#x2F;div&gt;只需一个键击。在许多编辑器中（如Eclipse、Sublime Text 2、Espresso等），插件也会生成适当的制表符标记，以便您可以使用Tab键在生成的代码的重要位置之间快速遍历。缩写优化HTML和XML的生成，但不限于此，还使书写繁琐的标记代码变得轻而易举。你可以开始学习语法来释放Emmet缩写的全部力量。 缩写语法Emmet使用类似于CSS选择器的语法来描述生成树和元素属性中的元素位置。 元素可以使用元素的名称，如div或p来生成HTML标记。Emmet没有预定义的可用标记名称集，可以编写任何单词并将其转换成标记：div → &lt;div&gt;&lt;/div&gt;, foo → &lt;foo&gt;&lt;/foo&gt;等等。 嵌套运算符嵌套运算符用于在生成的树中定位缩写元素：是应该放在上下文元素内还是应该放在上下文元素附近。 Child: &gt;可以使用&gt;运算符将元素嵌套在一起：1div&gt;ul&gt;li将产生12345&lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;&#x2F;li&gt; &lt;&#x2F;ul&gt;&lt;&#x2F;div&gt; Sibling: +使用+运算符将元素彼此靠近，在同一水平上：1div+p+bq将输出123&lt;div&gt;&lt;&#x2F;div&gt;&lt;p&gt;&lt;&#x2F;p&gt;&lt;blockquote&gt;&lt;&#x2F;blockquote&gt; Climb-up: ^使用&gt;运算符，您将沿着生成的树下降，所有兄弟元素的位置将根据最深的元素进行解析：1div+div&gt;p&gt;span+em将扩展到1234&lt;div&gt;&lt;&#x2F;div&gt;&lt;div&gt; &lt;p&gt;&lt;span&gt;&lt;&#x2F;span&gt;&lt;em&gt;&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;使用^运算符，您可以爬树一级并更改以下元素应该出现的上下文：1div+div&gt;p&gt;span+em^bq输出到12345&lt;div&gt;&lt;&#x2F;div&gt;&lt;div&gt; &lt;p&gt;&lt;span&gt;&lt;&#x2F;span&gt;&lt;em&gt;&lt;&#x2F;em&gt;&lt;&#x2F;p&gt; &lt;blockquote&gt;&lt;&#x2F;blockquote&gt;&lt;&#x2F;div&gt;您可以使用尽可能多的^运算符，每个运算符将向上移动一个级别：1div+div&gt;p&gt;span+em^^^bq将输出12345&lt;div&gt;&lt;&#x2F;div&gt;&lt;div&gt; &lt;p&gt;&lt;span&gt;&lt;&#x2F;span&gt;&lt;em&gt;&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;&lt;blockquote&gt;&lt;&#x2F;blockquote&gt; Multiplication: *使用*运算符，可以定义要输出多少次元素：1ul&gt;li*5输出1234567&lt;ul&gt; &lt;li&gt;&lt;&#x2F;li&gt; &lt;li&gt;&lt;&#x2F;li&gt; &lt;li&gt;&lt;&#x2F;li&gt; &lt;li&gt;&lt;&#x2F;li&gt; &lt;li&gt;&lt;&#x2F;li&gt;&lt;&#x2F;ul&gt; Grouping: ()Emmet的用户使用括号来对复杂缩写中的子树进行分组：1div&gt;(header&gt;ul&gt;li*2&gt;a)+footer&gt;p扩展到1234567891011&lt;div&gt; &lt;header&gt; &lt;ul&gt; &lt;li&gt;&lt;a href&#x3D;&quot;&quot;&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt; &lt;li&gt;&lt;a href&#x3D;&quot;&quot;&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;&#x2F;header&gt; &lt;footer&gt; &lt;p&gt;&lt;&#x2F;p&gt; &lt;&#x2F;footer&gt;&lt;&#x2F;div&gt;如果您正在使用浏览器的DOM，则可以将组看作文档片段：每个组包含缩写子树，并且其后面的所有元素都以与组的第一个元素相同的级别插入。 可以将组嵌套在一起，并将它们与乘法*运算符组合：1(div&gt;dl&gt;(dt+dd)*3)+footer&gt;p产生12345678910111213&lt;div&gt; &lt;dl&gt; &lt;dt&gt;&lt;&#x2F;dt&gt; &lt;dd&gt;&lt;&#x2F;dd&gt; &lt;dt&gt;&lt;&#x2F;dt&gt; &lt;dd&gt;&lt;&#x2F;dd&gt; &lt;dt&gt;&lt;&#x2F;dt&gt; &lt;dd&gt;&lt;&#x2F;dd&gt; &lt;&#x2F;dl&gt;&lt;&#x2F;div&gt;&lt;footer&gt; &lt;p&gt;&lt;&#x2F;p&gt;&lt;&#x2F;footer&gt;用组，你甚至可以用一个缩写来写完整的页面标记，但是请不要这样做。 属性运算符属性运算符用于修改输出元素的属性。例如，在HTML和XML中，您可以快速地将 class 属性添加到生成的元素中。 ID and CLASS在CSS中，您使用elem#id和elem.class符号来达到具有指定id或class属性的元素。在Emmet中，可以使用非常相同的语法将这些属性添加到指定的元素：1div#header+div.page+div#footer.class1.class2.class3输出123&lt;div id&#x3D;&quot;header&quot;&gt;&lt;&#x2F;div&gt;&lt;div class&#x3D;&quot;page&quot;&gt;&lt;&#x2F;div&gt;&lt;div id&#x3D;&quot;footer&quot; class&#x3D;&quot;class1 class2 class3&quot;&gt;&lt;&#x2F;div&gt; Custom attributes可以使用[attr]符号（类似于CSS）将自定义属性添加到元素中：1td[title&#x3D;&quot;Hello world!&quot; colspan&#x3D;3]输出&lt;td title=&quot;Hello world!&quot; colspan=&quot;3&quot;&gt;&lt;/td&gt; 您可以在方格括号内放置尽可能多的属性。 您不必指定属性值：td[colspan title]将生成&lt;td colspan=&quot;&quot; title=&quot;&quot;&gt;，每个空属性内都有tabstop（如果编辑器支持它们）。 您可以使用单引号或双引号引用属性值。 如果它们不包含空格，则不需要引用值：td[title=hello colspan=3]将起作用。Item numbering: $使用乘法*运算符，可以重复元素，但用$可以对它们进行编号。将$操作符放入元素的名称、属性名或属性值，以输出重复元素的当前数目：1ul&gt;li.item$*5 输出1234567&lt;ul&gt; &lt;li class&#x3D;&quot;item1&quot;&gt;&lt;&#x2F;li&gt; &lt;li class&#x3D;&quot;item2&quot;&gt;&lt;&#x2F;li&gt; &lt;li class&#x3D;&quot;item3&quot;&gt;&lt;&#x2F;li&gt; &lt;li class&#x3D;&quot;item4&quot;&gt;&lt;&#x2F;li&gt; &lt;li class&#x3D;&quot;item5&quot;&gt;&lt;&#x2F;li&gt;&lt;&#x2F;ul&gt; 您可以在一行中使用多个$来用零来填充数字：1ul&gt;li.item$$$*5 输出1234567&lt;ul&gt; &lt;li class&#x3D;&quot;item001&quot;&gt;&lt;&#x2F;li&gt; &lt;li class&#x3D;&quot;item002&quot;&gt;&lt;&#x2F;li&gt; &lt;li class&#x3D;&quot;item003&quot;&gt;&lt;&#x2F;li&gt; &lt;li class&#x3D;&quot;item004&quot;&gt;&lt;&#x2F;li&gt; &lt;li class&#x3D;&quot;item005&quot;&gt;&lt;&#x2F;li&gt;&lt;&#x2F;ul&gt; 改变编号基础和方向使用@修饰符，可以更改编号方向（升序或降序）和基数（例如起始值）。例如，为了改变方向,在$后面添加@-：1ul&gt;li.item$@-*5 输出1234567&lt;ul&gt; &lt;li class&#x3D;&quot;item5&quot;&gt;&lt;&#x2F;li&gt; &lt;li class&#x3D;&quot;item4&quot;&gt;&lt;&#x2F;li&gt; &lt;li class&#x3D;&quot;item3&quot;&gt;&lt;&#x2F;li&gt; &lt;li class&#x3D;&quot;item2&quot;&gt;&lt;&#x2F;li&gt; &lt;li class&#x3D;&quot;item1&quot;&gt;&lt;&#x2F;li&gt;&lt;&#x2F;ul&gt; 若要更改计数器基值，请将@N修饰符添加到$：1ul&gt;li.item$@3*5 转化为1234567&lt;ul&gt; &lt;li class&#x3D;&quot;item3&quot;&gt;&lt;&#x2F;li&gt; &lt;li class&#x3D;&quot;item4&quot;&gt;&lt;&#x2F;li&gt; &lt;li class&#x3D;&quot;item5&quot;&gt;&lt;&#x2F;li&gt; &lt;li class&#x3D;&quot;item6&quot;&gt;&lt;&#x2F;li&gt; &lt;li class&#x3D;&quot;item7&quot;&gt;&lt;&#x2F;li&gt;&lt;&#x2F;ul&gt; 你可以把这些修饰词组合在一起：1ul&gt;li.item$@-3*5 转化为1234567&lt;ul&gt; &lt;li class&#x3D;&quot;item7&quot;&gt;&lt;&#x2F;li&gt; &lt;li class&#x3D;&quot;item6&quot;&gt;&lt;&#x2F;li&gt; &lt;li class&#x3D;&quot;item5&quot;&gt;&lt;&#x2F;li&gt; &lt;li class&#x3D;&quot;item4&quot;&gt;&lt;&#x2F;li&gt; &lt;li class&#x3D;&quot;item3&quot;&gt;&lt;&#x2F;li&gt;&lt;&#x2F;ul&gt; Text: {}可以使用大括号向元素添加文本：1a&#123;Click me&#125; 将产生1&lt;a href&#x3D;&quot;&quot;&gt;Click me&lt;&#x2F;a&gt; 注意，&#123;text&#125;被用作一个单独的元素（如，div、p等）并被解析，但是当写在元素后面时，它具有特殊的含义。例如，a&#123;click&#125;和a&gt;&#123;click&#125;将产生相同的输出，但a&#123;click&#125;+b&#123;here&#125;和a&gt;&#123;click&#125;+b&#123;here&#125;将不会：12345&lt;!-- a&#123;click&#125;+b&#123;here&#125; --&gt;&lt;a href&#x3D;&quot;&quot;&gt;click&lt;&#x2F;a&gt;&lt;b&gt;here&lt;&#x2F;b&gt;&lt;!-- a&gt;&#123;click&#125;+b&#123;here&#125; --&gt;&lt;a href&#x3D;&quot;&quot;&gt;click&lt;b&gt;here&lt;&#x2F;b&gt;&lt;&#x2F;a&gt; 在第二个例子中，&lt;b&gt;元素放置在&lt;a&gt;元素内。这就是区别：当&#123;text&#125;在元素之后被写入时，它不会改变父级上下文。这里有一个更复杂的例子，说明为什么它是重要的：1p&gt;&#123;Click &#125;+a&#123;here&#125;+&#123; to continue&#125; 产生1&lt;p&gt;Click &lt;a href&#x3D;&quot;&quot;&gt;here&lt;&#x2F;a&gt; to continue&lt;&#x2F;p&gt; 在本例中，为了在&lt;p&gt;元素中写入Click here to continue，我们在p之后显式地用&gt;运算符沿着树向下移动，但是在a元素的情况下，我们不必这样做，因为我们只需要使用&lt;a&gt;元素和here单词，而不需要改变父上下文。 为了比较，这里有相同的缩写，没有子节点&gt;操作：1p&#123;Click &#125;+a&#123;here&#125;+&#123; to continue&#125;产生12&lt;p&gt;Click &lt;&#x2F;p&gt;&lt;a href&#x3D;&quot;&quot;&gt;here&lt;&#x2F;a&gt; to continue 关于缩写格式的注记当您熟悉Emmet的缩写语法时，您可能希望使用一些格式来使缩写更加可读。例如，在元素和运算符之间使用空格，如：1(header &gt; ul.nav &gt; li*5) + footer但是它不起作用，因为空间是一个停止符号，Emmet停止了缩写解析。 许多用户错误地认为每个缩写都应该用新行编写，但是他们错了：您可以在文本中的任何地方键入和扩展缩写：你不需要新行来展开缩写1&lt;li&gt;Hello World span.info&lt;li&gt;Emmet很聪明，可以理解你想扩大span.info的缩写，而不是li&gt;span.info。1&lt;li&gt;span.info&lt;li&gt; 这就是为什么Emmet需要一些指示符（比如空格）的地方，它应该停止解析，以不扩展任何你不需要的东西。如果你仍然认为复杂的缩略语需要这样的格式化使它们更可读： 缩写不是模板语言，它们不必是“可读的”，它们必须是“快速可扩展和可移除的”。 你不需要写复杂的缩写。不要认为“打字”是网页开发中最慢的过程。您将很快发现，构造单个复杂缩写比构造并键入几个短缩写要慢得多，而且容易出错。 phpStorm中的用法 介绍HTML中所有的标签都是盒子盒子有几种关系：盒子本身，盒子并列，盒子包含类是统一类字符，可以很多盒子使用id代表唯一，只能一个盒子使用 phpStorm中标签输入方式HTML表达式TAB健 HTML标签输入标签名 tab 内容输入表达式&gt;{内容} tab 类输入标签名.类名 tab ID输入标签#id名 tab 序号输入表达式*数字 tab 多个相同的输入(乘法)表达式 $* 数字 tab 并列输入表达式+表达式+表达式 tab 包含盒子输入表达式&gt;表达式&gt;表达式 tab 括号分组(表达式) tabul&gt;(li&gt;a) 官网：https://docs.emmet.io/abbreviations/syntax/]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>前端</tag>
        <tag>插件</tag>
        <tag>emmet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[viewport]]></title>
    <url>%2Fviewport.html</url>
    <content type="text"><![CDATA[target-densitydpi，这个属性可以改变设备的默认缩放。medium-dpi是target-densitydpi的默认值，如果显式定义target-densitydpi=device-dpi，那么设备就会按照真实的dpi来渲染页面。 target-densitydpi 这个私有属性，它表示目标设备的密度等级，作用是决定css中的1px代表多少物理像素target-densitydpi 值可以为一个数值或high-dpi、medium-dpi、low-dpi、device-dpi这几个字符串中的一个特别说明的是，当 target-densitydpi=device-dpi 时， css中的1px会等于物理像素中的1px。因为这个属性只有安卓支持，并且安卓已经决定要废弃target-densitydpi这个属性了，尽量避免使用这个属性。 每个属性的详细介绍： 属性名 取值 描述 width 正整数 或 device-width 定义视口的宽度，单位为像素 height 正整数 或 device-height 定义视口的高度，单位为像素，一般不用 initial-scale [0.0-10.0] 定义初始缩放值 minimum-scale [0.0-10.0] 定义缩小最小比例，它必须小于或等于maximum-scale设置 maximum-scale [0.0-10.0] 定义放大最大比例，它必须大于或等于minimum-scale设置 user-scalable yes/no 定义是否允许用户手动缩放页面，默认值yes]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js typing]]></title>
    <url>%2Fjs%20typing.html</url>
    <content type="text"><![CDATA[12345678910111213141516&lt;div id&#x3D;&#39;divTyping&#39;&gt;&lt;&#x2F;div&gt;&lt;script&gt; var str &#x3D; &#39;js 实现的 打字效果。&#39;; var i &#x3D; 0; function typing()&#123; var divTyping &#x3D; document.getElementById(&#39;divTyping&#39;); if (i &lt;&#x3D; str.length) &#123; divTyping.innerHTML &#x3D; str.slice(0, i++) + &#39;_&#39;; setTimeout(&#39;typing()&#39;, 200);&#x2F;&#x2F;递归调用 &#125; else&#123; divTyping.innerHTML &#x3D; str;&#x2F;&#x2F;结束打字,移除 _ 光标 &#125; &#125; typing();&lt;&#x2F;script&gt; 示例：点击查看 另一种自动打字效果，引用自：https://blog.csdn.net/qq_32623363/article/details/77429463示例：点击查看]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tabindex=-1让普通元素获得焦点]]></title>
    <url>%2Ftabindex%3D-1%E8%AE%A9%E6%99%AE%E9%80%9A%E5%85%83%E7%B4%A0%E8%8E%B7%E5%BE%97%E7%84%A6%E7%82%B9.html</url>
    <content type="text"><![CDATA[tabindex:规定元素的 tab 键次序。html中的tabIndex属性可以设置键盘中的TAB键在控件中的移动顺序,即焦点的顺序。 把控件的tabIndex属性设成1到32767的一个值，就可以把这个控件加入到TAB键的序列中。 这样，当浏览者使用TAB键在网页控件中移动时，将首先移动到具有最小tabIndex属性值的控件上，最后在具有最大tabIndex属性值的控件上结束移动。 如果有两个控件的tabIndex属性相同，则以控件在html代码中出现的顺序为准。 默认的tabIndex属性为0，将排列在在所有指定tabIndex的控件之后。 而若把tabIndex属性设为一个负值（如tabIndex=”-1”），那么这个链接将被排除在TAB键的序列之外。如果最初选择了[Tab]键，带这个输入栏的网页会将光标移动到firstName栏。 在给tabIndex特性赋值时，要留意几个问题。下面是几个赋值规则： 带0值tabIndex的元素根据源代码（或默认页面行为）进行排序。 大于0的tabIndex值设定其tab顺序。所有带正tabIndex值的元素出现在所有带0 tabIndex值的元素之前。 如果你犯了一个错误，把同一个tabIndex赋予给多个元素，像其它元素一样，它们会以一个0值tabIndex进行处理。 将tabIndex赋值为-1，则在使用[Tab]键时，此元素被忽略。注意：如果使用-1值时，onfocus与onblur事件仍被启动。tabIndex的值可为0至32767之间的任意数字 默认情况下，只有链接元素和表单元素可通过tab按键获得焦点。如果对其它元素使用tabindex属性也可以获得焦点，并可以实现focus（）方法。如果其它元素通过tab键获得焦点，只需将tabindex值为－1 浏览器支持几乎所有浏览器均tabindex属性，除了Safari。 定义和用法tabindex 属性规定元素的 tab 键控制次序（当 tab 键用于导航时）。 提示和注释注释：以下元素支持 tabindex 属性：&lt;a&gt;,&lt;area&gt;,&lt;button&gt;,&lt;input&gt;,&lt;object&gt;,&lt;select&gt;以及&lt;textarea&gt;。 语法&lt;element tabindex=&quot;number&quot;&gt; 属性值12345678910&lt;table&gt; &lt;th&gt; &lt;dd&gt;值&lt;&#x2F;dd&gt; &lt;dd&gt;描述&lt;&#x2F;dd&gt; &lt;&#x2F;th&gt; &lt;td&gt; &lt;dd&gt;number&lt;&#x2F;dd&gt; &lt;dd&gt;规定元素的 tab 键控制次序（1 是第一个）。&lt;&#x2F;dd&gt; &lt;&#x2F;td&gt;&lt;&#x2F;table&gt; 参考：1.https://blog.csdn.net/tom0008668/article/details/649047522.http://www.w3school.com.cn/tags/att_standard_tabindex.asp]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS Hack]]></title>
    <url>%2FCSS%20Hack.html</url>
    <content type="text"><![CDATA[CSS Hack]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>前端</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[获取当前设备的屏幕宽度]]></title>
    <url>%2F%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E8%AE%BE%E5%A4%87%E7%9A%84%E5%B1%8F%E5%B9%95%E5%AE%BD%E5%BA%A6.html</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;utf-8&quot;&gt; &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width,initial-scale&#x3D;1,minimum-scale&#x3D;1,maximum-scale&#x3D;1,user-scalable&#x3D;no&quot;&gt; &lt;title&gt;获取当前设备的屏幕宽度&lt;&#x2F;title&gt; &lt;script&gt; var deviceWidth &#x3D; parseInt(window.screen.width); &#x2F;&#x2F;获取当前设备的屏幕宽度 var deviceScale &#x3D; deviceWidth &#x2F; 640; &#x2F;&#x2F;得到当前设备屏幕与640之间的比例，之后我们就可以将网页宽度固定为640px var ua &#x3D; navigator.userAgent; &#x2F;&#x2F;获取当前设备类型（安卓或苹果） if (&#x2F;Android (\d+\.\d+)&#x2F;.test(ua)) &#123; var version &#x3D; parseFloat(RegExp.$1); if (version &gt; 2.3) &#123; document.write(&#39;&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;640,initial-scale&#x3D;&#39; + deviceScale + &#39;, minimum-scale &#x3D; &#39; + deviceScale + &#39;, maximum-scale &#x3D; &#39; + deviceScale + &#39;, target-densitydpi&#x3D;device-dpi&quot;&gt;&#39;); &#125; else &#123; document.write(&#39;&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;640,initial-scale&#x3D;0.75,maximum-scale&#x3D;0.75,minimum-scale&#x3D;0.75,target-densitydpi&#x3D;device-dpi&quot; &#x2F;&gt;&#39;); &#125; &#125; else &#123; document.write(&#39;&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;640, user-scalable&#x3D;no&quot;&gt;&#39;); &#125; &lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML标签的默认样式]]></title>
    <url>%2FHTML%E6%A0%87%E7%AD%BE%E7%9A%84%E9%BB%98%E8%AE%A4%E6%A0%B7%E5%BC%8F.html</url>
    <content type="text"><![CDATA[HTML标签的默认样式]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用js实现css3动画效果]]></title>
    <url>%2F%E7%94%A8js%E5%AE%9E%E7%8E%B0css3%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C.html</url>
    <content type="text"><![CDATA[用js实现css3动画效果]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端相关练习list]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3%E7%BB%83%E4%B9%A0list.html</url>
    <content type="text"><![CDATA[1.绘制图表 flot.js2.selection用法 例：复制后粘贴加入规定文本信息 改变选中文字颜色等3.前端加密 混淆4.搜索功能5.个性化定制 -支持自定义布局 -支持皮肤风格更换 -支持模块插件设置 -支持页头及页面背景更换 -支持栏目自定义设置]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css预处理器]]></title>
    <url>%2Fcss%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8.html</url>
    <content type="text"><![CDATA[css预处理器SassLess]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>前端</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记]]></title>
    <url>%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
    <content type="text"><![CDATA[&lt;tbody&gt;…&lt;/tbody&gt;：如果不加&lt;thead&gt;、&lt;tbody&gt;、&lt;tfooter&gt; , table表格加载完后才显示。加上这些表格结构， tbody包含行的内容下载完优先显示，不必等待表格结束后在显示，同时如果表格很长，用tbody分段，可以一部分一部分地显示。（通俗理解table 可以按结构一块块的显示，不在等整个表格加载完后显示。） 使用mailto在网页中链接Email地址 &lt;a href=&quot;mailto:&quot;&gt;1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;table&gt; &lt;caption&gt;&lt;&#x2F;caption&gt; &lt;tbody&gt; &lt;tr&gt; &lt;th&gt;功能&lt;&#x2F;th&gt; &lt;th&gt;关键字&lt;&#x2F;th&gt; &lt;th&gt;功能详解&lt;&#x2F;th&gt; &lt;th&gt;举例&lt;&#x2F;th&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td&gt;邮箱地址&lt;&#x2F;td&gt; &lt;td&gt;mailto:&lt;&#x2F;td&gt; &lt;td&gt;浏览器会自动调用默认的客户端电子邮件程序（如Outlook），并在收件人框中自动填上收件人的地址&lt;&#x2F;td&gt; &lt;td&gt;&lt;a href&#x3D;&quot;mailto:test@163.com&quot;&gt;发送&lt;&#x2F;a&gt;&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td&gt;抄送地址&lt;&#x2F;td&gt; &lt;td&gt;cc&#x3D;&lt;&#x2F;td&gt; &lt;td&gt;在收件人地址后用&lt;em&gt;cc&#x3D;&lt;&#x2F;em&gt;地址，可以填写抄送地址&lt;&#x2F;td&gt; &lt;td&gt;&lt;a href&#x3D;&quot;mailto:test@163.com?cc&#x3D;test@163.com&quot;&gt;发送&lt;&#x2F;a&gt;&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td&gt;密件抄送地址&lt;&#x2F;td&gt; &lt;td&gt;bcc&#x3D;&lt;&#x2F;td&gt; &lt;td&gt;在收件人地址后用&lt;em&gt;bcc&#x3D;&lt;&#x2F;em&gt;地址，可以填上密件抄送地址&lt;&#x2F;td&gt; &lt;td&gt;&lt;a href&#x3D;&quot;mailto:test@163.com?bcc&#x3D;test@163.com&quot;&gt;发送&lt;&#x2F;a&gt;&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td&gt;多个收件人、抄送、密件抄送人&lt;&#x2F;td&gt; &lt;td&gt;;&lt;&#x2F;td&gt; &lt;td&gt;用分号隔开多个收件人的地址，可以实现发送给多个收件人功能&lt;&#x2F;td&gt; &lt;td&gt;&lt;a href&#x3D;&quot;mailto:test@163.com;test@163.com&quot;&gt;&lt;&#x2F;a&gt;&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td&gt;邮件主题&lt;&#x2F;td&gt; &lt;td&gt;subject&#x3D;&lt;&#x2F;td&gt; &lt;td&gt;用&lt;em&gt;subject&#x3D;&lt;&#x2F;em&gt;添加邮件主题&lt;&#x2F;td&gt; &lt;td&gt;&lt;a href&#x3D;&quot;mailto:test@163.com?subject&#x3D;发送电子邮件&quot;&gt;&lt;&#x2F;a&gt;&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td&gt;邮件内容&lt;&#x2F;td&gt; &lt;td&gt;body&#x3D;&lt;&#x2F;td&gt; &lt;td&gt;用&lt;em&gt;body&#x3D;&lt;&#x2F;em&gt;添加邮件的内容&lt;&#x2F;td&gt; &lt;td&gt;&lt;a href&#x3D;&quot;mailto:test@163.com?body&#x3D;欢迎&quot;&gt;&lt;&#x2F;a&gt;&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt; 示例：点击查看 表单标签1&lt;form method&#x3D;&quot;传送方式&quot; action&#x3D;&quot;服务端文件&quot;&gt;&lt;&#x2F;form&gt; 只有设置了 name 属性的表单元素才能在提交表单时传递它们的值. css cascading style sheetscss 选择器(or 选择符){声明 属性：值}优先级 权值相同时 就近原则 离被设置元素越近优先级越高内联式 &gt; 嵌入式 &gt; 外部式嵌入式 &gt; 外部式 前提嵌入式样式位置在外部式后面 选择器权值 标签选择器 ID选择器 类选择器 后代选择器 子选择器 通用选择器 兄弟选择器 伪类选择符 分组选择符 继承权值：标签 1 类 10 ID 100 继承0.1 层叠 重要性浏览器默认样式 &lt; 网页制作者样式 &lt; 用户自己设置的样式!important 权值高于用户自己设置的样式 文字排版 letter-spacing word-spacing 内联元素之间有个间距 css 布局模型Flow流动模型 Float浮动模型 Layer层模型 字体缩写 font-style: italic; font-variant: small-caps; font-weight: bold; font-size: 12px; line-height: 1.5em; font-family: “Microsoft Yahei”,sans-serif; font: italic small-caps bold 12px/1.5em “Microsoft Yahei”,sans-serif; 参考：使用mailto在网页中链接Email地址]]></content>
      <categories>
        <category>学习笔记</category>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>前端</tag>
        <tag>html</tag>
      </tags>
  </entry>
</search>
